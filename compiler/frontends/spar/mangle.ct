.. File: mangle.ct
..
.. Variable and method name mangling
..
.. Return 'walk' or 'action', depending on the contents of 'actors'
.macro walkername t
.if ${member $t $(actors)}
.return action
.else
.return walker
.endif
.endmacro
..
.. Given an indent 'indent', the name 'var' of the variable that holds
.. the datastructure we're walking on, and a type 't', of that variable,
.. generate a return statement/
.macro generate_walker_return indent var t
$(indent)return $(var);
.endmacro
..
.. Given an indent 'ident' and a type 't', generate a list of local
.. declarations for the walker function of that type.
.macro generate_walker_locals indent var t
.if ${member ${stemname $t} ${typelist}}
$(indent)if( $(var) == NULL ){
$(indent)$(indent)return $(var);
$(indent)}
.endif
.endmacro
..
.. Given the name 'var' of the variable that holds the datastructure
.. we`re walking on, and the type 't' of that variable, generate a
.. signature for the walker function of the given type.
.macro generate_walker_signature var t
static $t mangle_$t_walker( $t $(var), mangle_data *ctx )
.endmacro
..
.. Given the name 'var' of the variable that holds the datastructure
.. we're walking on, and the type 't' of that variable, generate a forward
.. declaration for the walker function of the given type.
.macro generate_walker_declaration var t
static $t mangle_$t_walker( $t $(var), mangle_data *ctx );
.endmacro
..
.. Given an indent 'indent', a variable 'var' to walk into, the type of
.. the variable 'type', and the current type of the variable 'nowtype',
.. generate an invokation to an action.
.macro generate_action_call indent var type nowtype
.if ${eq $(type) $(nowtype)}
$(indent)$(var) = ($(type)) mangle_$(type)_action( $(var), ctx );
.else
$(indent)$(var) = ($(type)) mangle_$(type)_action( to_$(type)( $(var) ), ctx );
.endif
.endmacro
..
.. Given an indent 'indent', a variable 'var' to walk into, the type of
.. the variable 'type', and the current type of the variable 'nowtype',
.. generate an invokation to a walker.
.macro generate_walker_call indent var type nowtype
.if ${eq $(type) $(nowtype)}
$(indent)$(var) = ($(type)) mangle_$(type)_walker( $(var), ctx );
.else
$(indent)$(var) = ($(type)) mangle_$(type)_walker( to_$(type)( $(var) ), ctx );
.endif
.endmacro
..
.. Given an indent 'indent', a variable 'var' to walk into, the type of the
.. variable 'type', and the current type of the variable 'nowtype', generate
.. an invocation to an action or walker.
.macro generate_descent_call indent var type nowtype
.if ${member $(type) $(actors)}
.call generate_action_call "$(indent)" "$(var)" "$(type)" "$(nowtype)"
.else
.call generate_walker_call "$(indent)" "$(var)" "$(type)" "$(nowtype)"
.endif
.endmacro
..
.. Given an indent 'indent', a variable 'var', and a type 'type', generate
.. the body of an empty walker function.
.macro generate_empty_walker_body indent var type
$(indent)(void) ctx;
.endmacro
..
..
.. For which types are there actions defines?
.set actors
.append actors AbstractFunctionDeclaration
.append actors ArrayInitExpression
.append actors AssignOpExpression 
.append actors AssignStatement
.append actors BinopExpression
.append actors Block
.append actors BreakStatement
.append actors Cardinality
.append actors CastExpression
.append actors Catch
.append actors ClassDeclaration
.append actors ClassExpression
.append actors ClassIdExpression
.append actors ClassicForStatement
.append actors ConstructorDeclaration
.append actors ConstructorInvocationStatement
.append actors ContinueStatement
.append actors DeleteStatement
.append actors DoWhileStatement
.append actors FieldDeclaration
.append actors FieldExpression
.append actors FieldInvocationExpression
.append actors FieldInvocationStatement
.append actors ForStatement
.append actors ForeachStatement
.append actors FormalParameter
.append actors FormalParameter_list
.append actors FunctionDeclaration
.append actors GenericObjectType
.append actors GetLengthExpression
.append actors IfExpression
.append actors IfStatement
.append actors InstanceInitializer
.append actors InstanceInitializer
.append actors InstanceOfExpression
.append actors InterfaceDeclaration
.append actors InternalThrowStatement
.append actors MethodDeclaration
.append actors MethodInvocationExpression
.append actors MethodInvocationStatement
.append actors NativeFunctionDeclaration
.append actors NewArrayExpression
.append actors NewClassExpression
.append actors NewInitArrayExpression
.append actors OuterSuperConstructorInvocationStatement
.append actors OuterSuperFieldExpression
.append actors OuterSuperInvocationExpression
.append actors OuterSuperInvocationStatement
.append actors OuterThisExpression
.append actors PostDecrementExpression
.append actors PostIncrementExpression
.append actors ReturnStatement
.append actors ShortopExpression
.append actors SimpleTryStatement
.append actors StaticInitializer
.append actors SubscriptExpression
.append actors SuperConstructorInvocationStatement
.append actors SuperFieldExpression
.append actors SuperInvocationExpression
.append actors SuperInvocationStatement
.append actors SwitchStatement
.append actors ThisConstructorInvocationStatement
.append actors ThrowStatement
.append actors TryStatement
.append actors TypeDeclaration
.append actors TypeFieldExpression
.append actors TypeInstanceOfExpression
.append actors TypeInvocationExpression
.append actors TypeInvocationStatement
.append actors TypeName
.append actors TypeOf
.append actors TypeOfIf
.append actors UnopExpression
.append actors ValueReturnStatement
.append actors VariableName
.append actors VariableNameExpression
.append actors WaitCaseTimeout
.append actors WaitCaseValue
.append actors WaitStatement
.append actors WhereExpression
.append actors WhileStatement
.append actors declaration
.append actors expression_list
.append actors statement
.append actors statement_list
..
.insert tmcwalk.t
..
.set visit_types ${call calc_treewalk "MethodMapping_list VariableDeclaration MethodDeclaration" "$(actors)"}
..
/* File: mangle.c
 *
 * Mangle symbols in a Vnus program. This mangling has two
 * purposes:
 * 1. Ensure that all variable names have at least one '_' in their name.
 * 2. Ensure that all local variables are unique, so that one global
 *    symbol table can be used.
 */

#include <stdio.h>
#include <assert.h>
#include <tmc.h>
#include <string.h>

#include "defs.h"
#include "config.h"
#include "tmadmin.h"
#include "error.h"
#include "symbol_table.h"
#include "global.h"
#include "mangle.h"
#include "collect.h"
#include "typederive.h"
#include "typename.h"
#include "exprname.h"
#include "service.h"
#include "doimports.h"
#include "analyze.h"
#include "isconstant.h"
#include "iszero.h"
#include "constfold.h"
#include "substitute.h"
#include "regtype.h"
#include "inliner.h"
#include "ispure.h"
#include "codesize.h"
#include "dump.h"
#include "pragma.h"
#include "markfinal.h"
#include "collectassigned.h"
#include "getunbounds.h"
#include "countrefs.h"

// This is an extremely dirty trick to have fake method entries for
// a couple of special methods: we cast values that are unlikely
// to be valid pointers to the correct type.
// Barfff.
// TODO: do this better
#define SPAR_GETSIZE_METHODENTRY to_MethodEntry(1)
#define SPAR_ARRAYCLONE_METHODENTRY to_MethodEntry(3)
#define SPAR_ARRAYTOSTRING_METHODENTRY to_MethodEntry(5)
#define SPAR_ARRAYHASHCODE_METHODENTRY to_MethodEntry(7)
#define SPAR_ARRAYEQUALS_METHODENTRY to_MethodEntry(9)
#define SPAR_GETSIZEVECTOR_METHODENTRY to_MethodEntry(11)

static int inline_level = 0;

static bool is_special_method( MethodEntry me )
{
    return (
	SPAR_GETSIZE_METHODENTRY == me ||
	SPAR_ARRAYCLONE_METHODENTRY == me ||
	SPAR_ARRAYTOSTRING_METHODENTRY == me ||
	SPAR_ARRAYHASHCODE_METHODENTRY == me ||
	SPAR_ARRAYEQUALS_METHODENTRY == me ||
	SPAR_GETSIZEVECTOR_METHODENTRY == me
    );
}

.foreach t VariableName TypeName MainMethod
typedef ${alias $t} $t;
.endforeach

// One link in the jump chain. This jump chain is used to figure out
// the targets of break and continue statements.
typedef struct str_jumpchain_element {
    struct str_jumpchain_element *next;	// Next scope in context
    statement smt;			// The statement
    origsymbol *breaklabel;		// The break label on this stmt
    unsigned int analysis_level;	// The analysis stack depth at this lbl
    bool used_for_continue;
    bool used_for_break;
    ProgramState_list breaksource_states;
} jumpchain_element;

typedef struct str_mangle_data {
    statement_list breakout_declarations;
    statement_list mangled_pre_spill_smts;
    statement_list post_spill_smts;
    statement_list static_inits;
    statement_list dynamic_inits;
    modflags classflags;
    bool in_assign_lhs;
    bool in_constructor;
    bool in_typeof;
    bool in_pure_expression;
    SparProgram *prog;
    SparProgramUnit unit;
    tmsymbol *scopeptr;
    origsymbol_list ondemands;
    TypeEntry_list typelist;
    Entry_list symtab;
    tmsymbol owner;			// Fully qualified name of the owner
    tmsymbol packagename;
    int scopelevel;
    VarTranslation_list var_translations;
    VarMapping_list var_mappings;
    MethodMapping_list method_mappings;
    MethodMapping_list constructor_mappings;
    context where;
    TypeBinding_list typebindings;
    tmsymbol dynamic_init;		// Name of dynamic init of this class
    ProgramState_list states;		// Stack of program states for analysis.
    AbstractValue retval;
    type rettype;
    origin org;
    jumpchain_element *jumpchain;
    bool expand_inlines;
    bool static_context;
    expression_list notnull_asserted;	// Null-asserted symbols
    tmsymbol_list allowed_throws;	// List of allowed exceptions
} mangle_data;

.call generate_walker_forwards "$(visit_types)"
#line $[1+${tpllineno}] "${tplfilename}"

// Forward function declarations.
static expression get_compiletime_constant_SparProgram_field( SparProgram *prog, const_origsymbol fnm, tmsymbol tnm );
static VariableName mangle_VariableName_action( VariableName s, mangle_data *ctx );
static statement_list mangle_statement_list_action( statement_list sl, mangle_data *ctx );
static statement mangle_AssignStatement_action(
 AssignStatement smt,
 mangle_data *ctx
);
static statement mangle_statement_action( statement smt, mangle_data *ctx );
static FormalParameter mangle_FormalParameter_action( FormalParameter arg, mangle_data *ctx );
static expression mangle_VariableNameExpression_action( VariableNameExpression x, mangle_data *ctx );
static expression mangle_OuterThisExpression_action( OuterThisExpression x, mangle_data *ctx );
static statement mangle_ClassDeclaration_action( ClassDeclaration cl, mangle_data *ctx );
static bool mangle_type( SparProgram *prog, tmsymbol nm );
static bool visit_type( SparProgram *prog, const_origsymbol t );
static bool visit_type( mangle_data *ctx, const_type t );
static SparProgram mangle_SparProgram_method( SparProgram prog, MethodEntry me );
static MethodEntry bind_expression_method(
 mangle_data *ctx,
 const_expression x,
 const_origsymbol method,
 expression_list *this_parameters,
 bool *use_static_call,
 expression_list *parameters
);
static MethodEntry bind_type_method(
 mangle_data *ctx,
 const_origsymbol tnm,
 const_origsymbol method,
 expression_list *parameters
);
static expression mangle_FieldExpression_action( FieldExpression x, mangle_data *ctx );
static FieldDeclaration mangle_FieldDeclaration_action( FieldDeclaration t, mangle_data *ctx );
static void add_variable_translation( mangle_data *ctx, const_origsymbol from, const tmsymbol to, tmsymbol classname );
static statement mangle_ConstructorInvocationStatement_action( ConstructorInvocationStatement x, mangle_data *ctx );
static bool specialize_type( const_origin org, SparProgram *prog, const_origsymbol t, const_expression_list xl );
static bool mark_overridden_methods(
 const_TypeEntry_list typelist,
 const_Entry_list symtab,
 const_Signature s,
 const_type t
);
static bool mark_overridden_methods(
 const_TypeEntry_list typelist,
 const_Entry_list symtab,
 const_Signature s,
 const_origsymbol tnm
);
static void build_local_translation(
 mangle_data *ctx,
 const_origsymbol s
);
static tmsymbol translate_variable( mangle_data *ctx, const tmsymbol s );
static void visit_method(
 SparProgram *prog,
 tmsymbol t,
 const_Signature s,
 tmsymbol mangled_name,
 bool is_direct_call
);
static void visit_method(
 SparProgram *prog,
 MethodEntry *e,
 bool is_direct_call
);
static expression construct_special_method_expression(
 mangle_data *ctx,
 const_MethodEntry me,
 const_expression_list thisparameters,
 const_expression_list parameters
);

static bool has_final_flag( modflags flags )
{
    if( has_any_flag( flags, ACC_FINAL) ){
	return true;
    }
    if( !pref_strictanalysis ){
	return has_any_flag( flags, ACC_DEDUCED_FINAL );
    }
    return false;
}

/* Given a symbol 's' representing a type, return the translation of that
 * type, or return symbolNIL if it has no translation.
 */
static tmsymbol translate_type(
 SparProgram *prog,
 TypeEntry_list typelist,
 tmsymbol owner,
 tmsymbol packagename,
 const_origsymbol_list ondemands,
 TypeBinding_list *typebindings,
 const_origsymbol s
)
{
    tmsymbol res = canonify_type(
	prog,
	packagename,
	owner,
	ondemands,
	typebindings,
	s
    );
    if( res == tmsymbolNIL ){
        // No translation known, see if we can find something in
	// a superclass.
	const_TypeEntry e = lookup_TypeEntry( typelist, owner );
	if( e->tag == TAGClassEntry ){
	    const_ClassEntry ce = to_const_ClassEntry( e );

	    if( ce->super != typeNIL ){
		TypeEntry sce = lookup_TypeEntry( typelist, ce->super );
		assert( is_ConcreteTypeEntry( sce ) );
		if( showmangling ){
		    fprintf(
			stderr,
			"No translation for type '%s'; try recursively in context of superclass '%s'\n",
			s->sym->name,
			sce->name->sym->name
		    );
		}
		// See if the superclass can help to translate this.
		res = translate_type(
		    prog,
		    typelist,
		    sce->name->sym,
		    sce->package,
		    origsymbol_listNIL,	// We're not interested in imported types
		    &to_ConcreteTypeEntry(sce)->types,
		    s
		);
		if( showmangling ){
		    fputs( "Recursion completed\n", stderr );
		}
	    }
	}
    }
    if( res != tmsymbolNIL ){
	if( showmangling ){
	    fprintf(
		stderr,
		"mapped type '%s'->'%s'\n",
		s->sym->name,
		res->name
	    );
	}
    }
    return res;
}

/* Given a symbol 's' representing a type, return the translation of that
 * type, or return symbolNIL if it has no translation.
 */
static tmsymbol translate_type( mangle_data *ctx, const_origsymbol s )
{
    tmsymbol res = translate_type(
	ctx->prog,
	ctx->typelist,
	ctx->owner,
	ctx->packagename,
	ctx->ondemands,
	&ctx->typebindings,
	s
    );
    return res;
}

/* Given a type 't', return the translation of that
 * type, or return symbolNIL if it has no translation.
 */
static tmsymbol translate_type( mangle_data *ctx, const_type t )
{
    if( t->tag != TAGObjectType ){
	return tmsymbolNIL;
    }
    return translate_type( ctx, to_const_ObjectType(t)->name );
}

// Given a known local symbol, mangle it.
static tmsymbol mangle_local_symbol( const tmsymbol s )
{
    tmsymbol ans;

    if( s == tmsymbolNIL ){
	internal_error( "symbol is NIL" );
    }
    if( strchr( s->name, '_' ) == NULL ){
	tmstring s1 = printf_tmstring( "%s_", s->name );
	ans = gen_tmsymbol( s1 );
	rfre_tmstring( s1 );
    }
    else {
	ans = gen_tmsymbol( s->name );
    }
    assert( ans != tmsymbolNIL );
    return ans;
}

// Given a type symbol, return the mangled version.
static tmsymbol mangle_type_symbol( mangle_data *ctx, const_origsymbol s )
{
    if( s == origsymbolNIL ){
	return tmsymbolNIL;
    }
    tmsymbol ans = translate_type( ctx, s );
    if( ans == tmsymbolNIL ){
	origsymbol_error( s, "undefined type" );
    }
    return ans;
}

/* Given a translation table and a scope level, delete all entries
 * with higher scope levels.
 *
 * Note that scope levels should never decrease towards the end of the
 * list, so we should be able to start from the end and stop once the scope
 * level is below the specified level. This way is a bit safer (and slower).
 */
static VarTranslation_list delete_scopelevels_table(
 VarTranslation_list l,
 const char *desc,
 const int level
)
{
    unsigned int ix = 0;

    while( ix<l->sz ){
	VarTranslation tr = l->arr[ix];

	if( tr->level > level ){
	    if( showmangling ){
		fprintf(
		    stderr,
		    "Delete %s translation [%d] %s->%s\n",
		    desc,
		    tr->level,
		    tr->from->name,
		    tr->to->name
		);
	    }
	    l = delete_VarTranslation_list( l, ix );
	}
	else {
	    ix++;
	}
    }
    return l;
}

/* Given a variable mapping table and a scope level, delete all entries
 * with higher scope levels.
 *
 * Note that scope levels should never decrease towards the end of the
 * list, so we should be able to start from the end and stop once the scope
 * level is below the specified level. This way is a bit safer (and slower).
 */
static VarMapping_list delete_scopelevels_table(
 VarMapping_list l,
 const int level
)
{
    unsigned int ix = 0;

    while( ix<l->sz ){
	VarMapping tr = l->arr[ix];

	if( tr->level > level ){
	    if( showmangling ){
		fprintf(
		    stderr,
		    "Delete variable mapping [%d] %s-><expr>\n",
		    tr->level,
		    tr->from->name
		);
	    }
	    l = delete_VarMapping_list( l, ix );
	}
	else {
	    ix++;
	}
    }
    return l;
}

// Given a scope level, delete all entries with higher scope levels.
static void delete_scopelevels( mangle_data *ctx, const int level )
{
    if( showmangling ){
	fprintf(
	    stderr,
	    "Delete all translation levels higher than %d\n",
	    level
	);
    }
    ctx->var_translations = delete_scopelevels_table(
	ctx->var_translations,
	"variable",
	level
    );
    ctx->var_mappings = delete_scopelevels_table(
	ctx->var_mappings,
	level
    );
    ctx->scopelevel = level;
}

// Return a new abstract value that is as non-committal as possible.
static AbstractValue build_neutral_AbstractValue()
{
    return new_AbstractValue( AF_MAYBE, AF_MAYBE, false, expressionNIL );
}

// Given an expression, return true iff this initializes the variable.
static bool is_initialization( const_expression x )
{
    bool res = true;

    if( x == expressionNIL ){
        return true;
    }
    switch( x->tag ){
        case TAGAnnotationExpression:
	    res = is_initialization( to_const_AnnotationExpression(x)->x );
	    break;

        case TAGBracketExpression:
	    res = is_initialization( to_const_BracketExpression(x)->x );
	    break;

	case TAGDefaultValueExpression:
	    res = false;
	    break;

	default:
	    break;
    }
    return res;
}

// Given an optexpression, return true iff this initializes the variable.
static bool is_initialization( const_optexpression x )
{
    bool res = false;

    if( x == optexpressionNIL ){
        return true;
    }
    switch( x->tag ){
        case TAGOptExprNone:
	    break;

	case TAGOptExpr:
	    res = is_initialization( to_const_OptExpr(x)->x );
	    break;
    }
    return res;
}

// Given the stack of program states, the index of what we think of
// as the outer scope, and the name of a variable, return true
// iff the variable is mentioned in one of the scopes.
// If found, also make sure that there is an entry for the variable
// in the outer scope, and assign the index in the variable states
// to '*pos'.
static bool dredge_var_programstate(
 const_Entry_list symtab,
 ProgramState_list state,
 unsigned int outerix,
 tmsymbol var,
 unsigned int *pos
)
{
    unsigned int lvl;

    assert( outerix<state->sz );
    VarState_list vl = state->arr[outerix]->varStates;
    if( !search_var_programstates( state, outerix, var, &lvl, pos ) ){
	// See if the variable is a class member. If so,
	// pretend that there is yet another level of analysis that
	// records the state of these variables.
	const_VariableEntry e = lookup_VariableEntry( symtab, var );
	if( e != VariableEntryNIL ){
	    bool final = has_any_flag( e->flags, ACC_FINAL|ACC_DEDUCED_FINAL );
	    if( e->tag == TAGGlobalVariableEntry ){
		// Yep, create an entry for this variable, and tell
		// 'em we have been succesful.
		const_optexpression init = to_const_GlobalVariableEntry(e)->init;
		bool initialized = is_initialization( init );
		AbstractValue av;

		if( final && initialized ){
		    assert( init->tag == TAGOptExpr );
		    av = abstract_value( to_const_OptExpr(init)->x, state, symtab );
		}
		else {
		    av = build_neutral_AbstractValue();
		}
		VarState st = new_VarState(
		    var,
		    final,		// final?
		    true,		// Escapes?
		    initialized,	// definitely assigned?
		    !initialized, 	// definitely unassigned?
		    av
		);
		if( trace_analysis ){
		    fprintf( stderr, "static field '%s' incorporated into program state\n", var->name );
		}
		vl = append_VarState_list( vl, st );
		*pos = vl->sz-1;
		return true;
	    }
	    else if( e->tag == TAGFieldEntry ){
		// Yep, create an entry for this variable, and tell
		// 'em we have been succesful.
		AbstractValue av;
		const_optexpression init = to_const_FieldEntry(e)->init;
		bool initialized = is_initialization( init );

		if( final && initialized ){
		    assert( init->tag == TAGOptExpr );
		    av = abstract_value( to_const_OptExpr(init)->x, state, symtab );
		}
		else {
		    av = build_neutral_AbstractValue();
		}
		VarState st = new_VarState(
		    var,
		    final,		// final?
		    true,		// Escapes?
		    initialized,	// definitely assigned?
		    !initialized, 	// definitely unassigned?
		    av
		);
		if( trace_analysis ){
		    fprintf( stderr, "field '%s' incorporated into program state\n", var->name );
		}
		vl = append_VarState_list( vl, st );
		*pos = vl->sz-1;
		return true;
	    }
	    return false;
	}
	return false;
    }
    if( lvl != outerix ){
	unsigned int newpos = vl->sz;
	VarState st = rdup_VarState( state->arr[lvl]->varStates->arr[*pos] );

	if( !st->final ){
	    bool iterated = false;

	    for( unsigned int ix=lvl+1; ix<=outerix; ix++ ){
		iterated |= state->arr[ix]->iterated;
	    }
	    if( iterated ){
		// We must be careful in drawing conclusions from the
		// information we have until now, since the statements
		// are iterated, and statements later in the iteration
		// may spoil the state whe have now.
		AbstractValue v = st->value;
		v->zero = AF_MAYBE;
		v->positive = AF_MAYBE;
		v->constant = false;
		if( v->value != expressionNIL ){
		    rfre_expression( v->value );
		    v->value = expressionNIL;
		}
		if( trace_analysis ){
		    fprintf( stderr, "Variable '%s' may be overwritten later in an iteration.\n", var->name );
		}
	    }
	}
	// The variable is not represented at this level. Copy the
	// state from one of the level it does live on to the outer state.
	state->arr[outerix]->varStates = append_VarState_list(
	    state->arr[outerix]->varStates,
	    st
	);
	*pos = newpos;
    }
    return true;
}

// Given a variable name, register the fact that the variable is known not
// to be null.
static void register_not_null( const_Entry_list symtab, ProgramState_list states, tmsymbol nm )
{
    ProgramState topst = states->arr[states->sz-1];
    VarState_list vl = topst->varStates;
    unsigned int pos;

    if( dredge_var_programstate( symtab, states, states->sz-1, nm, &pos ) ){
	assert( pos<vl->sz );
	VarState v = vl->arr[pos];
	v->value->zero = AF_NO;
    }
    else {
	AbstractValue av = new_AbstractValue( AF_NO, AF_YES, false, expressionNIL );
	vl = append_VarState_list(
	    vl,
	    new_VarState(
	        nm,
		false,		// final?
		false,		// may escape?
		false,		// definitely assigned?
		false,		// definitely unassigned?
		av
	    )
	);
    }
    if( trace_analysis ){
	fprintf( stderr, "Deduction: variable '%s' is not null/0/false.\n", nm->name );
	dump_programstates( stderr, states );
    }
}

// Given a variable name, register the fact that the variable is known 
// to be positive.
static void register_positive( const_Entry_list symtab, ProgramState_list states, tmsymbol nm )
{
    ProgramState topst = states->arr[states->sz-1];
    VarState_list vl = topst->varStates;
    unsigned int pos;

    if( dredge_var_programstate( symtab, states, states->sz-1, nm, &pos ) ){
	assert( pos<vl->sz );
	VarState v = vl->arr[pos];
	v->value->positive = AF_YES;
    }
    else {
	AbstractValue av = new_AbstractValue( AF_MAYBE, AF_YES, false, expressionNIL );
	vl = append_VarState_list(
	    vl,
	    new_VarState(
	        nm,
		false,		// final?
		false,		// may escape?
		false,		// definitely assigned?
		false,		// definitely unassigned?
		av
	    )
	);
    }
    if( trace_analysis ){
	fprintf( stderr, "Deduction: variable '%s' is positive.\n", nm->name );
	dump_programstates( stderr, states );
    }
}

// Given a variable name, register the fact that the variable is known 
// to be positive.
static void register_negative( const_Entry_list symtab, ProgramState_list states, tmsymbol nm )
{
    ProgramState topst = states->arr[states->sz-1];
    VarState_list vl = topst->varStates;
    unsigned int pos;

    if( dredge_var_programstate( symtab, states, states->sz-1, nm, &pos ) ){
	assert( pos<vl->sz );
	VarState v = vl->arr[pos];
	v->value->positive = AF_NO;
    }
    else {
	AbstractValue av = new_AbstractValue( AF_MAYBE, AF_NO, false, expressionNIL );
	vl = append_VarState_list(
	    vl,
	    new_VarState(
	        nm,
		false,		// final?
		false,		// may escape?
		false,		// definitely assigned?
		false,		// definitely unassigned?
		av
	    )
	);
    }
    if( trace_analysis ){
	fprintf( stderr, "Deduction: variable '%s' is negative.\n", nm->name );
	dump_programstates( stderr, states );
    }
}

// Given a variable name, register the fact that the variable is not deletable
// upon termination of its scope.
static void register_escapes( mangle_data *ctx, tmsymbol nm, const char *reason )
{
    ProgramState topst = ctx->states->arr[ctx->states->sz-1];
    VarState_list vl = topst->varStates;
    unsigned int pos;

    if( dredge_var_programstate( ctx->symtab, ctx->states, ctx->states->sz-1, nm, &pos ) ){
	assert( pos<vl->sz );
	VarState v = vl->arr[pos];
	v->escapes = true;
    }
    else {
	AbstractValue av = new_AbstractValue( AF_MAYBE, AF_MAYBE, false, expressionNIL );
	vl = append_VarState_list(
	    vl,
	    new_VarState(
	        nm,
		false,
		true,		// may escape?
		false,		// definitely assigned?
		false,		// definitely unassigned?
		av
	    )
	);
    }
    if( trace_analysis ){
	fprintf( stderr, "Deduction: variable '%s' is not deletable. Reason: %s\n", nm->name, reason );
	dump_programstates( stderr, ctx->states );
    }
}

// Given a context and a return value, register the return value.
static void register_return_value( mangle_data *ctx, const_expression x )
{
    AbstractValue av = abstract_value( x, ctx->states, ctx->symtab );
    if( ctx->retval == AbstractValueNIL ){
        ctx->retval = av;
    }
    else {
	AbstractValue av1 = rdup_AbstractValue( av );
	abstract_thenelse( av, ctx->retval, av1 );
	rfre_AbstractValue( av1 );
	rfre_AbstractValue( ctx->retval );
	ctx->retval = av;
    }
}

// Given a variable name, register the fact that the variable is not deletable
// upon termination of the program.
static void register_escapes( mangle_data *ctx, origsymbol nm, const char *reason )
{
    register_escapes( ctx, nm->sym, reason );
}

// Forward declaration
static void register_escapes( mangle_data *ctx, const_expression_list x, const char *reason );

static void register_escapes( mangle_data *ctx, const_expression x, const char *reason )
{
    if( x == expressionNIL ){
        return;
    }
    switch( x->tag ){
        case TAGByteExpression:
        case TAGShortExpression:
        case TAGIntExpression:
        case TAGLongExpression:
        case TAGFloatExpression:
        case TAGDoubleExpression:
        case TAGCharExpression:
        case TAGBooleanExpression:
        case TAGStringExpression:
        case TAGNullExpression:
        case TAGSizeofExpression:
	case TAGFieldExpression:
	case TAGTypeFieldExpression:
	case TAGClassExpression:
	case TAGSuperFieldExpression:
	case TAGOuterThisExpression:
	case TAGMethodInvocationExpression:	// parms handled elsewhere
	case TAGFieldInvocationExpression:	// parms handled elsewhere
	case TAGTypeInvocationExpression:	// parms handled elsewhere
	case TAGSuperInvocationExpression:	// parms handled elsewhere
	case TAGOuterSuperInvocationExpression:	// parms handled elsewhere
	case TAGNewArrayExpression:		// parms handled elsewhere
	case TAGPostIncrementExpression:	// wrong type
	case TAGPostDecrementExpression:	// wrong type
	case TAGPreDecrementExpression:		// wrong type
	case TAGPreIncrementExpression:		// wrong type
	case TAGComplexExpression:		// wrong type
	case TAGTypeExpression:
	case TAGInstanceOfExpression:
	case TAGTypeInstanceOfExpression:
	case TAGClassInstanceOfExpression:
	case TAGInterfaceInstanceOfExpression:
	case TAGNewRecordExpression:
	case TAGGetBufExpression:
	case TAGGetSizeExpression:
	case TAGGetLengthExpression:
	case TAGInternalizeExpression:
	case TAGClassIdExpression:
	case TAGDefaultValueExpression:
	case TAGUnopExpression:
	case TAGOuterSuperFieldExpression:
	case TAGSubscriptExpression:
	case TAGVectorSubscriptExpression:
	    // Not interesting.
	    break;

	case TAGAnnotationExpression:
	    register_escapes( ctx, to_const_AnnotationExpression(x)->x, reason );
	    break;

	case TAGBracketExpression:
	    register_escapes( ctx, to_const_BracketExpression(x)->x, reason );
	    break;

	case TAGNotNullAssertExpression:
	    register_escapes( ctx, to_const_NotNullAssertExpression(x)->x, reason );
	    break;

	case TAGForcedCastExpression:
	    register_escapes( ctx, to_const_ForcedCastExpression(x)->x, reason );
	    break;

	case TAGCastExpression:
	    register_escapes( ctx, to_const_CastExpression(x)->x, reason );
	    break;

	case TAGWhereExpression:
	    register_escapes( ctx, to_const_WhereExpression(x)->x, reason );
	    break;

	case TAGBinopExpression:
	    register_escapes( ctx, to_const_BinopExpression(x)->left, reason );
	    register_escapes( ctx, to_const_BinopExpression(x)->right, reason );
	    break;

	case TAGShortopExpression:
	    register_escapes( ctx, to_const_ShortopExpression(x)->left, reason );
	    register_escapes( ctx, to_const_ShortopExpression(x)->right, reason );
	    break;

	case TAGIfExpression:
	    register_escapes( ctx, to_const_IfExpression(x)->thenval, reason );
	    register_escapes( ctx, to_const_IfExpression(x)->elseval, reason );
	    break;

	case TAGNewInitArrayExpression:
	    register_escapes( ctx, to_const_NewInitArrayExpression(x)->init, reason );
	    break;

	case TAGNewClassExpression:
	    register_escapes( ctx, to_const_NewClassExpression(x)->parameters, reason );
	    break;

	case TAGVariableNameExpression:
	    register_escapes( ctx, to_const_VariableNameExpression(x)->name, reason );
	    break;

	case TAGVectorExpression:
	    register_escapes( ctx, to_const_VectorExpression(x)->fields, reason );
	    break;

	case TAGArrayInitExpression:
	    register_escapes( ctx, to_const_ArrayInitExpression(x)->elements, reason );
	    break;

	case TAGAssignOpExpression:
	    internal_error( "should not occur here" );
    }
}

static void register_escapes( mangle_data *ctx, const_expression_list xl, const char *reason )
{
    if( xl == expression_listNIL ){
        return;
    }
    for( unsigned int ix=0; ix<xl->sz; ix++ ){
        register_escapes( ctx, xl->arr[ix], reason );
    }
}

// Given a list of actual expressions 'xl', a list of formal parameters
// 'formals' and a list of non-escaping formals, register all actual
// expressions as escaping for whom the corresponding formal parameter
// is not listed as non-escaping.
static void filtered_register_actuals(
    mangle_data *ctx,
    const_expression_list xl,
    FormalParameter_list formals,
    tmsymbol_list noescapes
)
{
    if( xl == expression_listNIL ){
        return;
    }
    if( xl->sz != formals->sz ){
	internal_error( "Number of formals is %u, actuals is %u", formals->sz, xl->sz );
    }

    for( unsigned int ix=0; ix<xl->sz; ix++ ){
	FormalParameter formal = formals->arr[ix];

	if( !member_tmsymbol_list( noescapes, formal->name->sym ) ){
	    // The formal parameter of this actual is not listed in
	    // the noescapes list, so we'll have to register it
	    // as escaping.
	    register_escapes( ctx, xl->arr[ix], "used as parameter" );
	}
    }
}

// Given a method entry and lists of actual parameters and actual
// this parameters, register all parameters that are not analyzed
// as non-escaped as escaped.
static void register_actual_escapes(
 mangle_data *ctx,
 const_MethodEntry me,
 expression_list parms,
 expression_list this_parms
)
{
    if( me->tag == TAGFunctionEntry ){
	// TODO: we have a noescapes list. Use it.
	const_FunctionEntry fe = to_const_FunctionEntry( me );

	tmsymbol_list noescapes = fe->noescape_formals;

	filtered_register_actuals( ctx, parms, fe->parameters, noescapes );
	filtered_register_actuals( ctx, this_parms, fe->thisparameters, noescapes );
    }
    else {
	register_escapes( ctx, parms, "used as parameter" );
	register_escapes( ctx, this_parms, "used as parameter" );
    }
}

// Register that a method throws the given type.
static void register_method_throw( ProgramState st, const_type t )
{
    if( t != typeNIL && t->tag == TAGObjectType ){
        origsymbol name = to_const_ObjectType(t)->name;
	st->thrown = add_tmsymbol_list( st->thrown, name->sym );
    }
}

// Register that a method is invoked with the given 'throws' list.
// We add the throws clause to the analysis administration to keep track
// of the methods that may be thrown.
static void register_method_throws( ProgramState_list states, const_type_list throws )
{
    assert( states->sz>0 );
    ProgramState topst = states->arr[states->sz-1];
    if( throws == type_listNIL ){
        return;
    }
    for( unsigned int ix=0; ix<throws->sz; ix++ ){
        register_method_throw( topst, throws->arr[ix] );
    }
}

// Register that we know that we will throw an exception.
static void register_throws_exception( ProgramState_list states, const_type t )
{
    assert( states->sz>0 );
    ProgramState topst = states->arr[states->sz-1];
    register_method_throw( topst, t );
    topst->throws = AF_YES;
}

// Register that we know that the statement/block does a return.
static void register_returns( ProgramState_list states )
{
    assert( states->sz>0 );
    ProgramState topst = states->arr[states->sz-1];
    topst->returns = AF_YES;
}

// Statement is a break or continue target. If it says it definitely
// does a jump, this is no longer true, since it may be caught here.
// TODO: do a more precise administration; in some circumstances
// we may be able to change this to 'AF_NO'.
static void register_jump_target( ProgramState_list states )
{
    assert( states->sz>0 );
    ProgramState topst = states->arr[states->sz-1];
    if( topst->jumps == AF_YES ){
	topst->jumps = AF_MAYBE;
    }
}

// Statement cannot complete normally. Register this in the analysis
// administration.
static void register_cannot_complete_normally( ProgramState_list states )
{
    assert( states->sz>0 );
    ProgramState topst = states->arr[states->sz-1];
    topst->jumps = AF_YES;
}

// Zap all the variables that are in ctx->notnull_asserted
static void zap_notnull_asserted( mangle_data *ctx )
{
    rfre_expression_list( ctx->notnull_asserted );
    ctx->notnull_asserted = new_expression_list();
}

// Register all the variables that are in ctx->notnull_asserted
static void register_notnull_asserted( mangle_data *ctx )
{
    for( unsigned int ix=0; ix<ctx->notnull_asserted->sz; ix++ ){
	expression x = ctx->notnull_asserted->arr[ix];

	if( x->tag == TAGVariableNameExpression ){
	    register_not_null( ctx->symtab, ctx->states, to_VariableNameExpression(x)->name->sym );
	}
    }
    zap_notnull_asserted( ctx );
}

// Zap all the variables that are in ctx->notnull_asserted from
// 'pos' onwards.
static void zapto_notnull_asserted( mangle_data *ctx, unsigned int pos )
{
    if( pos<ctx->notnull_asserted->sz ){
	ctx->notnull_asserted = deletelist_expression_list(
	    ctx->notnull_asserted,
	    pos,
	    ctx->notnull_asserted->sz
	);
    }
}

// Given the current context, return the number of notnull asserted
// variables pending.
static unsigned int getsize_notnull_asserted( mangle_data *ctx )
{
    return ctx->notnull_asserted->sz;
}

// Given a type, a method name and an expression 'x', construct a method call
// that invokes the method in the type with the expression.
//
// 'parms' is consumed.
static expression build_staticCall(
    mangle_data *ctx,
    const char *type_name,
    const char *method_name,
    expression_list parms
)
{
    origsymbol str_name = add_origsymbol( type_name );
    origsymbol v_name = add_origsymbol( method_name );

    MethodEntry e = bind_type_method( ctx, str_name, v_name, &parms );
    if( e == MethodEntryNIL ){
	internal_error( "cannot build static call for %s.%s(...)", type_name, method_name );
    }
    register_method_throws( ctx->states, e->throws );
    rfre_origsymbol( str_name );
    rfre_origsymbol( v_name );
    expression res = new_MethodInvocationExpression(
	new_MethodInvocation(
	    expressionNIL,
	    add_origsymbol( e->name ),
	    new_expression_list(),		// This parameters
	    parms,
	    0
	)
    );
    return res;
}

// Given a type, a method name and an expression 'x', construct a method call
// that invokes the method in the type with the expression.
//
// 'x' is consumed.
static expression build_staticCall1Expression(
    mangle_data *ctx,
    const char *type_name,
    const char *method_name,
    expression x
)
{
    expression_list parms = new_expression_list();
    parms = append_expression_list( parms, x );
    return build_staticCall( ctx, type_name, method_name, parms );
}

// Given an expression 'x' presumably representing a Vnus string,
// wrap it in a conversion to a Spar string.
static expression internalize_Vnus_string( mangle_data *ctx, expression x )
{
    origsymbol str_name = add_origsymbol( "spar.compiler.Internalize" );
    tmsymbol v_name = add_tmsymbol( "internalize" );

    tmsymbol callfrom_type = ctx->owner;
    bool is_static;
    bool use_static_call;
    tmsymbol tr_tnm = translate_type( ctx, str_name );

    bool ok = visit_type( ctx->prog, str_name );
    rfre_origsymbol( str_name );
    if( !ok ){
	return x;
    }
    Signature s = new_Signature(
	0,
	v_name,
	append_type_list( new_type_list(), new_PrimitiveType( BT_STRING ) )
    );
    MethodEntry me = bind_Method(
	ctx->prog,
	ctx->symtab,
	ctx->typelist,
	tr_tnm,			// Where to search the method.
	callfrom_type,		// Where are we calling from.
	s,			// What are we looking for.
	&is_static,
	&use_static_call,
	ctx->org
    );
    rfre_Signature( s );
    if( me == MethodEntryNIL ){
	internal_error( "cannot build call for string internalization" );
    }
    if( !is_static ){
        internal_error( "string internalization method should be static" );
    }
    if( !use_static_call ){
        internal_error( "string internalization method should be called statically" );
    }
    register_method_throws( ctx->states, me->throws );
    visit_method( ctx->prog, &me, is_static );
    return new_InternalizeExpression( me->name, x );
}

// Given a context 'ctx' and an expression 'x', return an
// expression that does string conversion on 'x' by invoking the
// toString() method of 'x'. Also generate code to test the return of
// the call, and subsitute the string "null" if necessary.
//
// This function must consume expression 'x', and either
// incorporate it in the returned expression, or delete it.
//
// We known that 'x' cannot be null.
static expression build_tostring_call( mangle_data *ctx, const_expression x )
{
    origsymbol toString_name = add_origsymbol( "toString" );
    expression_list parms = new_expression_list();
    expression_list this_parameters = new_expression_list();
    bool use_static_call;
    expression res;

    MethodEntry method = bind_expression_method(
	ctx,
	x,
	toString_name,
	&this_parameters,
	&use_static_call,
	&parms
    );
    rfre_origsymbol( toString_name );
    if( is_special_method( method ) ){
	res = construct_special_method_expression(
	    ctx,
	    method,
	    this_parameters,
	    parms
	);
	rfre_expression_list( this_parameters );
	rfre_expression_list( parms );
    }
    else {
	register_method_throws( ctx->states, method->throws );
	expression vtab = expressionNIL;
	if( !use_static_call ){
	    vtab = rdup_expression( x );
	}
	res = new_MethodInvocationExpression(
	    new_MethodInvocation(
		vtab,
		add_origsymbol( method->name ),
		this_parameters,
		parms,
		0
	    )
	);
    }
    return res;
}

// Given a context 'ctx' and an expression 'x', return an
// expression that does string conversion on 'x' by invoking 
// spar.compiler.StringConversion.convert( x ). 
//
// This function consumes expression 'x'; it either
// incorporates it in the returned expression, or deletes it.
static expression build_stringconversion_call( mangle_data *ctx, expression x )
{
    expression res = build_staticCall1Expression(
	ctx,
	"spar.compiler.StringConversion",
	"convert",
	x
    );
    return res;
}

// Given an expression `x', wrap it in an expression to convert it to a
// java.lang.String. In obvious cases, return a string constant.
static expression build_stringConvert_expression( mangle_data *ctx, expression x )
{
    expression res;

    if( x == expressionNIL || x->tag == TAGNullExpression ){
	rfre_expression( x );
	return internalize_Vnus_string(
	    ctx,
	    new_StringExpression( new_tmstring( "null" ) )
	);
    }
    // TODO: Something stinks here: where are floats and doubles handled?
    // Either they're always handled in constant folding, and this stuff
    // is superfluous, or this stuff is needed, and floats and doubles
    // are missing.
    if( x->tag == TAGByteExpression ){
	tmstring s = printf_tmstring( "%d", (int) to_ByteExpression(x)->v );

	rfre_expression( x );
	x = new_StringExpression( s );
    }
    else if( x->tag == TAGShortExpression ){
	tmstring s = printf_tmstring( "%d", (int) to_ShortExpression(x)->v );

	rfre_expression( x );
	x = new_StringExpression( s );
    }
    else if( x->tag == TAGIntExpression ){
	tmstring s = printf_tmstring( "%ld", (long) to_IntExpression(x)->v );

	rfre_expression( x );
	x = new_StringExpression( s );
    }
    else if( x->tag == TAGLongExpression ){
	tmstring s = printf_tmstring( "%lld", (long long) to_LongExpression(x)->v );

	rfre_expression( x );
	x = new_StringExpression( s );
    }
    else if( x->tag == TAGCharExpression ){
        char buf[30];
	vnus_char c = to_CharExpression(x)->c;

	if( c<0x100 ){
	    buf[0] = c;
	    buf[1] = '\0';
	}
	else {
	    sprintf( buf, "\\u%04x", (int) c );
	}
	rfre_expression( x );
	x = new_StringExpression( new_tmstring( buf ) );
    }
    else if( x->tag == TAGBooleanExpression ){
        vnus_boolean b = to_BooleanExpression(x)->b;

	rfre_expression( x );
	x = new_StringExpression( new_tmstring( b?"true":"false" ) );
    }

    // Now wrap all string constants in an internalization.
    if( x->tag == TAGStringExpression ){
	return internalize_Vnus_string( ctx, x );
    }
    type t = derive_type_expression( ctx->symtab, x );
    if( t == typeNIL ){
	rfre_expression( x );
	rfre_type( t );
	return internalize_Vnus_string(
	    ctx,
	    new_StringExpression( new_tmstring( "null" ) )
	);
    }
    if( is_ReferenceType( t ) ){
        if( is_zero( x, ctx->states ) == AF_NO ){
	    // We *know* `x' cannot be zero, so we can blindly invoke
	    // the toString method on it.
	    //
	    // TODO: break out side-effect expressions.
	    // TODO: what if toString returns 0?
	    res = build_tostring_call( ctx, x );
	    rfre_expression( x );
	}
	else {
	    res = build_stringconversion_call( ctx, x );
	}
	rfre_type( t );
    }
    else if( t->tag == TAGVoidType ){
	rfre_type( t );
        origin_error( ctx->org, "Cannot convert a void to a String" );
	res = expressionNIL;
    }
    else {
	// TODO: handle tuples more sanely. We could get away with
	// some kind of string that just says `tuple', but elegant it ain't.
	//
	// For now we stupidly assume that this is a scalar expression,
	// and the toString method can neatly be replaced with the
	// relevant java.lang.String.valueOf() method.
	// Also note that we don't ever have to test for null here.
	res = build_staticCall1Expression(
	    ctx,
	    "java.lang.String",
	    "valueOf",
	    x
	);
	rfre_type( t );
    }
    return res;
}

// Given an expression, return true iff we know it represent the empty string.
static bool is_empty_string( const_expression x )
{
    if( x == expressionNIL ){
        return false;
    }
    if( x->tag == TAGInternalizeExpression ){
        return is_empty_string( to_const_InternalizeExpression(x)->x );
    }
    else if( x->tag == TAGStringExpression ){
        return (to_const_StringExpression(x)->s[0] == '\0');
    }
    return false;
}

// Given two string expressions 'left' and 'right', return an
// expression that concatenates the two. 
// The function uses copies of `left' and `right, so it's up to
// the caller to destroy the originals, if necessary.
static expression build_string_concat( mangle_data *ctx, const_expression left, const_expression right )
{
    if( left == expressionNIL || is_empty_string( left ) ){
        return rdup_expression( right );
    }
    if( right == expressionNIL || is_empty_string( right ) ){
        return rdup_expression( left );
    }
    origsymbol concat_name = add_origsymbol( "concat" );
    expression_list parms = new_expression_list();
    expression_list this_parameters = new_expression_list();
    bool use_static_call;

    parms = append_expression_list( parms, rdup_expression( right ) );
    MethodEntry method = bind_expression_method(
	ctx,
	left,
	concat_name,
	&this_parameters,
	&use_static_call,
	&parms
    );
    register_method_throws( ctx->states, method->throws );
    rfre_origsymbol( concat_name );
    expression res = new_MethodInvocationExpression(
	new_MethodInvocation(
	    expressionNIL,
	    add_origsymbol( method->name ),
	    this_parameters,
	    parms,
	    0
	)
    );
    return res;
}

// Given an expression that presumably represents a reference, construct
// an expression that causes a null pointer exception to be thrown
// when necessary.
static expression build_notnullassert( mangle_data *ctx, expression x )
{
    if( pref_nonotnullassert || ctx->in_typeof ){
	return x;
    }
    // TODO: generate special code if the result below is AF_YES.
    if( is_zero( x, ctx->states ) != AF_NO ){
	if( x->tag == TAGVariableNameExpression || ctx->in_pure_expression ){
	    if( occurs_expression_list( ctx->notnull_asserted, x ) ){
		// Already null asserted.
	        return x;
	    }

	    // Since the evaluation of this expression only completes when
	    // the expression is not null, register the variable as
	    // being not null.
	    ctx->notnull_asserted = append_expression_list(
		ctx->notnull_asserted,
		rdup_expression( x )
	    );
	    if( trace_analysis ){
	        dump_expression( stderr, x, "Registered a new expression as not null" );
	    }
	}
	x = new_NotNullAssertExpression( x );
    }
    return x;
}

// Given an expression list presumably containing reference expressions (e.g.
// a list of 'this' parameters', construct expressions that cause a null
// pointer exceptions to be thrown if necessary.
static expression_list build_notnullassert( mangle_data *ctx, expression_list l )
{
    if( l != expression_listNIL ){
	for( unsigned int ix=0; ix<l->sz; ix++ ){
	    l->arr[ix] = build_notnullassert( ctx, l->arr[ix] );
	}
    }
    return l;
}

// Given a list of interfaces, visit them.
static bool visit_interfaces( mangle_data *ctx, const_type_list interfaces )
{
    bool ok = true;

    for( unsigned int ix=0; ix<interfaces->sz; ix++ ){
	const_type interface = interfaces->arr[ix];
	if( interface == typeNIL ){
	    continue;
	}
	assert( interface->tag == TAGObjectType );
	origsymbol interface_name = to_const_ObjectType( interface )->name;
	if( interface_name == origsymbolNIL ){
	    continue;
	}
	if( !visit_type( ctx->prog, interface_name ) ){
	    return false;
	}
	interface_name->sym = mangle_type_symbol( ctx, interface_name );
	if( interface_name->sym != tmsymbolNIL ){
	    const_TypeEntry e = lookup_TypeEntry( ctx->typelist, interface_name );

	    if( e != TypeEntryNIL ){
		if( e->tag == TAGClassEntry ){
		    origsymbol_error( interface_name, "Cannot implement a class" );
		    return false;
		}
		else if( e->tag != TAGInterfaceEntry ){
		    origsymbol_error( interface_name, "Cannot implement this" );
		    return false;
		}
	    }
	    ctx->typelist = register_subclass(
		ctx->typelist,
		interface_name,
		ctx->owner
	    );
	}
    }
    return ok;
}

// Given a pointer to a SparProgram 'prog' and the mangled name of a
// method 'mangled_name', make sure that the type of that method is loaded,
// and that the method with that signature is mangled.
//
// If 'is_direct_call' is true, we know for sure that this method is called
// directly.
static void mangle_method( SparProgram *prog, tmsymbol mangled_name, bool is_direct_call )
{
    MethodEntry e = lookup_MethodEntry( (*prog)->symtab, mangled_name );
    if( e == MethodEntryNIL ){
	internal_error( "cannot force compilation of '%s'", mangled_name->name );
    }
    if( is_direct_call ){
	e->directusecount++;
    }
    else {
	e->isvirtuallyused = true;
    }
    if( trace_usage ){
	fprintf(
	    stderr,
	    "mangle_method(): method '%s' is used %sdirectly. directusecount=%ld, isvirtuallyused=%s\n",
	    mangled_name->name,
	    is_direct_call?"":"in",
	    (long) e->directusecount,
	    e->isvirtuallyused?"true":"false"
	);
    }
    if( e->tag != TAGForwardFunctionEntry ){
	if( trace_usage ){
	    fprintf( stderr, "method '%s' is already mangled, no further action needed\n", mangled_name->name );
	}
	return;
    }
    ForwardFunctionEntry fe = to_ForwardFunctionEntry(e);
    if( fe->mangled ){
	// This method is already being mangled, don't try to do that again
	// (stops a recursion).
	return;
    }
    fe->mangled = true;
    *prog = mangle_SparProgram_method( *prog, e );
}

// Given a pointer to a SparProgram 'prog' and the mangled name of a
// constructor 'mangled_name', make sure that the type of that constructor is
// loaded, and that the constructor with that signature is mangled.
//
// Note that a constructor is always called directly.
static MethodEntry mangle_constructor( SparProgram *prog, tmsymbol mangled_name )
{
    MethodEntry e = lookup_MethodEntry( (*prog)->symtab, mangled_name );
    if( e == MethodEntryNIL ){
	return e;
    }
    assert( !e->isvirtuallyused );
    e->directusecount++;
    if( trace_usage ){
	fprintf( stderr, "constructor '%s' is used. directusecount=%ld\n", mangled_name->name, (long) e->directusecount );
    }
    if( e->tag != TAGForwardFunctionEntry ){
	if( trace_usage ){
	    fprintf( stderr, "constructor '%s' is already mangled, no further action needed\n", mangled_name->name );
	}
	return e;
    }
    ForwardFunctionEntry fe = to_ForwardFunctionEntry(e);
    if( fe->mangled ){
	// This method is already being mangled, don't try to do that again.
	// This avoids an infinite recursion.
	return e;
    }
    fe->mangled = true;
    *prog = mangle_SparProgram_method( *prog, to_MethodEntry( e ) );
    return lookup_MethodEntry( (*prog)->symtab, mangled_name );
}

// Given a type entry 'te', mark all subclasses of this type as used.
static void visit_method_in_subclasses( SparProgram *prog, const_TypeEntry te, const_Signature name, tmsymbol mangled_name )
{
    tmsymbol_list subclasses = te->subclasses;

    if( trace_usage ){
	tmstring sig = typename_Signature( name );
	fprintf( stderr, "visiting method '%s' in subclasses of '%s'\n", sig, te->name->sym->name );
	rfre_tmstring( sig );
    }
    for( unsigned int ix=0; ix<subclasses->sz; ix++ ){
	tmsymbol subclass = subclasses->arr[ix];
	tmsymbol mnm = lookup_mangledname_type(
	    (*prog)->typelist,
	    subclass,
	    name
	);
	if( mnm != tmsymbolNIL && mnm != mangled_name ){
	    // Only do this if the subclass in fact overrides this method.
	    MethodEntry e = lookup_MethodEntry( (*prog)->symtab, mangled_name );
	    if( e != MethodEntryNIL ){
		e->isoverridden = true;
	    }
	    visit_method( prog, subclasses->arr[ix], name, mnm, false );
	}
	else {
	    // This subclass does not override the method, but a further
	    // subclass might.
	    TypeEntry sub_te = lookup_TypeEntry( (*prog)->typelist, subclass );
	    visit_method_in_subclasses( prog, sub_te, name, mangled_name );
	}
    }
    if( trace_usage ){
	tmstring sig = typename_Signature( name );
	fprintf( stderr, "method '%s' in subclasses of '%s' have been visited\n", sig, te->name->sym->name );
	rfre_tmstring( sig );
    }
}

// Given the current program context, the type in which the invoked
// method occurs 't', and the invoked method 's', register a visit
// to this method.
//
// If 'is_direct_call' is true, we know for sure that this exact method
// will be called.
static void visit_method(
 SparProgram *prog,
 tmsymbol t,
 const_Signature s,
 tmsymbol mangled_name,
 bool is_direct_call
)
{
    if( mangled_name == tmsymbolNIL ){
	return;
    }
    if( trace_usage ){
	tmstring sig = typename_Signature( s );
	fprintf(
	    stderr,
	    "method '%s.%s' (='%s') is used %sdirectly\n",
	    t->name,
	    sig,
	    mangled_name->name,
	    is_direct_call?"":"in"
	);
	rfre_tmstring( sig );
    }
    mangle_method( prog, mangled_name, is_direct_call );
    if( !is_direct_call ){
	// Also visit the method in any subclasses that override
	// this method. Note that this only happens for calls
	// through a virtual table; direct calls (including all
	// static calls) never influence the usage administration
	// of methods in subclasses.
	TypeEntry e = lookup_TypeEntry( (*prog)->typelist, t );
	if( e != TypeEntryNIL ){
	    assert( is_ConcreteTypeEntry( e ) );
	    visit_method_in_subclasses( prog, e, s, mangled_name );
	}
    }
}

// As above, but for the case we have an entry 'e' in the symbol table
// for the method.
// This is a bit tricky, since 'e' may refer to a ForwardFunctionEntry,
// and during the visiting operation it will disappear.
// Therefore this function may replace '*e' with a new pointer.
//
// If 'is_direct_call' is set, we know for sure that this method is
// called directly.
static void visit_method(
 SparProgram *prog,
 MethodEntry *e,
 bool is_direct_call
)
{
    if( *e == MethodEntryNIL ){
	return;
    }
    if( (*e)->tag != TAGForwardFunctionEntry ){
	// This method has already been registered in the symboltable,
	// so all we have to do now is mark it as used.
	if( is_direct_call ){
	    (*e)->directusecount++;
	}
	else {
	    (*e)->isvirtuallyused = true;
	}
	return;
    }
    tmsymbol mangled_name = (*e)->name;
    if( trace_usage ){
	tmstring sig = typename_Signature( (*e)->realname );
	fprintf(
	    stderr,
	    "method '%s.%s' (='%s') is used\n",
	    (*e)->owner->name,
	    sig,
	    mangled_name->name
	);
	rfre_tmstring( sig );
    }
    mangle_method( prog, mangled_name, is_direct_call );
    Entry res = lookup_Entry( (*prog)->symtab, mangled_name );
    if( res == EntryNIL ){
	return;
    }
    assert( is_MethodEntry( res ) );
    *e = to_MethodEntry( res );
    if( !is_direct_call ){
	// If this is a virtual call, also visit all methods
	// override this method. Note that this is not necessary for
	// methods that are directly called.
	const_TypeEntry te = lookup_TypeEntry( (*prog)->typelist, (*e)->owner );
	if( te != TypeEntryNIL ){
	    assert( is_ConcreteTypeEntry( te ) );
	    visit_method_in_subclasses( prog, te, (*e)->realname, (*e)->name );
	}
    }
}

// Force a visit on all virtually used methods in the given class that are
// listed in the given method mappings.
static void visit_virtually_used_methods(
 mangle_data *ctx, 
 const_origsymbol clazz,
 MethodMapping_list method_mappings
)
{
    if( method_mappings == NULL ){
	return;
    }
    for( unsigned int ix=0; ix<method_mappings->sz; ix++ ){
	const_MethodMapping mm = method_mappings->arr[ix];
	const_Signature s = mm->realname;

	if( mark_overridden_methods( ctx->typelist, ctx->symtab, s, clazz ) ){
	    if( trace_usage ){
		tmstring sig = typename_Signature( s );
		fprintf(
		    stderr,
		    "overridden method '%s.%s' is used virtually, so method '%s' is used virtually too\n",
		    clazz->sym->name,
		    sig,
		    mm->mangledname->name
		);
		rfre_tmstring( sig );
	    }
	    mangle_method( ctx->prog, mm->mangledname, false );
	}
	else {
	    if( trace_usage ){
		fprintf(
		    stderr,
		    "method '%s' does not override a virtually used method in type '%s'\n",
		    mm->mangledname->name,
		    clazz->sym->name
		);
	    }
	}
    }
}

// Given a mangle context, a superclass, a list of interfaces, and a method
// entry, visit methods that are overridden by this method.
static void visit_overridden_methods(
 mangle_data *ctx,
 const_type super,
 const_type_list interfaces
)
{
    if( super != typeNIL ){
	if( super->tag == TAGObjectType ){
	    const_origsymbol supernm = to_const_ObjectType(super)->name;
	    visit_virtually_used_methods( ctx, supernm, ctx->method_mappings );
	}
    }
    for( unsigned int ix=0; ix<interfaces->sz; ix++ ){
	const_type interface = interfaces->arr[ix];

	if( interface == typeNIL || interface->tag != TAGObjectType ){
	    continue;
	}
	origsymbol interface_name = to_const_ObjectType( interface )->name;
	interface_name->sym = mangle_type_symbol( ctx, interface_name );
	if( interface_name->sym == tmsymbolNIL ){
	    continue;
	}
	visit_virtually_used_methods( ctx, interface_name, ctx->method_mappings );
    }
}

// Given a method entry 'e' for an inlined method, return an expanded version
// of the method body. The lists of 'this' and normal parameters are used
// to initialize the formal parameters that are now local variables of
// the returned wrapper block.
static Block expand_inlined_method(
 mangle_data *ctx,
 MethodEntry e,
 const_origin org,
 const_expression_list this_parms,
 const_expression_list parms,
 tmsymbol retvar
)
{
    if( e == MethodEntryNIL ){
	return BlockNIL;
    }
    if( inline_level>=MAX_INLINE_DEPTH ){
	origin_error( org, "This is level %d of inlining; I give up", MAX_INLINE_DEPTH );
	exit( 1 );
    }
    inline_level++;
    if( trace_inlining ){
	tmstring sig = typename_Signature( e->realname );
	fprintf(
	    stderr,
	    "inlined method '%s.%s' is expanded\n",
	    e->owner->name,
	    sig
	);
	rfre_tmstring( sig );
    }
    if( e->directusecount<1 ){
	internal_error( "Bad use count for '%s'", e->name->name );
    }
    else {
	e->directusecount--;
    }
    Block blk = inline_method( ctx->symtab, e, org, this_parms, parms, retvar );
    countrefs_Block( blk, ctx->symtab, 1 );
    inline_level--;
    return blk;
}

// Expand an invocation to a macro in an expression to a simpler
// expression. This may leave a macro block in the list of spilled
// statements. If value_ignored is set, we know that the result of the
// method invocation will never be used. In that case we can generate
// somewhat smarter code.
static expression expand_inlined_expression(
 mangle_data *ctx,
 MethodEntry e,
 const_origin org,
 const_expression_list this_parms,
 const_expression_list parms,
 bool value_ignored
)
{
    tmsymbol mangled_retvar = tmsymbolNIL;
    
    if( !value_ignored ){
	tmsymbol retvar = gen_tmsymbol( "retvar" );
	FieldDeclaration fd = new_FieldDeclaration(
	    rdup_origin( org ),
	    Pragma_listNIL,
	    origsymbol_listNIL,
	    0,
	    false,
	    new_origsymbol( retvar, rdup_origin( org ) ),
	    rdup_type( e->t ),
	    new_OptExprNone()
	);
.call generate_descent_call "	" fd FieldDeclaration FieldDeclaration
	ctx->mangled_pre_spill_smts = append_statement_list(
	    ctx->mangled_pre_spill_smts,
	    fd
	);
	mangled_retvar = fd->name->sym;
    }
    Block blk = expand_inlined_method(
	ctx,
	e,
	org,
	this_parms,
	parms,
	mangled_retvar
    );
    if( blk == BlockNIL ){
	return expressionNIL;
    }
    if( !value_ignored ){
	expression v = extract_trivial_inline_expression( blk, mangled_retvar );
	if( v != expressionNIL ){
	    // The inlined block is trivial, and evaluates to the given
	    // expression. We might as well return the expression instead
	    // of the block.
	    rfre_Block( blk );
	    return v;
	}
    }
    ctx->mangled_pre_spill_smts = append_statement_list(
	ctx->mangled_pre_spill_smts,
	new_BlockStatement(
	    rdup_origin( org ),
	    Pragma_listNIL,
	    origsymbol_listNIL,
	    blk
	)
    );
    if( value_ignored ){
        return expressionNIL;
    }
    expression res = new_VariableNameExpression(
	new_origsymbol( mangled_retvar, rdup_origin( org ) ),
	VAR_GENERATED|VAR_LOCAL|VAR_FINAL
    );

    return res;
}

// Given the current program context, the type in which the invoked
// constructor occurs 't', and the invoked constructor 's', register a visit
// to this constructor.
static MethodEntry visit_constructor( SparProgram *prog, tmsymbol t, const_Signature s, tmsymbol mangled_name )
{
    if( mangled_name == tmsymbolNIL ){
	return MethodEntryNIL;
    }
    if( trace_usage ){
	tmstring sig = typename_Signature( s );
	fprintf(
	    stderr,
	    "constructor '%s.%s' (='%s') is used\n",
	    t->name,
	    sig,
	    mangled_name->name
	);
	rfre_tmstring( sig );
    }
    return mangle_constructor( prog, mangled_name );
}

// Given the current program and a type 't', register a visit to this type.
static bool visit_type( SparProgram *prog, const_origin org, tmsymbol t )
{
    bool ok = compile_type( prog, t );
    if( !ok ){
	origin_error( org, "Unknown type '%s'", t->name );
	if( trace_typelist ){
	    dump_TypeEntry_list( stderr, (*prog)->typelist, "Current type list" );
	}
	return false;
    }
    if( trace_usage ){
	fprintf( stderr, "type '%s' is used\n", t->name );
    }
    ok &= mangle_type( prog, t );
    return ok;
}

static bool visit_type( SparProgram *prog, const_origsymbol t )
{
    if( t == origsymbolNIL ){
	return false;
    }
    bool ok = compile_type( prog, t->sym );
    if( !ok ){
	origsymbol_error( t, "Unknown type" );
	return false;
    }
    if( trace_usage ){
	fprintf( stderr, "type '%s' is used\n", t->sym->name );
    }
    ok = mangle_type( prog, t->sym );
    return ok;
}

static bool visit_type( mangle_data *ctx, const_type_list tl )
{
    for( unsigned int ix=0; ix<tl->sz; ix++ ){
	if( !visit_type( ctx, tl->arr[ix] ) ){
	    return false;
	}
    }
    return true;
}

// Given a fully qualified type name 't', make sure that the type is
// present in the list of compilation units of the SparProgram '*prog'.
// If necessary compile the source file of the type.
static bool visit_type( mangle_data *ctx, const_type t )
{
    bool ok = true;

    if( t == typeNIL ){
	return ok;
    }
    switch( t->tag ){
	case TAGPrimitiveType:
	case TAGTypeType:
	case TAGNullType:
	case TAGVoidType:
	case TAGExceptionVariableType:
	case TAGGCRefLinkType:
	case TAGGCTopRefLinkType:
	    break;

	case TAGArrayType:
	    ok = visit_type( ctx, to_const_ArrayType( t )->elmtype );
	    break;

	case TAGPrimArrayType:
	    ok = visit_type( ctx, to_const_PrimArrayType( t )->elmtype );
	    break;

	case TAGPragmaType:
	    ok = visit_type( ctx, to_const_PragmaType( t )->t );
	    break;

	case TAGObjectType:
	{
	    // tmsymbol tr_t = translate_type( ctx, to_const_ObjectType( t )->name );
	    origsymbol tnm_org = to_const_ObjectType( t )->name;
	    if( tnm_org != origsymbolNIL ){
		tmsymbol tnm = tnm_org->sym;
		tmsymbol tnm_long = search_TypeBinding( ctx->typebindings, tnm );
		if( tnm_long != tmsymbolNIL ){
		    tnm = tnm_long;
		}
		ok = visit_type( ctx->prog, tnm_org->org, tnm );
	    }
	    break;
	}

	case TAGGenericObjectType:
	    // Not necessary to do it here, since this is taken care of
	    // separately.
	    //ok = visit_type( prog, to_const_GenericObjectType( t )->name );
	    break;

	case TAGTypeOf:
	case TAGTypeOfIf:
	case TAGFunctionType:
	    break;

	case TAGTupleType:
	    ok = visit_type( ctx, to_const_TupleType( t )->fields );
	    break;

	case TAGVectorType:
	    ok = visit_type( ctx, to_const_VectorType( t )->elmtype );
	    break;

    }
    return ok;
}

static bool visit_type( mangle_data *ctx, const FormalParameter fp )
{
    return visit_type( ctx, fp->t );
}

static bool visit_type( mangle_data *ctx, const FormalParameter_list tl )
{
    for( unsigned int ix=0; ix<tl->sz; ix++ ){
	if(!visit_type( ctx, tl->arr[ix] ) ){
	    return false;
	}
    }
    return true;
}

/* Given a symbol 's', return true if the symbol has a translation, and
 * set *pos to the index in de list, or return false if the symbol
 * has no translation, and do not touch *pos.
 *
 * The list is searched back to front to ensure that the most recent
 * translation of a symbol is used.
 */
static bool search_VarTranslation( const_VarTranslation_list trans, const tmsymbol s, unsigned int *pos )
{
    unsigned int ix = trans->sz;

    while( ix>0 ){
	ix--;
	if( trans->arr[ix]->from == s ){
	    *pos = ix;
	    return true;
	}
    }
    return false;
}

/* Given a symbol 's', return true if the symbol has a mapping, and
 * set *pos to the index in de list, or return false if the symbol
 * has no translation, and do not touch *pos.
 *
 * The list is searched back to front to ensure that the most recent
 * translation of a symbol is used.
 */
static bool search_VarMapping( const VarMapping_list trans, const tmsymbol s, unsigned int *pos )
{
    unsigned int ix = trans->sz;

    while( ix>0 ){
	ix--;
	if( trans->arr[ix]->from == s ){
	    *pos = ix;
	    return true;
	}
    }
    return false;
}

// Given a variable translation 'from' to 'to', add it to the translation
// list.
static void add_variable_translation(
 mangle_data *ctx,
 const_origsymbol from,
 const tmsymbol to,
 tmsymbol classname
)
{
    unsigned int pos;

    if( from == origsymbolNIL || to == tmsymbolNIL ){
	internal_error( "null pointer" );
    }
    if(
	classname == tmsymbolNIL &&
	search_VarTranslation( ctx->var_translations, from->sym, &pos )
    ){
	if( ctx->var_translations->arr[pos]->classname == tmsymbolNIL ){
	    // The old field is not a class field either. Complain.
	    origsymbol_error( from, "variable already defined" );
	}
    }
    VarTranslation tr = new_VarTranslation(
	from->sym,
	to,
	ctx->scopelevel,
	classname
    );
    ctx->var_translations = append_VarTranslation_list( ctx->var_translations, tr );
    if( showmangling ){
	const_origin org = from->org;
	if( classname == tmsymbolNIL ){
	    fprintf(
		stderr,
		"[%d] Add variable translation %s:%d %s->%s\n",
		ctx->scopelevel,
		org->file->name,
		org->line,
		from->sym->name,
		to->name
	    );
	}
	else {
	    fprintf(
		stderr,
		"[%d] Add %s field translation %s:%d %s->%s\n",
		ctx->scopelevel,
		classname->name,
		org->file->name,
		org->line,
		from->sym->name,
		to->name
	    );
	}
    }
}

// Given a symbol 's' representing a variable, return the translation of
// that symbol, or return symbolNIL if it has no translation.
static tmsymbol translate_variable( mangle_data *ctx, const tmsymbol s )
{
    unsigned int ix;
    VarTranslation_list tab = ctx->var_translations;

    if( s == tmsymbolNIL ){
	return s;
    }
    tmsymbol res = s;
    if( search_VarTranslation( tab, s, &ix ) ){
	if( showmangling ){
	    fprintf(
		stderr,
		"mangled variable '%s' to '%s'\n",
		s->name,
		tab->arr[ix]->to->name
	    );
	}
	res = tab->arr[ix]->to;
    }
    else {
	internal_error( "no translation found for variable '%s'", s->name );
    }
    return res;
}

/* Given a signature 's' representing a method, return the translation of that
 * method, or return tmsymbolNIL if it has no translation.
 */
static tmsymbol translate_method( mangle_data *ctx, const_Signature s )
{
    unsigned int ix;
    tmsymbol res;
    const MethodMapping_list tab = ctx->method_mappings;

    if( search_MethodMapping( tab, s, &ix ) ){
	if( showmangling ){
	    tmstring tnm = typename_Signature( s );

	    fprintf(
		stderr,
		"mapped method '%s' to '%s'\n",
		tnm,
		tab->arr[ix]->mangledname->name
	    );
	    rfre_tmstring( tnm );
	}
	res = tab->arr[ix]->mangledname;
    }
    else {
	if( showmangling ){
	    tmstring tnm = typename_Signature( s );

	    fprintf( stderr, "No mapping found for '%s'\n", tnm );
	    rfre_tmstring( tnm );
	}
	res = tmsymbolNIL;
    }
    return res;
}

/* Given a signature 's' representing a constructor, return the translation
 * of that constructor, or return tmsymbolNIL if it has no translation.
 */
static tmsymbol translate_constructor( mangle_data *ctx, const Signature s )
{
    unsigned int ix;
    tmsymbol res;
    const MethodMapping_list tab = ctx->constructor_mappings;

    if( search_MethodMapping( tab, s, &ix ) ){
	if( showmangling ){
	    tmstring tnm = typename_Signature( s );

	    fprintf(
		stderr,
		"mapped constructor '%s' to '%s'\n",
		tnm,
		tab->arr[ix]->mangledname->name
	    );
	    rfre_tmstring( tnm );
	}
	res = tab->arr[ix]->mangledname;
    }
    else {
	res = tmsymbolNIL;
    }
    return res;
}

// Given a known cardinality symbol, mangle it.
static tmsymbol mangle_Cardinality_symbol( const tmsymbol s )
{
    tmsymbol ans;

    if( s == tmsymbolNIL ){
	internal_error( "null symbol" );
    }
    if( strchr( s->name, '_' ) == NULL ){
	tmstring s1 = printf_tmstring( "%s_", s->name );
	ans = gen_tmsymbol( s1 );
	rfre_tmstring( s1 );
    }
    else {
	ans = gen_tmsymbol( s->name );
    }
    assert( ans != tmsymbolNIL );
    return ans;
}

/* Given a symbol of a local definition, create and enter
 * its translation in the list.
 */
static void build_local_translation(
 mangle_data *ctx,
 const_origsymbol s
)
{
    tmsymbol nw = mangle_local_symbol( s->sym );
    add_variable_translation( ctx, s, nw, tmsymbolNIL );
}

/* Given a list of symbols that are for local definitions, enter
 * them in the list of translations.
 */
static void build_local_translations(
 mangle_data *ctx,
 const_origsymbol_list sl
)
{
    ctx->scopelevel++;
    for( unsigned int ix=0; ix<sl->sz; ix++ ){
	build_local_translation( ctx, sl->arr[ix] );
    }
}

// Given a field mapping, enter its translation in the list.
static void build_field_translation( mangle_data *ctx, const_FieldMapping m )
{
    // Fake an origin to keep everyone happy.
    // For a field it shouldn't be used anyway.
    origsymbol nm = add_origsymbol( m->realname->name );
    add_variable_translation( ctx, nm, m->mangledname, m->classname );
    rfre_origsymbol( nm );
}

// Given a list of field mappings, enter them in the list of translations.
static void build_field_translations( mangle_data *ctx, const_FieldMapping_list fl )
{
    ctx->scopelevel++;
    for( unsigned int ix=0; ix<fl->sz; ix++ ){
	build_field_translation( ctx, fl->arr[ix] );
    }
}

// Given a variable symbol, return the mangled version.
static tmsymbol mangle_variable_symbol( mangle_data *ctx, const tmsymbol s, const_origin org )
{
    tmsymbol ans = translate_variable( ctx, s );

    if( ans == tmsymbolNIL ){
	sprintf( errarg, "'%s'", s->name );
	origin_error( org, "undefined variable" );
	ans = rdup_tmsymbol( s );
    }
    return ans;
}

// Given a prolog method, return the mangled version.
static MethodEntry mangle_prolog_method( SparProgram *prog, tmsymbol t, const_Signature fn )
{
    bool is_static;
    bool use_static_call;

    bool ok = visit_type( prog, originNIL, t );
    if( !ok ){
	return MethodEntryNIL;
    }
    MethodEntry me = bind_Method(
	prog,
	(*prog)->symtab,
	(*prog)->typelist,
	t,			/* Where to search the method. */
	tmsymbolNIL,		/* Where are we calling from. */
	fn,			/* What are we looking for */
	&is_static,
	&use_static_call,
	0
    );
    if( me == MethodEntryNIL ){
	tmstring sig = typename_Signature( fn );

	internal_error( "undefined method '%s.%s' in prolog", t->name, sig );
    }
    else {
	// We don't care about a 'throws' clause in prolog methods,
	// since we're not going to complain about unreachable catch
	// clauses or things like that anyway.

	// Register this method as used. We always do a direct call, since
	// we invoke a static method.
	visit_method( prog, &me, true );
    }
    return me;
}

/* Given a constructor signature, make sure that constructor is mangled. */
static void mangle_prolog_constructor( SparProgram *prog, tmsymbol t, const_Signature fn )
{
    if( !visit_type( prog, originNIL, t ) ){
	return;
    }
    tmsymbol methodnm = bind_Constructor(
	prog,
	(*prog)->symtab,
	(*prog)->typelist,
	t,			/* Where to search the method. */
	tmsymbolNIL,		/* Where are we calling from. */
	fn,			/* What are we looking for */
	0
    );
    if( methodnm == tmsymbolNIL ){
	tmstring sig = typename_Signature( fn );

	internal_error( "undefined constructor '%s.%s' in prolog", t->name, sig );
    }
    else {
	// Register this constructor as used. We always do a direct call, since
	// we invoke a static method.
	(void) visit_constructor( prog, t, fn, methodnm );
    }
}

/* Do unary numeric promotion as described in JLS2 5.6.1 */
static expression do_unary_numeric_promotion( Entry_list symtab, expression x )
{
    type tx = derive_type_expression( symtab, x );

    if( tx != typeNIL && tx->tag == TAGPrimitiveType ){
	BASETYPE bt = to_PrimitiveType( tx )->base;

	if( (bt == BT_BYTE) || (bt == BT_SHORT) || (bt == BT_CHAR) ){
	    x = new_CastExpression(
		new_PrimitiveType( BT_INT ),
		x
	    );
	}
    }
    rfre_type( tx );
    return x;
}

/* Given a statement and a break label, wrap the statement
 * in a block, and put the break label on an empty statement after that.
 */
static statement breakwrap_statement(
 statement smt,
 origsymbol break_target
)
{
    statement_list smts = new_statement_list();

    smts = append_statement_list( smts, smt );
    smts = append_statement_list(
	smts,
	new_EmptyStatement(
	    gen_origin(),
	    Pragma_listNIL,
	    append_origsymbol_list( new_origsymbol_list(), break_target )
	)
    );
    BlockStatement res = new_BlockStatement(
	rdup_origin( smt->org ),
	Pragma_listNIL,
	origsymbol_listNIL,	// Labels
	new_Block( tmsymbolNIL, new_Pragma_list(), smts )
    );
    return res;
}

// Given a method entry in the symbol table 'mentry' and a list of parameters
// 'parameters', rewrite all parameter expressions that require string
// internalization.
static void force_string_parameters(
 mangle_data *ctx,
 MethodEntry mentry,
 expression_list *parameters,
 type_list parmtypes
)
{
    FormalParameter_list fpl = to_MethodEntry( mentry )->parameters;
    assert( fpl->sz == (*parameters)->sz );
    assert( parmtypes->sz == (*parameters)->sz );
    for( unsigned int ix=0; ix<fpl->sz; ix++ ){
	const_FormalParameter fp = fpl->arr[ix];
	const_type pt = parmtypes->arr[ix];

	if( !is_vnusstring_type( fp->t ) && is_vnusstring_type( pt ) ){
	    (*parameters)->arr[ix] = internalize_Vnus_string(
		ctx,
		(*parameters)->arr[ix]
	    );
	}
    }
}

static expression_list force_type_MethodEntry(
 mangle_data *ctx,
 expression_list parameters,
 MethodEntry me
)
{
    type_list tl = rdup_type_list( me->realname->parameters );

.call generate_descent_call "    " tl type_list type_list
    origsymbol method = new_origsymbol( me->realname->name, rdup_origin( ctx->org ) );
    parameters = force_type( ctx->symtab, method, parameters, tl );
    rfre_origsymbol( method );
    rfre_type_list( tl );
    return parameters;
}

/* Given an type name 'tnm', a method 'method' and a pointer to a list of
 * parameters 'parameters', return the symboltable entry of the function to
 * invoke.
 *
 * Since we refer to the method through its type, only static methods
 * can be invoked. Complain if the method is non-static after all.
 */
static MethodEntry bind_type_method(
 mangle_data *ctx,
 const_origsymbol tnm,
 const_origsymbol methodnm,
 expression_list *parameters
)
{
    tmsymbol callfrom_type = ctx->owner;
    bool is_static;
    bool use_static_call;
    tmsymbol tr_tnm = translate_type( ctx, tnm );
    bool ok;

    ok = visit_type( ctx->prog, tnm->org, tr_tnm );
    if( !ok ){
	return MethodEntryNIL;
    }
    ok = visit_type( ctx->prog, ctx->org, callfrom_type );
    if( !ok ){
	return MethodEntryNIL;
    }
    Signature s = new_Signature(
	0,
	methodnm->sym,
	derive_type_expression_list( ctx->symtab, *parameters )
    );
    MethodEntry me = bind_Method(
	ctx->prog,
	ctx->symtab,
	ctx->typelist,
	tr_tnm,			/* Where to search the method. */
	callfrom_type,		/* Where are we calling from. */
	s,			/* What are we looking for */
	&is_static,
	&use_static_call,
	methodnm->org
    );
    // bind_Method already complains if not found, so keep silent
    if( me != MethodEntryNIL ){
	force_string_parameters( ctx, me, parameters, s->parameters );
	*parameters = force_type_MethodEntry( ctx, *parameters, me );
	if( !ctx->in_typeof ){
	    visit_method( ctx->prog, &me, true );
	}
	if( showmangling ){
	    tmstring snm = typename_Signature( s );

	    fprintf(
		stderr,
		"'%s.%s' is a reference to mangled method '%s'\n",
		tnm->sym->name,
		snm,
		me->name->name
	    );
	    rfre_tmstring( snm );
	}
	if( !is_static ){
	    tmstring snm = typename_Signature( s );

	    error(
		"Cannot make a static reference to an instance method '%s' in class '%s'",
		snm,
		tnm->sym->name
	    );
	    rfre_tmstring( snm );
	    me = MethodEntryNIL;
	}
    }
    rfre_Signature( s );
    return me;
}

static MethodEntry bind_type_method(
 mangle_data *ctx,
 const_type t,
 const_origsymbol methodnm,
 expression_list *parameters
)
{
    MethodEntry me = MethodEntryNIL;

    switch( t->tag ){
	case TAGObjectType:
	    me = bind_type_method( ctx, to_const_ObjectType(t)->name, methodnm, parameters );
	    break;

	case TAGGenericObjectType:
	    origin_internal_error( ctx->org, "Generic type should have been expanded" );
	    break;

	case TAGPragmaType:
	    me = bind_type_method( ctx, to_const_PragmaType(t)->t, methodnm, parameters );
	    break;

	case TAGPrimitiveType:
	case TAGTypeType:
	case TAGTupleType:
	case TAGVectorType:
	case TAGNullType:
	case TAGFunctionType:
	case TAGTypeOf:
	case TAGTypeOfIf:
	case TAGVoidType:
	case TAGArrayType:
	case TAGPrimArrayType:
	case TAGExceptionVariableType:
	case TAGGCRefLinkType:
	case TAGGCTopRefLinkType:
	    origin_error( ctx->org, "Only classes and interfaces have static methods" );
    }
    return me;
}

// Given the name of the static init method, construct and return
// a statement to invoke this method.
static statement build_static_init_statement(
 tmsymbol t,
 tmsymbol needinit_nm,
 tmsymbol init_nm
)
{
    if( init_nm == tmsymbolNIL ){
	return statementNIL;
    }
    if( needinit_nm == tmsymbolNIL ){
	internal_error( "null symbol" );
    }
    tmsymbol fq_need = needinit_nm;
    tmsymbol fq_proc = init_nm;
    if( t != tmsymbolNIL ){
	fq_need = qualify_tmsymbol( t, fq_need );
	fq_proc = qualify_tmsymbol( t, fq_proc );
    }
    return new_IfStatement(
	gen_origin(),
	build_Pragma_list( new_role_pragma( "static-init" ) ),
	origsymbol_listNIL,	// Labels
	false,			// eval both
	new_VariableNameExpression( add_origsymbol( fq_need ), VAR_GENERATED|VAR_GLOBAL ),
	new_Block(
	    tmsymbolNIL,
	    new_Pragma_list(),
	    append_statement_list(
		new_statement_list(),
		new_MethodInvocationStatement(
		    gen_origin(),
		    Pragma_listNIL,
		    origsymbol_listNIL,	// Labels
		    new_MethodInvocation(
			expressionNIL,
			add_origsymbol( fq_proc ),
			new_expression_list(),	// This parameters
			new_expression_list(),
			CALL_STATICINIT
		    )
		)
	    )
	),
	// else branch of the if.
	new_Block( tmsymbolNIL, new_Pragma_list(), new_statement_list() )
    );
}

static bool staticInit_was_done( const_ProgramState_list states, tmsymbol tnm )
{
    unsigned int ix = states->sz;
    while( ix>0 ){
	ix--;
	ProgramState st = states->arr[ix];

	if( member_tmsymbol_list( st->completedStaticInits, tnm ) ){
	    return true;
	}
    }
    return false;
}

// Forward declaration.
static bool register_staticInit_done( mangle_data *ctx, const_type t );

// Given a type entry, register the type of that entry as having
// been static-initialized. 
// Also register any superclasses or superinterfaces  that are not
// yet in the list as being initialized (since a static init function
// is supposed to do that).
// Return true iff the static init is not necessary.
static bool register_staticInit_done( mangle_data *ctx, TypeEntry me )
{
    bool useful = true;

    assert( ctx->states->sz>0 );
    ProgramState topstate = ctx->states->arr[ctx->states->sz-1];
    topstate->completedStaticInits = append_tmsymbol_list(
	topstate->completedStaticInits,
	me->name->sym
    );
    if( is_ObjectTypeEntry( me ) ){
	useful = !to_ObjectTypeEntry( me )->staticInitTrivial;

	type_list interfaces = to_ObjectTypeEntry( me )->interfaces;
	for( unsigned int ix=0; ix<interfaces->sz; ix++ ){
	    useful |= register_staticInit_done( ctx, interfaces->arr[ix] );
	}
    }
    if( me->tag == TAGClassEntry ){
	useful |= register_staticInit_done( ctx, to_ClassEntry(me)->super );
    }
    return useful;
}

// Given a type 't', register the type of that entry as having been
// static-initialized.
static bool register_staticInit_done( mangle_data *ctx, tmsymbol tnm )
{
    if( staticInit_was_done( ctx->states, tnm ) ){
	if( trace_analysis ){
	    fprintf( stderr, "Static init for '%s' already registed. Recursion stopped.\n", tnm->name );
	}
	return false;
    }
    TypeEntry me = lookup_TypeEntry( ctx->typelist, tnm );
    bool useful = true;
    if( me != TypeEntryNIL ){
	useful = register_staticInit_done( ctx, me );
    }
    return useful;
}

// Given a type 't', register the type of that entry as having been
// static-initialized.
static bool register_staticInit_done( mangle_data *ctx, const_type t )
{
     if( t == typeNIL ){
	 return false;
     }
     if( t->tag == TAGObjectType ){
	 // It may be a GenericObjectType, but all other types
	 // are wrong. It is not our place to report that, though.
	 tmsymbol tnm = to_const_ObjectType( t )->name->sym;
	 return register_staticInit_done( ctx, tnm );
     }
     return true;
}

// Forward declaration.
static statement build_static_init_statement(
    mangle_data *ctx,
    const_type t
);

// Given the name of a type, construct and return a statement to
// invoke the static initializer of this type, if any.
// Return statementNIL if no static initialization is necessary.
static statement build_static_init_statement(
    mangle_data *ctx,
    tmsymbol tnm
)
{
    if( tnm == tmsymbolNIL ){
	return statementNIL;
    }
    ProgramState_list states = ctx->states;

    // First see if it is already mentioned in any of the program
    // state lists.
    if( trace_analysis ){
	fprintf( stderr, "Building static init for '%s'\n", tnm->name );
    }
    if( staticInit_was_done( states, tnm ) ){
	if( trace_analysis ){
	    fprintf( stderr, "Static init for '%s' already done\n", tnm->name );
	}
	return statementNIL;
    }

    TypeEntry me = lookup_TypeEntry( ctx->typelist, tnm );
    if( me == TypeEntryNIL || !is_ObjectTypeEntry( me ) ){
	// Something must be wrong, don't try to do anything.
	return statementNIL;
    }
    if( to_ObjectTypeEntry(me)->staticInit == tmsymbolNIL ){
	// This object has no static initializer. If it's a class
	// it may have a superclass that may need initializing,
	// otherwise don't bother.
	if( me->tag == TAGClassEntry ){
	    const_type super = to_ClassEntry(me)->super;
	    return build_static_init_statement( ctx, super );
	}
	return statementNIL;

    }
    // Not yet listed, so we have to register this one as done...
    if( !register_staticInit_done( ctx, me ) ){
	// But if nothing interesting happens during static init,
	// we might as well not generate the code.
	if( trace_analysis ){
	    fprintf( stderr, "Static init for '%s' not useful at this point\n", tnm->name );
	}
	return statementNIL;
    }
    // ... and return a statement to cause static init of this class.
    if( trace_analysis ){
	fprintf( stderr, "Static init code for '%s' built.\n", tnm->name );
    }
    return build_static_init_statement(
	me->name->sym,
	to_ObjectTypeEntry( me )->staticInitNeed,
	to_ObjectTypeEntry( me )->staticInit
    );
}

// Given the name of a type, construct an return a statement to
// invoke the static initializer of this type, if any.
static statement build_static_init_statement(
    mangle_data *ctx,
    const_origsymbol tnm
)
{
    if( tnm == origsymbolNIL ){
	return statementNIL;
    }
    return build_static_init_statement( ctx, translate_type( ctx, tnm ) );
}

// Given a type, construct an return a statement to
// invoke the static initializer of this type, if any.
static statement build_static_init_statement(
    mangle_data *ctx,
    const_type t
)
{
    if( t == typeNIL ){
	return statementNIL;
    }
    if( t->tag != TAGObjectType ){
	internal_error( "Parameterized type should have been rewritten" );
    }
    return build_static_init_statement( ctx, to_const_ObjectType(t)->name );
}

static const_VariableEntry bind_field(
    mangle_data *ctx,
    tmsymbol in_where,
    tmsymbol from_where,
    const_origsymbol field
)
{
    const_VariableEntry res = bind_Field(
	ctx->prog,
	ctx->symtab,
	ctx->typelist,
	in_where,
	from_where,
	field
    );
    if( res == VariableEntryNIL ){
	return VariableEntryNIL;
    }
    // Only references to static fields trigger an init call,
    // for dynamic fields the job has presumably been done in the
    // constructor that made these instances of the dynamic field.
    //
    // Do not generate init calls for fields involved in the
    // initialization administration (would cause infinite
    // recursion) or for final static fields ('constant' fields per
    // JLS2 12.4.1).
    if(
	!ctx->in_typeof &&
	!has_any_flag( res->flags, ACC_COMPILECONSTANT|ACC_INIT )
    ){
	assert( res->owner != tmsymbolNIL );
	statement smt = build_static_init_statement( ctx, res->owner );
	if( smt != statementNIL ){
.call generate_descent_call "	    " smt statement statement
	    ctx->mangled_pre_spill_smts = append_statement_list(
		ctx->mangled_pre_spill_smts,
		smt
	    );
	}
    }
    return res;
}

static bool search_GenericMapping_list(
 const_GenericMapping_list gl,
 tmsymbol nm,
 unsigned int *pos
)
{
    for( unsigned int ix=0; ix<gl->sz; ix++ ){
	if( gl->arr[ix]->name == nm ){
	    *pos = ix;
	    return true;
	}
    }
    return false;
}

static bool search_GenericBinding_list(
 const_GenericBinding_list bl,
 const_expression_list xl,
 unsigned int *pos
)
{
    for( unsigned int ix=0; ix<bl->sz; ix++ ){
	if( isequal_expression_list( bl->arr[ix]->pattern, xl ) ){
	    *pos = ix;
	    return true;
	}
    }
    return false;
}

// Given a list of generic bindings, a class name and a list of parameters,
// return the proper binding for this name and parameters.
static tmsymbol lookup_GenericInstance(
 const_GenericMapping_list gl,
 const_origsymbol cl,
 const_expression_list parms
)
{
    unsigned int ix;

    // Locate its entry in the list of generics
    if( !search_GenericMapping_list( gl, cl->sym, &ix ) ){
	return tmsymbolNIL;
    }
    const_GenericMapping gm = gl->arr[ix];
    if( !search_GenericBinding_list( gm->bindings, parms,  &ix ) ){
	return tmsymbolNIL;
    }
    return gm->bindings->arr[ix]->clazz;
}

// Given an expression list, make sure that it is suitable as an
// instance tuple of a parameterized type.
static bool is_valid_instance_tuple(
 mangle_data *ctx,
 const_expression_list xl,
 const_FormalParameter_list tl
)
{
    bool ok = true;
    if( xl->sz>tl->sz ){
	origin_error( ctx->org, "Invalid type instance: too many parameters" );
	return false;
    }
    if( xl->sz<tl->sz ){
	origin_error( ctx->org, "Invalid type instance: too few parameters" );
	return false;
    }
    for( unsigned int ix=0; ix<xl->sz; ix++ ){
	const_expression x = xl->arr[ix];
	const_FormalParameter p = tl->arr[ix];

	if( x == expressionNIL || p->t == typeNIL ){
	    return false;
	}
	type t = derive_type_expression( ctx->symtab, x );
	if( p->t->tag == TAGTypeType ){
	    if( x->tag != TAGTypeExpression ){
		origin_error(
		    ctx->org,
		    "Cannot instantiate type, value for type parameter '%s' must be a type",
		    p->name->sym->name
		);
		ok = false;
	    }
	}
	else {
	    if( !is_LiteralExpression( x ) ){
		origin_error(
		    ctx->org,
		    "Cannot instantiate type, value for parameter '%s' is not constant",
		    p->name->sym->name
		);
		ok = false;
	    }
	    if( !is_identity_conv_type( ctx->symtab, p->t, t ) ){
		tmstring typenm_formal = typename_type( p->t );
		tmstring typenm_actual = typename_type( t );
		origin_error(
		    ctx->org,
		    "cannot instantiate a %s class parameter with a %s parameter",
		    typenm_formal,
		    typenm_actual
		);
		rfre_tmstring( typenm_actual );
		rfre_tmstring( typenm_formal );
		ok = false;
	    }
	}
	rfre_type( t );
    }
    return ok;
}

// Given a generic object type, return an ordinary object type that
// refers to the expanded version.
// If necessary, create a new version.
static ObjectType bind_GenericObjectType( mangle_data *ctx, const_GenericObjectType t )
{
    unsigned int ix;

    // Make sure the generic type has been parsed.
    if( !compile_type( ctx->prog, t->name->sym ) ){
	return ObjectTypeNIL;
    }

    const_GenericMapping_list gl = (*ctx->prog)->generics;
    if( !search_GenericMapping_list( gl, t->name->sym, &ix ) ){
	// TODO: see if the type is in fact without parameters, and
	// give a clearer error message for that case.
	origsymbol_error( t->name, "No such parameterized type" );
	return ObjectTypeNIL;
    }
    const_GenericMapping gm = gl->arr[ix];
    if( !is_valid_instance_tuple( ctx, t->parameters, gm->formals ) ){
	return ObjectTypeNIL;
    }

    tmsymbol nm = lookup_GenericInstance( gl, t->name, t->parameters );
    if( nm == tmsymbolNIL ){
	if( !specialize_type( t->name->org, ctx->prog, t->name, t->parameters ) ){
	    // Something's wrong; presumably there has been a complaint.
	    return ObjectTypeNIL;
	}
	nm = lookup_GenericInstance( gl, t->name, t->parameters );
	if( nm == tmsymbolNIL ){
	    internal_error( "specialization of generic type '%s' failed", t->name->sym->name );
	}
    }
    ObjectType res = new_ObjectType(
	new_origsymbol( nm, rdup_origin( t->name->org ) )
    );
    return res;
}

// Given a signature 's' and a type name 'tnm', return true iff the
// method with this signature is used through a virtual call in the
// given type, or one of its superclasses, or one of the interfaces
// it implements.
//
// Also mark any methods that match the signature as overridden.
static bool mark_overridden_methods(
 const_TypeEntry_list typelist,
 const_Entry_list symtab,
 const_Signature s,
 const_origsymbol tnm
)
{
    bool res = false;

    const_TypeEntry te = lookup_TypeEntry( typelist, tnm );
    if( te == TypeEntryNIL ){
	return false;
    }
    switch( te->tag ){
	case TAGClassEntry:
	{
	    const_ClassEntry ce = to_const_ClassEntry( te );
	    const_MethodMapping_list methods = ce->methods;
	    unsigned int pos;
	    bool recurse = true;

	    if( search_MethodMapping( methods, s, &pos ) ){
		// We've found a method that matches, now dig up
		// its virtual use flag.
		MethodEntry mentry = lookup_MethodEntry(
		    symtab,
		    methods->arr[pos]->mangledname
		);
		if( mentry != MethodEntryNIL ){
		    if( mentry->isvirtuallyused ){
			res = true;
			recurse = !mentry->isoverridden;
			mentry->isoverridden = true;
		    }
		}
	    }
	    if( recurse && ce->super != typeNIL ){
		res |= mark_overridden_methods( typelist, symtab, s, ce->super );
	    }
	    const_type_list interfaces = ce->interfaces;
	    for( unsigned int ifx=0; ifx<interfaces->sz; ifx++ ){
		res |= mark_overridden_methods( typelist, symtab, s, interfaces->arr[ifx] );
	    }
	    break;
	}

	case TAGInterfaceEntry:
	{
	    const_InterfaceEntry ce = to_const_InterfaceEntry( te );
	    const_MethodMapping_list methods = ce->methods;
	    unsigned int pos;

	    if( search_MethodMapping( methods, s, &pos ) ){
		// We've found a method that matches, now dig up
		// its virtual use flag.
		MethodEntry mentry = lookup_MethodEntry( symtab, methods->arr[pos]->mangledname );
		if( mentry != MethodEntryNIL ){
		    if( mentry->isvirtuallyused ){
			res = true;
			mentry->isoverridden = true;
		    }
		}
	    }
	    const_type_list interfaces = ce->interfaces;
	    for( unsigned int ifx=0; ifx<interfaces->sz; ifx++ ){
		res |= mark_overridden_methods( typelist, symtab, s, interfaces->arr[ifx] );
	    }
	    break;
	}

	case TAGForwardObjectEntry:
	case TAGPackageEntry:
	    break;


    }
    if( trace_usage ){
	tmstring snm = typename_Signature( s );

	fprintf(
	    stderr,
	    "mark_overridden_methods: '%s' is %sused virtually in '%s'\n",
	    snm,
	    res?"":"not ",
	    tnm->sym->name
	);
	rfre_tmstring( snm );
    }
    return res;
}

// The same as above, but with the type represented as a type, not a name.
static bool mark_overridden_methods(
 const_TypeEntry_list typelist,
 const_Entry_list symtab,
 const_Signature s,
 const_type t
)
{
    if( t->tag != TAGObjectType ){
	internal_error( "Only an object type can have methods" );
    }
    return mark_overridden_methods( typelist, symtab, s, to_const_ObjectType(t)->name );
}

static void check_is_initialized(
 mangle_data *ctx,
 tmsymbol nm,
 const_origin org
)
{
    ProgramState_list states = ctx->states;
    unsigned int lvl;
    unsigned int pos;

    if( search_var_programstates( states, states->sz, nm, &lvl, &pos ) ){
	const_VarState v = states->arr[lvl]->varStates->arr[pos];
	if( !v->defassigned ){
	    VariableEntry e = lookup_VariableEntry( ctx->symtab, nm );
	    if( e != VariableEntryNIL ){
		origin_error(
		    org,
		    "Variable `%s' %s been initialized",
		    e->realname->sym->name,
		    v->defunassigned?"has not":"may not have"
		);
	    }
	}
    }
    else {
	origin_internal_error( org, "Cannot check init status of '%s': not registered", nm->name );
    }
}

static void check_is_initialized( mangle_data *ctx, const_origsymbol nm )
{
    check_is_initialized( ctx, nm->sym, nm->org );
}

static void check_final_violation(
 mangle_data *ctx,
 tmsymbol nm,
 const_origin org
)
{
    const_ProgramState_list states = ctx->states;
    unsigned int lvl;
    unsigned int pos;

    if( search_var_programstates( states, states->sz, nm, &lvl, &pos ) ){
	const_VarState v = states->arr[lvl]->varStates->arr[pos];
	if( v->final && !v->defunassigned ){
	    const_VariableEntry e = lookup_VariableEntry( ctx->symtab, nm );

	    if( e != VariableEntryNIL ){
		origin_error(
		    org,
		    "Cannot assign a second value to a final variable: %s",
		    e->realname->sym->name
		);
	    }
	}
    }
    else {
	const_VariableEntry e = lookup_VariableEntry( ctx->symtab, nm );
	if( has_any_flag( e->flags, ACC_FINAL ) ){
	    // This may be a field violation.

	    switch( e->tag ){
	        case TAGFieldEntry:
		    // TODO: if we're not in a constructor, assignment
		    // to a blank final is also wrong.
		    if(
		        !ctx->in_constructor ||
			is_initialization( to_const_FieldEntry(e)->init )
		    ){
			origin_error(
			    org,
			    "Cannot assign a value to a final field: %s",
			    e->realname->sym->name
			);
		    }
		    break;

	        case TAGGlobalVariableEntry:
		    // TODO: if we're not in a constructor, assignment
		    // to a blank final is also wrong.
		    if(
		        !ctx->in_constructor ||
			is_initialization( to_const_GlobalVariableEntry(e)->init )
		    ){
			origin_error(
			    org,
			    "Cannot assign a value to a static final field: %s",
			    e->realname->sym->name
			);
		    }
		    break;

		case TAGLocalVariableEntry:
		    origsymbol_internal_error( e->realname, "Variable missing from analysis state" );
		    break;

		default:
		    break;

	    }
	}
    }
}

static bool escapes_variable( mangle_data *ctx, tmsymbol nm )
{
    const_ProgramState_list states = ctx->states;
    unsigned int lvl;
    unsigned int pos;

    if( search_var_programstates( states, states->sz, nm, &lvl, &pos ) ){
	const_VarState v = states->arr[lvl]->varStates->arr[pos];
	return v->escapes;
    }
    return true;
}

static bool escapes_variable( mangle_data *ctx, origsymbol nm )
{
    return escapes_variable( ctx, nm->sym );
}

static bool escapes( mangle_data *ctx, const_expression x )
{
    if( x == expressionNIL ){
        return true;
    }
    bool res = true;
    switch( x->tag ){
        case TAGByteExpression:
        case TAGShortExpression:
        case TAGIntExpression:
        case TAGLongExpression:
        case TAGFloatExpression:
        case TAGDoubleExpression:
        case TAGCharExpression:
        case TAGBooleanExpression:
	    res = false;
	    break;

        case TAGNullExpression:
        case TAGStringExpression:
        case TAGSizeofExpression:
	case TAGFieldExpression:
	case TAGTypeFieldExpression:
	case TAGClassExpression:
	case TAGSuperFieldExpression:
	case TAGOuterThisExpression:
	case TAGMethodInvocationExpression:
	case TAGFieldInvocationExpression:
	case TAGTypeInvocationExpression:
	case TAGSuperInvocationExpression:
	case TAGOuterSuperInvocationExpression:
	case TAGPostIncrementExpression:
	case TAGPostDecrementExpression:
	case TAGPreDecrementExpression:
	case TAGPreIncrementExpression:
	case TAGComplexExpression:
	case TAGTypeExpression:
	case TAGInstanceOfExpression:
	case TAGTypeInstanceOfExpression:
	case TAGClassInstanceOfExpression:
	case TAGInterfaceInstanceOfExpression:
	case TAGGetBufExpression:
	case TAGGetSizeExpression:
	case TAGGetLengthExpression:
	case TAGInternalizeExpression:
	case TAGClassIdExpression:
	case TAGDefaultValueExpression:
	case TAGUnopExpression:
	case TAGOuterSuperFieldExpression:
	case TAGSubscriptExpression:
	case TAGVectorSubscriptExpression:
	case TAGBinopExpression:
	case TAGShortopExpression:
	case TAGIfExpression:		// TODO: be smarter than this.
	case TAGVectorExpression:
	    res = true;
	    break;

	case TAGAnnotationExpression:
	    res = escapes( ctx, to_const_AnnotationExpression(x)->x );
	    break;

	case TAGBracketExpression:
	    res = escapes( ctx, to_const_BracketExpression(x)->x );
	    break;

	case TAGNotNullAssertExpression:
	    res = escapes( ctx, to_const_NotNullAssertExpression(x)->x );
	    break;

	case TAGForcedCastExpression:
	    res = escapes( ctx, to_const_ForcedCastExpression(x)->x );
	    break;

	case TAGCastExpression:
	    res = escapes( ctx, to_const_CastExpression(x)->x );
	    break;

	case TAGWhereExpression:
	    res = true;
	    break;

	case TAGVariableNameExpression:
	    res = escapes_variable( ctx, to_const_VariableNameExpression(x)->name );
	    break;

	case TAGNewRecordExpression:
	case TAGNewArrayExpression:
	case TAGNewInitArrayExpression:
	case TAGNewClassExpression:
	case TAGArrayInitExpression:
	    res = false;
	    break;

	case TAGAssignOpExpression:
	    internal_error( "should not occur here" );
    }
    return res;
}

// Given a variable 'nm', return true iff it is safe to do a __delete
// on this variable. This means that it should not escape, should have
// the right type for a delete, and should be local variable (as
// opposed to e.g. a formal parameter or class field).
static bool is_deletable_variable( mangle_data *ctx, const_VarState v )
{
    if( v->value->zero != AF_YES && !v->escapes && v->defassigned ){
	const_VariableEntry e = lookup_VariableEntry( ctx->symtab, v->name );
	if( e == VariableEntryNIL || e->tag != TAGLocalVariableEntry ){
	    return false;
	}
	const_LocalVariableEntry ve = to_const_LocalVariableEntry( e );
	if( ve->t == typeNIL || !is_ReferenceType( ve->t ) ){
	    return false;
	}
	return true;
    }
    return false;
}

// Given a variable 'nm', return true iff it is safe to do a __delete
// on this variable. This means that it should not escape, should have
// the right type for a delete, and should be local variable (as
// opposed to e.g. a formal parameter or class field).
static bool is_deletable_variable( mangle_data *ctx, tmsymbol nm )
{
    const_ProgramState_list states = ctx->states;
    unsigned int lvl;
    unsigned int pos;

    if( search_var_programstates( states, states->sz, nm, &lvl, &pos ) ){
	return is_deletable_variable( ctx, states->arr[lvl]->varStates->arr[pos] );
    }
    return false;
}

// Given a variable 'nm', return iff this variable escapes.
static bool is_escaping_variable( const_ProgramState_list states, tmsymbol nm )
{
    unsigned int lvl;
    unsigned int pos;


    if( trace_analysis ){
	fprintf(
	    stderr,
	    "Determine whether formal '%s' escapes\n",
	    nm->name
	);
    }
    if( search_var_programstates( states, states->sz, nm, &lvl, &pos ) ){
	bool res = states->arr[lvl]->varStates->arr[pos]->escapes;
	if( trace_analysis ){
	    fprintf(
		stderr,
		"Analysis info for '%s' says it does %sescape\n",
		nm->name,
		res?"":"not "
	    );
	}
	return res;
    }
    if( trace_analysis ){
	fprintf(
	    stderr,
	    "No analysis info for '%s', assume it escapes\n",
	    nm->name
	);
    }
    return true;
}

static bool is_deletable_variable( mangle_data *ctx, origsymbol nm )
{
    return is_deletable_variable( ctx, nm->sym );
}

static bool is_deletable( mangle_data *ctx, const_expression x )
{
    if( x == expressionNIL ){
        return false;
    }
    bool res = false;
    switch( x->tag ){
        case TAGByteExpression:
        case TAGShortExpression:
        case TAGIntExpression:
        case TAGLongExpression:
        case TAGFloatExpression:
        case TAGDoubleExpression:
        case TAGCharExpression:
        case TAGBooleanExpression:
        case TAGStringExpression:
        case TAGNullExpression:
        case TAGSizeofExpression:
	case TAGFieldExpression:
	case TAGTypeFieldExpression:
	case TAGClassExpression:
	case TAGSuperFieldExpression:
	case TAGOuterThisExpression:
	case TAGMethodInvocationExpression:
	case TAGFieldInvocationExpression:
	case TAGTypeInvocationExpression:
	case TAGSuperInvocationExpression:
	case TAGOuterSuperInvocationExpression:
	case TAGPostIncrementExpression:
	case TAGPostDecrementExpression:
	case TAGPreDecrementExpression:
	case TAGPreIncrementExpression:
	case TAGComplexExpression:
	case TAGTypeExpression:
	case TAGInstanceOfExpression:
	case TAGTypeInstanceOfExpression:
	case TAGClassInstanceOfExpression:
	case TAGInterfaceInstanceOfExpression:
	case TAGGetBufExpression:
	case TAGGetSizeExpression:
	case TAGGetLengthExpression:
	case TAGInternalizeExpression:
	case TAGClassIdExpression:
	case TAGDefaultValueExpression:
	case TAGUnopExpression:
	case TAGOuterSuperFieldExpression:
	case TAGSubscriptExpression:
	case TAGVectorSubscriptExpression:
	case TAGBinopExpression:
	case TAGShortopExpression:
	case TAGIfExpression:
	case TAGVectorExpression:
	    // Not interesting.
	    break;

	case TAGAnnotationExpression:
	    res = is_deletable( ctx, to_const_AnnotationExpression(x)->x );
	    break;

	case TAGBracketExpression:
	    res = is_deletable( ctx, to_const_BracketExpression(x)->x );
	    break;

	case TAGNotNullAssertExpression:
	    res = is_deletable( ctx, to_const_NotNullAssertExpression(x)->x );
	    break;

	case TAGForcedCastExpression:
	    res = is_deletable( ctx, to_const_ForcedCastExpression(x)->x );
	    break;

	case TAGCastExpression:
	    res = is_deletable( ctx, to_const_CastExpression(x)->x );
	    break;

	case TAGWhereExpression:
	    res = false;
	    break;

	case TAGVariableNameExpression:
	    res = is_deletable_variable( ctx, to_const_VariableNameExpression(x)->name );
	    break;

	case TAGNewRecordExpression:
	case TAGNewArrayExpression:
	case TAGNewInitArrayExpression:
	case TAGNewClassExpression:
	case TAGArrayInitExpression:
	    res = true;
	    break;

	case TAGAssignOpExpression:
	    internal_error( "should not occur here" );
    }
    return res;
}

// Given a type with name 'tnm' and a field with name 'field', return
// an expression to access this field.
//
// Field access expressions of this form are either static field references,
// or references to the magic field 'class'.
static expression bind_type_field(
 mangle_data *ctx,
 tmsymbol tnm,
 const_origsymbol fieldnm
)
{
    // This must be a reference to a static field of class 'tnm'.

    // The Java 1.1 language construct <classname>.class expresses
    // a reference to a java.lang.Class instance that describes
    // <classname>. The wording in the Java documentation suggest a
    // references to a unique, precomputed, instance, but for now
    // we simply construct a new instance on demand through the
    // java.lang.Class constructor that has the class id as
    // parameter.
    // TODO
    if( strcmp( fieldnm->sym->name, "class" ) == 0 ){
	expression res = new_NewClassExpression(
	    expressionNIL,
	    new_ObjectType( add_origsymbol( "java.lang.Class" ) ),
	    append_expression_list(
		new_expression_list(),
		new_ClassIdExpression( add_origsymbol( tnm ) )
	    ),
	    statement_listNIL
	);
.call generate_descent_call "	" res expression expression
	return res;
    }
    // TODO: do we need this?
    bool ok = visit_type( ctx->prog, ctx->org, tnm );
    if( !ok ){
	return expressionNIL;
    }
    const_VariableEntry field = bind_field(
	ctx,
	tnm,
	ctx->owner,
	fieldnm
    );
    if( field == VariableEntryNIL ){
	origsymbol_error( fieldnm, "Unknown field in type '%s'", tnm->name );
	return expressionNIL;
    }
    if( !has_any_flag( field->flags, ACC_STATIC|ACC_COMPILECONSTANT ) ){
	origsymbol_error(
	    fieldnm,
	    "Static reference to an instance variable in class '%s'",
	    tnm->name
	);
    }
    if( !ctx->in_assign_lhs && has_final_flag( field->flags ) ){
	const_expression init = get_init_expression( field );

	if( init != expressionNIL && is_constant( init ) ){
	    return new_CastExpression(
		lookup_vartype( field ),
		rdup_expression( init )
	    );
	}
    }
    return new_VariableNameExpression(
	new_origsymbol( field->name, rdup_origin( fieldnm->org ) ),
	VAR_STATFIELD
    );
}

static expression bind_type_field( mangle_data *ctx, const_origsymbol tnm, const_origsymbol field )
{
    return bind_type_field( ctx, tnm->sym, field );
}

static expression bind_type_field( mangle_data *ctx, const_type t, const_origsymbol field )
{
    expression res = expressionNIL;

    switch( t->tag ){
	case TAGObjectType:
	    res = bind_type_field( ctx, to_const_ObjectType(t)->name, field );
	    break;

	case TAGGenericObjectType:
	    origin_internal_error( ctx->org, "Generic type should have been expanded" );
	    break;

	case TAGPragmaType:
	    res = bind_type_field( ctx, to_const_PragmaType(t)->t, field );
	    break;

	case TAGPrimitiveType:
	case TAGTypeType:
	case TAGTupleType:
	case TAGVectorType:
	case TAGNullType:
	case TAGFunctionType:
	case TAGTypeOf:
	case TAGTypeOfIf:
	case TAGVoidType:
	case TAGArrayType:
	case TAGPrimArrayType:
	case TAGExceptionVariableType:
	case TAGGCRefLinkType:
	case TAGGCTopRefLinkType:
	    origin_error( ctx->org, "Only classes and interfaces have static fields" );
    }
    return res;
}

// Given a variable name 'nm' and a context 'ctx', bind the name to the
// proper context.
static expression bind_variable( const const_origsymbol nm, mangle_data *ctx )
{
    unsigned int pos;

    if( is_qualified_origsymbol( nm ) ){
	origsymbol first;
	origsymbol last;

	break_qualified_name( nm, &first, &last );
	if( search_VarTranslation( ctx->var_translations, first->sym, &pos ) ){
	    /* We assume this is a reference to a field of a variable. */
	    if( showmangling ){
		fprintf(
		    stderr,
		    "qualified name '%s' is an instance field reference\n",
		    nm->sym->name
		);
	    }
	    FieldExpression res = new_FieldExpression(
		new_VariableNameExpression( first, 0 ),
		last
	    );
.call generate_descent_call "            " res FieldExpression FieldExpression
	    return res;
	}
	else {
	    tmsymbol trt = canonify_type(
		ctx->prog,
		ctx->packagename,
		ctx->owner,
		ctx->ondemands,
		&ctx->typebindings,
		first
	    );
	    if( trt != tmsymbolNIL ){
		if( showmangling ){
		    fprintf(
			stderr,
			"qualified name '%s' is a static field reference\n",
			nm->sym->name
		    );
		}
		expression res = bind_type_field( ctx, trt, last );
		rfre_origsymbol( first );
		rfre_origsymbol( last );
		return res;
	    }
	    else {
		/* We assume this is a reference to a field of a variable. */
		if( showmangling ){
		    fprintf(
			stderr,
			"qualified name '%s' is a instance field reference\n",
			nm->sym->name
		    );
		}
		FieldExpression res = new_FieldExpression(
		    new_VariableNameExpression( first, 0 ),
		    last
		);
.call generate_descent_call "		" res FieldExpression FieldExpression
		return res;
	    }
	}
    }
    /* Not a qualified symbol. */
    if( search_VarTranslation( ctx->var_translations, nm->sym, &pos ) ){
	const_VarTranslation tr = ctx->var_translations->arr[pos];

	if( tr->classname == tmsymbolNIL ){
	    if( showmangling ){
		fprintf(
		    stderr,
		    "simple name '%s' refers to local variable '%s'\n",
		    nm->sym->name,
		    tr->to->name
		);
	    }
	    const_Entry e = search_Entry( ctx->symtab, tr->to );
	    if( e != EntryNIL ){
		if( !ctx->in_assign_lhs && has_final_flag( e->flags ) ){
		    const_expression init = get_init_expression( e );

		    if( init != expressionNIL && is_constant( init ) ){
			return new_CastExpression(
			    lookup_vartype( e ),
			    rdup_expression( init )
			);
		    }
		}
	    }
	    VariableNameExpression res = new_VariableNameExpression( rdup_origsymbol( nm ), VAR_LOCAL );
.call generate_walker_call "	    " res VariableNameExpression VariableNameExpression
	    if(
		!ctx->in_assign_lhs &&
		!ctx->in_typeof &&
		(
		    e == EntryNIL ||
		    !has_any_flag( e->flags, ACC_INIT )
		)
	    ){
		check_is_initialized( ctx, res->name );
	    }
	    return res;
	}
    }
    if( !visit_type( ctx->prog, ctx->org, ctx->owner ) ){
	internal_error( "The visit to type '%s' failed", ctx->owner->name );
    }
    const_VariableEntry field = bind_field(
	ctx,
	ctx->owner,
	ctx->owner,
	nm
    );
    if( field == VariableEntryNIL ){
	origsymbol_error( nm, "unknown variable" );
	return expressionNIL;
    }
    if( showmangling ){
	fprintf(
	    stderr,
	    "simple name '%s' refers to %sstatic field '%s'\n",
	    nm->sym->name,
	    has_any_flag( field->flags, ACC_STATIC )?"":"non",
	    field->name->name
	);
    }
    if( has_final_flag( field->flags ) ){
	if( !ctx->in_assign_lhs ){
	    const_expression init = get_init_expression( field );

	    if( init != expressionNIL && is_constant( init ) ){
		return new_CastExpression(
		    lookup_vartype( field ),
		    rdup_expression( init )
		);
	    }
	}
    }
    if( has_any_flag( field->flags, ACC_STATIC ) ){
	return new_VariableNameExpression(
	    new_origsymbol( field->name, rdup_origin( nm->org ) ),
	    VAR_STATFIELD
	);
    }
    else {
	if( ctx->where == CTX_STATICROUTINE ){
	    origin_error(
		nm->org,
		"Cannot make a static reference to an instance variable '%s' in class '%s'",
		nm->sym->name,
		ctx->owner->name
	    );
	    return expressionNIL;
	}
	if(
	    ctx->in_assign_lhs &&
	    has_any_flag( field->flags, ACC_COMPILECONSTANT )
	){
	    origin_error( ctx->org, "Cannot assign to a compile-time constant" );
	}
	OuterThisExpression th = new_OuterThisExpression(
	    new_ObjectType( add_origsymbol( field->owner ) )
	);
.call generate_descent_call "	" th OuterThisExpression OuterThisExpression
	return new_FieldExpression(
	    th,
	    new_origsymbol( field->name, rdup_origin( nm->org ) )
	);
    }
    //lint -unreachable
    return expressionNIL;
}

static expression construct_special_method_expression(
 mangle_data *ctx,
 const_MethodEntry me,
 const_expression_list thisparameters,
 const_expression_list parameters
)
{
    // A very dirty trick: let the hashCode() method return the length
    // of the array, since that is a number of the right type, and even
    // has some usefulness as a hash value (although there certainly are
    // beter hash functions).
    if( me == SPAR_ARRAYHASHCODE_METHODENTRY ){
	assert( parameters->sz == 0 );
	assert( thisparameters->sz == 1 );

	expression res = new_GetLengthExpression(
	    build_notnullassert( ctx, rdup_expression( thisparameters->arr[0] ) )
	);
	return res;
    }
    if( me == SPAR_GETSIZE_METHODENTRY ){
	assert( parameters->sz == 1 );
	assert( thisparameters->sz == 1 );

	expression res = new_GetSizeExpression(
	    build_notnullassert( ctx, rdup_expression( thisparameters->arr[0] ) ),
	    rdup_expression( parameters->arr[0] )
	);
	return res;
    }
    if( me == SPAR_GETSIZEVECTOR_METHODENTRY ){
	assert( parameters->sz == 0 );
	assert( thisparameters->sz == 1 );
	expression arr = thisparameters->arr[0];
	type art = derive_type_expression( ctx->symtab, arr );
	type cart = clean_type( art );
	assert( cart->tag == TAGArrayType );
	expression_list xl = new_expression_list();
	const_expression rankexpr = to_ArrayType(cart)->rank;
	unsigned int rank;

	if( !extract_array_rank( originNIL, rankexpr, &rank ) ){
	    rank = 0;
	}

	for( unsigned int n=0; n<rank; n++ ){
	    expression elm;

	    if( n == 0 ){
		elm = new_GetSizeExpression(
		    build_notnullassert( ctx, rdup_expression( arr ) ),
		    new_IntExpression( (int) n )
		);
	    }
	    else {
		elm = new_GetSizeExpression(
		    rdup_expression( arr ),
		    new_IntExpression( (int) n )
		);
	    }
	    xl = append_expression_list( xl, elm );
	}
	rfre_type( art );
	return new_VectorExpression( xl );
    }
    if( me == SPAR_ARRAYCLONE_METHODENTRY ){
	assert( parameters->sz == 0 );
	assert( thisparameters->sz == 1 );
	origsymbol tnm = add_origsymbol( "spar.compiler.Array" );
	origsymbol method = add_origsymbol( "arrayClone" );
	expression_list my_parms = new_expression_list();

	my_parms = append_expression_list(
	    my_parms,
	    rdup_expression( thisparameters->arr[0] )
	);
	me = bind_type_method(
	    ctx,
	    tnm,
	    method,
	    &my_parms
	);
	rfre_origsymbol( tnm );
	rfre_origsymbol( method );
	if( me == MethodEntryNIL ){
	    internal_error( "array cloning method binding failed" );
	}
	return new_MethodInvocationExpression(
	    new_MethodInvocation(
		expressionNIL,
		new_origsymbol( me->name, gen_origin() ),
		new_expression_list(),
		my_parms,
		0
	    )
	);
    }
    if( me == SPAR_ARRAYTOSTRING_METHODENTRY ){
	assert( parameters->sz == 0 );
	assert( thisparameters->sz == 1 );
	origsymbol tnm = add_origsymbol( "spar.compiler.Array" );
	origsymbol method = add_origsymbol( "arrayToString" );
	expression_list my_parms = new_expression_list();

	my_parms = append_expression_list(
	    my_parms,
	    rdup_expression( thisparameters->arr[0] )
	);
	me = bind_type_method(
	    ctx,
	    tnm,
	    method,
	    &my_parms
	);
	rfre_origsymbol( tnm );
	rfre_origsymbol( method );
	if( me == MethodEntryNIL ){
	    internal_error( "array toString method binding failed" );
	}
	return new_MethodInvocationExpression(
	    new_MethodInvocation(
		expressionNIL,
		new_origsymbol( me->name, gen_origin() ),
		new_expression_list(),
		my_parms,
		0
	    )
	);
    }
    if( me == SPAR_ARRAYEQUALS_METHODENTRY ){
	assert( parameters->sz == 1 );
	assert( thisparameters->sz == 1 );
	origsymbol tnm = add_origsymbol( "spar.compiler.Array" );
	origsymbol method = add_origsymbol( "arrayEquals" );
	expression_list my_parms = new_expression_list();

	my_parms = append_expression_list(
	    my_parms,
	    rdup_expression( thisparameters->arr[0] )
	);
	my_parms = append_expression_list(
	    my_parms,
	    rdup_expression( parameters->arr[0] )
	);
	me = bind_type_method(
	    ctx,
	    tnm,
	    method,
	    &my_parms
	);
	rfre_origsymbol( tnm );
	rfre_origsymbol( method );
	if( me == MethodEntryNIL ){
	    internal_error( "array equals method binding failed" );
	}
	return new_MethodInvocationExpression(
	    new_MethodInvocation(
		expressionNIL,
		new_origsymbol( me->name, gen_origin() ),
		new_expression_list(),
		my_parms,
		0
	    )
	);
    }
    return expressionNIL;
}

static statement construct_special_method_statement(
 mangle_data *ctx,
 Pragma_list pragmas,
 const_MethodEntry me
)
{
    statement res = statementNIL;
    if(
	me == SPAR_GETSIZE_METHODENTRY ||
	me == SPAR_ARRAYCLONE_METHODENTRY ||
	me == SPAR_ARRAYHASHCODE_METHODENTRY ||
	me == SPAR_ARRAYEQUALS_METHODENTRY ||
	me == SPAR_ARRAYTOSTRING_METHODENTRY ||
	me == SPAR_GETSIZEVECTOR_METHODENTRY
    ){
	// Since these functions don't have any effect, we may as well
	// put in an empty statement.
	res = new_EmptyStatement(
	    rdup_origin( ctx->org ),
	    rdup_Pragma_list( pragmas ),
	    origsymbol_listNIL	// Labels
	);
	if( warn_ignoredvalue ){
	    // TODO: this should perhaps be wired to a different warning
	    // option.
	    origin_warning( ctx->org, "statement has no effect" );
	}
    }
    return res;
}

// Given a label and the jump chain, return the element in the
// the jump chain that contains this label, or else return NULL
static jumpchain_element *search_jumpchain(
 jumpchain_element *l,
 const_origsymbol lbl
)
{
    while( l != NULL ){
	origsymbol_list labels = l->smt->labels;
	if( labels != origsymbol_listNIL ){
	    if( member_origsymbol_list( labels, lbl ) ){
		return l;
	    }
	}
	l = l->next;
    }
    return (jumpchain_element *) NULL;
}

static void report_AFLAG( FILE *f, AFLAG fl )
{
    const char *msg = "??";

    switch( fl ){
	case AF_YES:		msg = "yes";	 break;
	case AF_NO:		msg = "no";	 break;
	case AF_MAYBE:		msg = "maybe";	 break;
	case AF_UNKNOWN:	msg = "unknown";	 break;
    }
    fputs( msg, f );
}

static void report_AbstractValue( FILE *f, const_AbstractValue v )
{
    fputs( "zero=", f );
    report_AFLAG( f, v->zero );
    fputs( " positive=", f );
    report_AFLAG( f, v->positive );
}

// Given a variable name and a value, register the
// assignment of the value to the variable in the analysis information.
static void register_variable_assignment(
    mangle_data *ctx,
    tmsymbol nm,
    const_expression x
)
{
    AbstractValue av = abstract_value( x, ctx->states, ctx->symtab );
    ProgramState topst = ctx->states->arr[ctx->states->sz-1];
    VarState_list vl = topst->varStates;
    unsigned int pos;
    bool old_escapes = escapes( ctx, x );
    bool real_init = is_initialization( x );

    if( trace_analysis ){
#if 0
	if( strcmp( nm->name, "obj_5" ) == 0 ){
	    yup();
	}
#endif
	fprintf(
	    stderr,
	    "Deduction: variable '%s' %s escape.\n",
	    nm->name,
	    old_escapes?"may":"does not"
	);
    }

    if(
        dredge_var_programstate(
	    ctx->symtab,
	    ctx->states,
	    ctx->states->sz-1,
	    nm,
	    &pos
	)
    ){
	assert( pos<vl->sz );
	VarState v = vl->arr[pos];

	rfre_AbstractValue( v->value );
	v->value = av;
	v->escapes = old_escapes;
	v->defassigned = true;
	v->defunassigned = false;
    }
    else {
	vl = append_VarState_list(
	    vl,
	    new_VarState(
	        nm,
		false,			// not Final.
		old_escapes,		// Escapes?
		real_init,		// definitely assigned.
		!real_init,		// not definitely unassigned.
		av
	    )
	);
    }
    if( trace_analysis ){
	fprintf( stderr, "Variable '%s' has been assigned to.\n", nm->name );
	dump_programstates( stderr, ctx->states );
    }
}

// Given a variable name and a value, register that the value of the
// variable is 'x'. This conclusion may not come from an assignment,
// but from an if statement or something like that.
static void register_variable_equality(
    mangle_data *ctx,
    tmsymbol nm,
    const_expression x
)
{
    AbstractValue av = abstract_value( x, ctx->states, ctx->symtab );
    ProgramState topst = ctx->states->arr[ctx->states->sz-1];
    VarState_list vl = topst->varStates;
    unsigned int pos;

    if(
        dredge_var_programstate(
	    ctx->symtab,
	    ctx->states,
	    ctx->states->sz-1,
	    nm,
	    &pos
	)
    ){
	assert( pos<vl->sz );
	VarState v = vl->arr[pos];

	rfre_AbstractValue( v->value );
	v->value = av;
    }
    else {
	vl = append_VarState_list(
	    vl,
	    new_VarState(
	        nm,
		false,			// not Final.
		false,			// Escapes?
		false,			// definitely assigned.
		false,			// not definitely unassigned.
		av
	    )
	);
    }
    if( trace_analysis ){
	fprintf( stderr, "Abstract value of variable '%s' has been registered.\n", nm->name );
	dump_programstates( stderr, ctx->states );
    }
}

// Given a variable name and a value, register the
// assignment of the value to the variable in the analysis information.
static void register_variable_assignment(
    mangle_data *ctx,
    origsymbol nm,
    const_expression x
)
{
    register_variable_assignment( ctx, nm->sym, x );
}

// Given a variable name and a value, register the
// declaration and value of the cardinality variable.
static void register_cardinality(
    mangle_data *ctx,
    const_Cardinality card
)
{
    // TODO: have a better look at the bounds.
    AbstractValue av = build_neutral_AbstractValue();
    ProgramState topst = ctx->states->arr[ctx->states->sz-1];
    VarState_list vl = topst->varStates;
    unsigned int pos;

    if( search_var_programstate( vl, card->name->sym, &pos ) ){
	VarState v = vl->arr[pos];
	rfre_AbstractValue( v->value );
	v->value = av;
	v->final = true;
	v->defassigned = true;
	v->defunassigned = false;
    }
    else {
	vl = append_VarState_list(
	    vl,
	    new_VarState(
	        card->name->sym,
		true,			// Final?
		false,			// Does not escape (but who cares).
		true,			// definitely assigned.
		false,			// not definitely unassigned.
		av
	    )
	);
    }
    if( trace_analysis ){
	fprintf( stderr, "Cardinality '%s' has been declared. Value: ", card->name->sym->name );
	report_AbstractValue( stderr, av );
	fputs( "\n", stderr );
    }
}

// Given a variable name, register the declaration of that variable.
static void register_variable_declaration(
    mangle_data *ctx,
    origsymbol nm,
    bool final
)
{
    AbstractValue av = build_neutral_AbstractValue();
    ProgramState topst = ctx->states->arr[ctx->states->sz-1];
    VarState_list vl = topst->varStates;
    unsigned int pos;

    if( search_var_programstate( vl, nm->sym, &pos ) ){
	VarState v = vl->arr[pos];
	v->final = final;
	v->defassigned = false;
	v->defunassigned = true;
	rfre_AbstractValue( v->value );
	v->value = av;
    }
    else {
	vl = append_VarState_list(
	    vl,
	    new_VarState(
	        nm->sym,
		final,		// Final?
		false,		// may escape?
		false,		// not definitely assigned.
		true,		// definitely unassigned.
		av
	    )
	);
    }
    if( trace_analysis ){
	fprintf( stderr, "Variable '%s' has been declared. Value: ", nm->sym->name );
	report_AbstractValue( stderr, av );
	fputs( "\n", stderr );
    }
}

// Given a variable name, register that it will be changed later in
// the loop. This is treated as an assignment of a vague value to the
// variable at this point, the beginning of the loop.
static void register_variable_loopchanged(
    mangle_data *ctx,
    tmsymbol real_nm
)
{
    unsigned int ix;

    if( !search_VarTranslation( ctx->var_translations, real_nm, &ix ) ){
	return;
    }
    tmsymbol nm = ctx->var_translations->arr[ix]->to;
    if( showmangling ){
	fprintf(
	    stderr,
	    "mangled variable '%s' to '%s'\n",
	    real_nm->name,
	    nm->name
	);
    }

    unsigned int pos;
    ProgramState topst = ctx->states->arr[ctx->states->sz-1];
    VarState_list vl = topst->varStates;
    if(
	dredge_var_programstate(
	    ctx->symtab,
	    ctx->states,
	    ctx->states->sz-1,
	    nm,
	    &pos
	)
    ){
	assert( pos<vl->sz );
	VarState v = vl->arr[pos];
	v->escapes = true;		// TODO: can we find out more?
	v->value->zero = AF_MAYBE;
	v->value->positive = AF_MAYBE;
	// Don't touch defassigned
	v->defunassigned = false;
    }
    else {
	AbstractValue av = build_neutral_AbstractValue();
	vl = append_VarState_list(
	    vl,
	    new_VarState(
		nm,	// name
		false,	// not final
		true,	// may escape?	// TODO: can we find out more?
		false,	// not definitely assigned
		false,	// not definitely unassigned
		av	// Abstract value
	    )
	);
    }
    if( trace_analysis ){
	fprintf( stderr, "Variable '%s' will be changed in the loop.\n", nm->name );
	dump_programstates( stderr, ctx->states );
    }
}

static void register_variables_loopchanged(
 mangle_data *ctx,
 const_tmsymbol_list changed
)
{
    for( unsigned int ix=0; ix<changed->sz; ix++ ){
	register_variable_loopchanged( ctx, changed->arr[ix] );
    }
}

static const_ProgramState get_ProgramState_top( const mangle_data *ctx )
{
    unsigned int sz = ctx->states->sz;
    assert( sz>=1 );
    return ctx->states->arr[sz-1];
}

// Given a program state, return true iff the state indicates that
// execution will complete abruptly.
static bool completes_abruptly( const_ProgramState st )
{
    return st->throws == AF_YES || st->returns == AF_YES || st->jumps == AF_YES;
}

// Given a context, return true iff the top state indicates that
// execution will complete abruptly.
static bool completes_abruptly( const mangle_data *ctx )
{
    const_ProgramState topstate = get_ProgramState_top( ctx );
    return completes_abruptly( topstate );
}

// Given an outer scope variable state 'oldtop' and a variable entry from
// the inner variable state, merge the two, assuming that the
// state changes in the inner scope one *may* have occurred.
static void merge_possibletrip_varstate(
 const_Entry_list symtab,
 ProgramState_list states,
 unsigned int outerix,
 const_VarState inner
)
{
    unsigned int pos;

    assert( outerix<states->sz );
    if( dredge_var_programstate( symtab, states, outerix, inner->name, &pos ) ){
	VarState_list vl = states->arr[outerix]->varStates;
	assert( pos<vl->sz );
	VarState outer_var = vl->arr[pos];

	if( inner->escapes ){
	    outer_var->escapes = true;
	}
	if( !inner->defunassigned ){
	    outer_var->defunassigned = false;
	}
	abstract_either( outer_var->value, inner->value );
    }
}

// Given two variable states, merge the two, assuming that the
// state changes in the 'oldtop' one *may* have occurred.
static void merge_possibletrip_varstates(
 const_Entry_list symtab,
 ProgramState_list states,
 unsigned int outerix,
 VarState_list oldtop
)
{
    for( unsigned int ix=0; ix<oldtop->sz; ix++ ){
	merge_possibletrip_varstate( symtab, states, outerix, oldtop->arr[ix] );
    }
}

static void merge_onetrip_AbstractValue(
 AbstractValue outer,
 const_AbstractValue inner
)
{
    outer->zero = inner->zero;
    outer->positive = inner->positive;
    outer->constant = inner->constant;
    if( outer->value != NULL ){
	rfre_expression( outer->value );
    }
    outer->value = rdup_expression( inner->value );
}

// Return the maximum of two aflags.
static AFLAG aflag_max( const AFLAG a, const AFLAG b )
{
    if( a == AF_YES || b == AF_YES ) return AF_YES;
    if( a == AF_MAYBE || b == AF_MAYBE ) return AF_MAYBE;
    return AF_NO;
}

// Return the minimum of two aflags.
static AFLAG aflag_min( const AFLAG a, const AFLAG b )
{
    if( a == AF_NO || b == AF_NO ) return AF_NO;
    if( a == AF_MAYBE || b == AF_MAYBE ) return AF_MAYBE;
    return AF_YES;
}

// Return the then-else evaluation of two aflags.
static AFLAG aflag_thenelse( const AFLAG a, const AFLAG b )
{
    if( a == b ) return a;
    return AF_MAYBE;
}

// Given an outer scope variable state 'oldtop' and a variable entry from
// the inner variable state, merge the two, assuming that the
// state changes in the inner scope definitely occurred.
static void merge_onetrip_varstate(
 const_Entry_list symtab,
 ProgramState_list states,
 unsigned int outerix,
 const_VarState inner
)
{
    unsigned int pos;

    assert( outerix<states->sz );
    VarState_list vl = states->arr[outerix]->varStates;
    if( dredge_var_programstate( symtab, states, outerix, inner->name, &pos ) ){
	assert( pos<vl->sz );
	VarState outer_var = vl->arr[pos];

	if( inner->escapes ){
	    outer_var->escapes = true;
	}
	if( inner->defassigned ){
	    outer_var->defassigned = true;
	}
	if( !inner->defunassigned ){
	    outer_var->defunassigned = false;
	}
	merge_onetrip_AbstractValue( outer_var->value, inner->value );
    }
    else {
        vl = append_VarState_list( vl, rdup_VarState( inner ) );
    }
}

// Given two variable states, merge the two, assuming that the
// state changes in the 'oldtop' have certainly occurred.
static void merge_onetrip_varstates(
 const_Entry_list symtab,
 ProgramState_list states,
 unsigned int outerix,
 const_VarState_list oldtop
)
{
    for( unsigned int ix=0; ix<oldtop->sz; ix++ ){
	merge_onetrip_varstate( symtab, states, outerix, oldtop->arr[ix] );
    }
}

static void merge_multitrip_AbstractValue(
 AbstractValue outer,
 const_AbstractValue inner
)
{
    if( inner->constant ){
	outer->zero = inner->zero;
	outer->positive = inner->positive;
	if( outer->value != expressionNIL ){
	    rfre_expression( outer->value );
	}
	if( inner->value != expressionNIL ){
	    outer->value = rdup_expression( inner->value );
	}
	else {
	    outer->value = expressionNIL;
	}
    }
    else {
	outer->zero = AF_MAYBE;
	outer->positive = AF_MAYBE;
	if( outer->value != expressionNIL ){
	    rfre_expression( outer->value );
	    outer->value = expressionNIL;
	}
    }
    outer->constant = inner->constant;
}

// Given an outer scope variable state 'oldtop' and a variable entry from
// the inner variable state, merge the two, assuming that the
// state changes in the inner scope definitely occurred.
static void merge_multitrip_varstate(
 const_Entry_list symtab,
 ProgramState_list states,
 unsigned int outerix,
 const_VarState inner
)
{
    unsigned int pos;

    assert( outerix<states->sz );
    if( dredge_var_programstate( symtab, states, outerix, inner->name, &pos ) ){
	VarState_list vl = states->arr[outerix]->varStates;
	assert( pos<vl->sz );
	VarState outer_var = vl->arr[pos];

	if( inner->escapes ){
	    outer_var->escapes = true;
	}
	if( inner->defassigned ){
	    outer_var->defassigned = true;
	}
	if( !inner->defunassigned ){
	    outer_var->defunassigned = false;
	}
	merge_multitrip_AbstractValue( outer_var->value, inner->value );
    }
}

// Given two variable states, merge the two, assuming that the
// state changes in the 'oldtop' have certainly occurred, possibly
// several times.
static void merge_multitrip_varstates(
 const_Entry_list symtab,
 ProgramState_list states,
 unsigned int outerix,
 VarState_list oldtop
)
{
    for( unsigned int ix=0; ix<oldtop->sz; ix++ ){
	merge_multitrip_varstate( symtab, states, outerix, oldtop->arr[ix] );
    }
}

// Return a new, initial program state
static ProgramState build_initial_ProgramState( bool iterated )
{
    return new_ProgramState(
	new_tmsymbol_list(),	// completed static inits
	new_VarState_list(),
	new_tmsymbol_list(),	// thrown
	iterated,
	AF_NO,			// throws?
	AF_NO,			// jumps?
	AF_NO			// returns?
    );
}

// Given a context, create a new element in the program state chain.
static void push_programstate( ProgramState_list states, bool iterated, const char *who )
{
    states = append_ProgramState_list(
	states,
	build_initial_ProgramState( iterated )
    );
    if( trace_analysis ){
	fprintf(
	    stderr,
	    "Created new %sprogram state for %s (now %u active)\n",
	    iterated?"iterated ":"",
	    who,
	    states->sz
	);
	dump_programstates( stderr, states );
    }
}

// Extract and return the top context.
static ProgramState extract_programstate( ProgramState_list states )
{
    ProgramState res;
    int valid;

    states = extract_ProgramState_list( states, states->sz-1, &res, &valid );
    if( trace_analysis ){
	fprintf(
	    stderr,
	    "Extracted program state (now %u active)\n",
	    states->sz
	);
    }
    assert( valid );
    return res;
}

// Remove the top context.
static void pop_programstate( ProgramState_list states )
{
    assert( states->sz>0 );
    states = delete_ProgramState_list( states, states->sz-1 );
}

// Verbosely pop the top context.
static void pop_zerotrip_programstate( ProgramState_list states, const char *who )
{
    pop_programstate( states );
    if( trace_analysis ){
	fprintf(
	    stderr,
	    "Zerotrip merging of program state for %s (now %u active)\n",
	    who,
	    states->sz
	);
	dump_programstates( stderr, states );
    }
}

// Merge the given context. It is *perhaps* effective.
static void merge_possibletrip_programstate(
 const_Entry_list symtab,
 ProgramState_list states,
 const_ProgramState oldtopstate,
 const char *who
)
{
    if( completes_abruptly( oldtopstate ) ){
	if( trace_analysis ){
	    fprintf(
		stderr,
		"Possibletrip merging of program state for %s:\nTop state completes abruptly; dropped.\n",
		who
	    );
	    dump_programstates( stderr, states );
	}
    }
    // Since we don't know if anything has happened, it may be
    // necessary to label some things as 'perhaps'.
    unsigned int sz = states->sz;
    assert( sz>0 );
    merge_possibletrip_varstates(
	symtab,
	states,
	sz-1,
	oldtopstate->varStates
    );
    ProgramState newtopstate = states->arr[sz-1];
    newtopstate->throws = aflag_max( aflag_min( AF_MAYBE, oldtopstate->throws), newtopstate->throws );
    newtopstate->jumps = aflag_max( aflag_min( AF_MAYBE, oldtopstate->jumps), newtopstate->jumps );
    newtopstate->returns = aflag_max( aflag_min( AF_MAYBE, oldtopstate->returns), newtopstate->returns );
    newtopstate->thrown = add_tmsymbol_list( newtopstate->thrown, oldtopstate->thrown );
    if( trace_analysis ){
	fprintf(
	    stderr,
	    "Possibletrip merging of program state for %s\n",
	    who
	);
	dump_programstates( stderr, states );
    }
}

// Remove the top context. It is *perhaps* effective.
static void pop_possibletrip_programstate( const_Entry_list symtab, ProgramState_list states, const char *who )
{
    ProgramState topstate = extract_programstate( states );
    merge_possibletrip_programstate( symtab, states, topstate, who );
    rfre_ProgramState( topstate );
}

// Merge the given context. It is certain to be effective.
static void merge_onetrip_programstate(
 const_Entry_list symtab,
 ProgramState_list states,
 const_ProgramState oldtopstate,
 const char *who
)
{
    unsigned int sz = states->sz;
    assert( sz>0 );
    // Merge the information from the top program state into
    // the program state below it.
    ProgramState newtopstate = states->arr[sz-1];
    newtopstate->completedStaticInits = concat_tmsymbol_list(
	newtopstate->completedStaticInits,
	rdup_tmsymbol_list( oldtopstate->completedStaticInits )
    );
    merge_onetrip_varstates( symtab, states, sz-1, oldtopstate->varStates );
    newtopstate->throws = aflag_max( newtopstate->throws, oldtopstate->throws );
    newtopstate->jumps = aflag_max( newtopstate->jumps, oldtopstate->jumps );
    newtopstate->returns = aflag_max( newtopstate->returns, oldtopstate->returns );
    newtopstate->thrown = add_tmsymbol_list( newtopstate->thrown, oldtopstate->thrown );
    if( trace_analysis ){
	fprintf( stderr, "Onetrip merger of program state for %s (now %u active)\n", who, states->sz );
	dump_programstates( stderr, states );
    }
}

// Remove the top context. It is certain to be effective.
static void pop_onetrip_programstate(
 const_Entry_list symtab,
 ProgramState_list states,
 const char *who
)
{
    ProgramState topstate = extract_programstate( states );
    merge_onetrip_programstate( symtab, states, topstate, who );
    rfre_ProgramState( topstate );
}

// Given an outer scope variable state 'oldtop' and a variable entry from
// the inner variable state, merge the two, assuming that the
// state changes in the inner scope one *may* have occurred.
static VarState merge_thenelse_varstate(
 const_VarState thenstate,
 const_VarState elsestate
)
{
    AbstractValue av = build_neutral_AbstractValue();
    if( thenstate == VarStateNIL ){
	VarState res = new_VarState(
	    elsestate->name,
	    elsestate->final,
	    false,		// May escape?
	    false,		// Definitely assigned?
	    false, 		// Definitely unassigned?
	    av
	);
	return res;
    }
    if( elsestate == VarStateNIL ){
	VarState res = new_VarState(
	    thenstate->name,
	    thenstate->final,
	    false,		// May escape?
	    false,		// Definitely assigned?
	    false, 		// Definitely unassigned?
	    av
	);
	return res;
    }
    abstract_thenelse( av, thenstate->value, elsestate->value );
    VarState res = new_VarState(
	thenstate->name,
	thenstate->final,
	thenstate->escapes || elsestate->escapes,
	thenstate->defassigned && elsestate->defassigned,
	thenstate->defunassigned && elsestate->defunassigned,
	av
    );
    return res;
}

// Given a 'then' and an 'else' varstate list, merge them with the
// new top state.
static VarState_list merge_thenelse_varstates(
 const_VarState_list thenstates,
 const_VarState_list p_elsestates
)
{
    unsigned int ix;

    VarState_list res = new_VarState_list();
    VarState_list elsestates = rdup_VarState_list( p_elsestates );
    for( ix=0; ix<thenstates->sz; ix++ ){
	VarState v = thenstates->arr[ix];
	unsigned int pos;
	VarState r1;

	if( search_var_programstate( elsestates, v->name, &pos ) ){
	    r1 = merge_thenelse_varstate( v, elsestates->arr[pos] );
	    // Zap this entry from the 'else', since we already have done a
	    // merger for it.
	    elsestates = delete_VarState_list( elsestates, pos );
	}
	else {
	    r1 = merge_thenelse_varstate( v, VarStateNIL );
	}
	res = append_VarState_list( res, r1 );
    }
    for( ix=0; ix<elsestates->sz; ix++ ){
	res = append_VarState_list(
	    res,
	    merge_thenelse_varstate( VarStateNIL, elsestates->arr[ix] )
	);
    }
    rfre_VarState_list( elsestates );
    return res;
}

// Given two program states, return a new program state that represents
// the state if either of the two could possibly have been executed.
static ProgramState merge_thenelse_programstates(
 const_ProgramState thenstate,
 const_ProgramState elsestate
)
{
    if( trace_analysis ){
	fprintf( stderr, "starting then-else merging.\n" );
    }
    if( completes_abruptly( thenstate ) ){
	// Since the then branch completes abruptly, its end state is
	// irrelevant at this point. Take the resulting state from the else
	// branch.
	if( trace_analysis ){
	    fprintf( stderr, "Then branch completes abruptly, take the else branch state\n" );
	}
	ProgramState res = rdup_ProgramState( elsestate );
	res->thrown = add_tmsymbol_list( res->thrown, thenstate->thrown );
	return res;
    }
    if( completes_abruptly( elsestate ) ){
	// Since the then branch completes abruptly, its end state is
	// irrelevant at this point. Take the resulting state from the else
	// branch.
	if( trace_analysis ){
	    fprintf( stderr, "Else branch completes abruptly, take the then branch state\n" );
	}
	ProgramState res = rdup_ProgramState( thenstate );
	res->thrown = add_tmsymbol_list( res->thrown, elsestate->thrown );
	return res;
    }

    // Take the union of then and else branch thrown lists.
    tmsymbol_list allthrown = rdup_tmsymbol_list( thenstate->thrown );
    allthrown = add_tmsymbol_list( allthrown, elsestate->thrown );

    tmsymbol_list theninits = thenstate->completedStaticInits;
    tmsymbol_list elseinits = elsestate->completedStaticInits;
    tmsymbol_list csis = new_tmsymbol_list();

    if( trace_analysis ){
	fprintf( stderr, "Both then and else branch may complete normally; detailed merge required\n" );
    }
    for( unsigned int ix=0; ix<elseinits->sz; ix++ ){
	tmsymbol nm = elseinits->arr[ix];

	if( member_tmsymbol_list( theninits, nm ) ){
	    // Both the then and the else branch say they initialize
	    // this class, so we can assume it is initialized.
	    if( trace_analysis ){
		fprintf( stderr, "Both the then and the else initialize class '%s'\n", nm->name );
	    }
	    csis = append_tmsymbol_list( csis, nm );
	}
    }

    VarState_list vsl = merge_thenelse_varstates(
	thenstate->varStates,
	elsestate->varStates
    );
    assert( thenstate->iterated == elsestate->iterated );
    AFLAG throws = aflag_thenelse( thenstate->throws, elsestate->throws );
    AFLAG jumps = aflag_thenelse( thenstate->jumps, elsestate->jumps );
    AFLAG returns = aflag_thenelse( thenstate->returns, elsestate->returns );
    ProgramState res = new_ProgramState(
        csis,			// Completed static inits
	vsl,			// Varstates 
	allthrown,
	thenstate->iterated,	// Iterated?
	throws,
	jumps,
	returns
    );
    if( trace_analysis ){
	fprintf( stderr, "Completed then-else merge\n" );
	dump_programstate( stderr, 0, res );
    }
    return res;
}

// Remove the top context. Either this context, or the one in 'thenstate'
// was effective, so see if they have something in common.
// Delete the 'thenstate' when you're done.
static AFLAG pop_thenelse_programstate(
 const_Entry_list symtab,
 ProgramState_list states,
 ProgramState thenstate,
 const char *who
)
{
    unsigned int sz = states->sz;
    assert( sz>1 );
    // Merge the information from the top program state into
    // the program state below it.
    ProgramState elsestate = states->arr[sz-1];
    ProgramState mergedstate = merge_thenelse_programstates(
	thenstate,
	elsestate
    );
    rfre_ProgramState( states->arr[sz-1] );
    states->arr[sz-1] = mergedstate;
    pop_onetrip_programstate( symtab, states, who );
    rfre_ProgramState( thenstate );
    if( trace_analysis ){
	fprintf( stderr, "then-else merging of program state for %s (now %u active)\n", who, states->sz );
	dump_programstates( stderr, states );
    }
    // TODO: return more precisely whether the then branch is taken.
    return AF_MAYBE;
}

// Remove the top context. It is certain to be effective.
static void pop_multitrip_programstate( const_Entry_list symtab, ProgramState_list states, const char *who )
{
    unsigned int sz = states->sz;
    assert( sz>1 );
    // Merge the information from the top program state into
    // the program state below it.
    ProgramState newtopstate = states->arr[sz-2];
    ProgramState oldtopstate = states->arr[sz-1];
    newtopstate->completedStaticInits = concat_tmsymbol_list(
	newtopstate->completedStaticInits,
	oldtopstate->completedStaticInits
    );
    oldtopstate->completedStaticInits = tmsymbol_listNIL;
    merge_multitrip_varstates( symtab, states, sz-2, oldtopstate->varStates );
    newtopstate->throws = aflag_max( newtopstate->throws, oldtopstate->throws );
    newtopstate->jumps = aflag_max( newtopstate->jumps, oldtopstate->jumps );
    newtopstate->returns = aflag_max( newtopstate->returns, oldtopstate->returns );
    newtopstate->thrown = add_tmsymbol_list( newtopstate->thrown, oldtopstate->thrown );
    pop_programstate( states );
    if( trace_analysis ){
	fprintf(
	    stderr,
	    "Multitrip merging of program state for %s (now %u active)\n",
	    who,
	    states->sz
	);
	dump_programstates( stderr, states );
    }
}

// Register that we know that the statement/block does a break or continue.
static void register_jumps( mangle_data *ctx, jumpchain_element *e )
{
    if( e != NULL ){
	if( trace_analysis ){
	    fprintf(
		stderr,
		"For jump analysis: merging down program states to level %u\n",
		e->analysis_level
	    );
	    dump_programstates( stderr, ctx->states );
	}
	if( e->breaksource_states == NULL ){
	    e->breaksource_states = new_ProgramState_list();
	}
	ProgramState_list l = rdup_ProgramState_list( ctx->states );
	unsigned int analysis_level = e->analysis_level;

	while( l->sz>analysis_level ){
	    pop_onetrip_programstate( ctx->symtab, l, "jump analysis merging" );
	}
	ProgramState st = extract_programstate( l );
	if( trace_analysis ){
	    fprintf( stderr, "Jump analysis merging down completed:\n" );
	    dump_programstate( stderr, e->analysis_level, st );
	}
	e->breaksource_states = append_ProgramState_list( e->breaksource_states, st );
	rfre_ProgramState_list( l );
    }
    ProgramState topst = ctx->states->arr[ctx->states->sz-1];
    topst->jumps = AF_YES;
    if( trace_analysis ){
	fprintf(
	    stderr,
	    "Execution completes abruptly due to break or continue\n"
	);
	dump_programstates( stderr, ctx->states );
    }
}

// Register the presence of the catch variable 'nm'
static void register_catch_variable( ProgramState_list states, const_origsymbol nm )
{
    AbstractValue av = new_AbstractValue( AF_NO, AF_YES, true, expressionNIL );
    ProgramState topst = states->arr[states->sz-1];
    VarState_list vl = topst->varStates;
    unsigned int pos;

    if( search_var_programstate( vl, nm->sym, &pos ) ){
	VarState v = vl->arr[pos];
	rfre_AbstractValue( v->value );
	v->value = av;
	v->defassigned = true;
	v->defunassigned = false;
    }
    else {
	vl = append_VarState_list(
	    vl,
	    new_VarState(
	        nm->sym,
		false,		// final?
		true,		// may escape?
		true,		// definitely assigned
		false,		// not definitely unassigned.
		av
	    )
	);
    }
    if( trace_analysis ){
	fprintf( stderr, "Catch variable '%s' has been registered. Value: ", nm->sym->name );
	report_AbstractValue( stderr, av );
	fputs( "\n", stderr );
    }
}

static void register_FormalParameter( ProgramState_list states, const_FormalParameter parm, bool thisparm )
{
    AbstractValue av;

    if( thisparm ){
	av = new_AbstractValue( AF_NO, AF_YES, true, expressionNIL );
    }
    else {
	av = build_neutral_AbstractValue();
    }
    ProgramState topst = states->arr[states->sz-1];
    VarState_list vl = topst->varStates;
    unsigned int pos;

    if( search_var_programstate( vl, parm->name->sym, &pos ) ){
	VarState v = vl->arr[pos];
	rfre_AbstractValue( v->value );
	v->value = av;
	v->final = has_final_flag( parm->flags );
	v->defassigned = true;
	v->defunassigned = false;
    }
    else {
	vl = append_VarState_list(
	    vl,
	    new_VarState(
		parm->name->sym,
		has_final_flag( parm->flags ),
		false,		// escapes. TODO: set to false.
		true,
		false,
		av
	    )
	);
    }
    if( trace_analysis ){
	fprintf( stderr, "Formal parameter '%s' has been registered. Value: ", parm->name->sym->name );
	report_AbstractValue( stderr, av );
	fputs( "\n", stderr );
    }
}

static void register_FormalParameter_list( ProgramState_list states, FormalParameter_list parms, bool thisparm )
{
    for( unsigned int ix=0; ix<parms->sz; ix++ ){
	register_FormalParameter( states, parms->arr[ix], thisparm );
    }
}

// Given an operator, if it is a comparision operator, return its inverse.
// That is, return the operator that would be used if the then and else branch
// of an if would be exchanged.
static BINOP inverse_operator( BINOP op )
{
    switch( op ){
	case BINOP_EQUAL:		return BINOP_NOTEQUAL;
	case BINOP_NOTEQUAL:		return BINOP_EQUAL;
	case BINOP_LESS:		return BINOP_GREATEREQUAL;
	case BINOP_LESSEQUAL:		return BINOP_GREATER;
	case BINOP_GREATER:		return BINOP_LESSEQUAL;
	case BINOP_GREATEREQUAL:	return BINOP_LESS;
	default:			break;
    }
    return op;
}

// Given a condition expression and a 'then branch' flag, try to register the
// fact tested by the condition, or its opposite, as a fact.
static void register_condition( mangle_data *ctx, const_expression cond, bool then_branch )
{
    if( cond->tag == TAGAnnotationExpression ){
        register_condition( ctx, to_const_AnnotationExpression(cond)->x, then_branch );
	return;
    }
    if( cond->tag == TAGVariableNameExpression ){
	BooleanExpression val = new_BooleanExpression( then_branch );

	register_variable_equality(
	    ctx,
	    to_const_VariableNameExpression(cond)->name->sym,
	    val
	);
	rfre_expression( val );
	return;
    }
    if( cond->tag == TAGShortopExpression ){
	const_ShortopExpression cmp = to_const_ShortopExpression( cond );
	SHORTOP op = cmp->optor;

	if( op == SHORTOP_AND && then_branch ){
	    register_condition( ctx, cmp->left, then_branch );
	    register_condition( ctx, cmp->right, then_branch );
	    return;
	}
	if( op == SHORTOP_OR && !then_branch ){
	    register_condition( ctx, cmp->left, then_branch );
	    register_condition( ctx, cmp->right, then_branch );
	    return;
	}
    }
    if( cond->tag == TAGBinopExpression ){
	const_BinopExpression cmp = to_const_BinopExpression( cond );
	BINOP op = cmp->optor;

	if( !then_branch ){
	    op = inverse_operator( op );
	}
	if( cmp->left->tag == TAGVariableNameExpression ){
	    // We have <name> <op> <expr>
	    // See if we can deduce something
	    tmsymbol nm = to_VariableNameExpression(cmp->left)->name->sym;
	    if( op == BINOP_EQUAL ){
		register_variable_equality( ctx, nm, cmp->right );
	    }
	    AFLAG z = is_zero( cmp->right, ctx->states );
	    if( z == AF_YES ){
		// We have <name> <op> 0/null
		switch( op ){
		    case BINOP_NOTEQUAL:
			register_not_null( ctx->symtab, ctx->states, nm );
			break;

		    case BINOP_EQUAL:
			// Already handled elsewhere
			break;

		    case BINOP_LESSEQUAL:
			// There nothing useful to register.
			break;

		    case BINOP_GREATER:
			register_not_null( ctx->symtab, ctx->states, nm );
			register_positive( ctx->symtab, ctx->states, nm );
			break;

		    case BINOP_GREATEREQUAL:
			register_positive( ctx->symtab, ctx->states, nm );
			break;

		    case BINOP_LESS:
			register_negative( ctx->symtab, ctx->states, nm );
			break;

		    default:
			break;

		}
	    }
	    // TODO: do something clever with known constants.
	}
	if( cmp->right->tag == TAGVariableNameExpression ){
	    // We have <expr> <op> <name>
	    // See if we can deduce something
	    tmsymbol nm = to_VariableNameExpression(cmp->right)->name->sym;
	    if( op == BINOP_EQUAL ){
		register_variable_equality( ctx, nm, cmp->left );
	    }
	    AFLAG z = is_zero( cmp->left, ctx->states );
	    if( z == AF_YES ){
		// We have <null> <op> <name>
		switch( op ){
		    case BINOP_NOTEQUAL:
			register_not_null( ctx->symtab, ctx->states, nm );
			break;

		    case BINOP_EQUAL:
			// Already handled elsewhere
			break;

		    case BINOP_GREATEREQUAL:	// 0 >= <nm>
			break;

		    case BINOP_LESSEQUAL:	// 0 <= <nm>
			register_positive( ctx->symtab, ctx->states, nm );
			break;

		    case BINOP_GREATER:		// 0 > <nm>
			register_negative( ctx->symtab, ctx->states, nm );
			break;

		    case BINOP_LESS:		// 0 < <nm>
			register_not_null( ctx->symtab, ctx->states, nm );
			register_positive( ctx->symtab, ctx->states, nm );
			break;

		    default:
			break;
		}
	    }
	    // TODO: do something clever with known constants.
	}
	return;
    }
    return;
}


// Given a list of cardinalities and a loop body, unroll the loop for
// the cardinalities.
// All cardinality range specifications should be constants.
static Block unroll_for_body( const_Entry_list symtab, Cardinality_list cards, Block body )
{
    if( cards->sz == 0 ){
	return rdup_Block( body );
    }
    Cardinality card = cards->arr[0];
    Cardinality_list sublist = slice_Cardinality_list( cards, 1, cards->sz );
    vnus_int l = 0;
    vnus_int u = 0;
    vnus_int s = 1;
    if( card->lowerbound == expressionNIL ){
	l = 0;
    }
    else if( card->lowerbound->tag == TAGIntExpression ){
	l = to_IntExpression( card->lowerbound )->v;
    }
    else {
	origin_error( card->name->org, "The lowerbound of an inlined for should be a constant" );
	l = 0;
    }
    if( card->upperbound == expressionNIL ){
	u = 0;
    }
    else if( card->upperbound->tag == TAGIntExpression ){
	u = to_IntExpression( card->upperbound )->v;
    }
    else {
	origin_error( card->name->org, "The upperbound of an inlined for should be a constant" );
	u = 0;
    }
    if( card->stride == expressionNIL ){
	s = 1;
    }
    else if( card->stride->tag == TAGIntExpression ){
	s = to_IntExpression( card->stride )->v;
    }
    else {
	origin_error( card->name->org, "The stride of an inlined for should be a constant" );
	s = 0;
    }
    const_VariableEntry e = lookup_VariableEntry( symtab, card->name->sym );
    if( e == VariableEntryNIL ){
	return body;
    }
    statement_list sl = new_statement_list();
    ValueAbstraction_list vl = new_ValueAbstraction_list();
    IntExpression x = new_IntExpression( 0 );
    vl = append_ValueAbstraction_list(
	vl,
	new_ValueAbstraction( e->realname->sym, x )
    );
    for( vnus_int v=l; v<u; v += s ){
	Block blk = unroll_for_body( symtab, sublist, body );
	x->v = v;
	blk = substitute_Block(
	    card->name->org,
	    blk,
	    TypeAbstraction_listNIL,
	    NameTranslation_listNIL,
	    vl,
	    NameTranslation_listNIL,
	    NameTranslation_listNIL
	);
	BlockStatement smt = new_BlockStatement(
	    gen_origin(),
	    Pragma_listNIL,
	    origsymbol_listNIL,	// Labels
	    blk
	);
	sl = append_statement_list( sl, smt );
    }
    rfre_ValueAbstraction_list( vl );
    rfre_Cardinality_list( sublist );
    return new_Block( tmsymbolNIL, Pragma_listNIL, sl );
}

// Given a vector type 'vt' and a subscript expression 'x', return a
// TupleExpression where each element of the vector 'x' is explicitly
// addressed.
static VectorExpression build_VectorType_subscript(
    origin org,
    VectorType vt,
    expression x
)
{
    unsigned int sz;
    expression_list xl = new_expression_list();

    if( extract_vector_power( org, vt->power, &sz ) ){
	xl = setroom_expression_list( xl, sz );
	for( unsigned int ix=0; ix<sz; ix++ ){
	    xl = append_expression_list(
		xl,
		new_VectorSubscriptExpression( rdup_expression( x ), ix )
	    );
	}
    }
    return new_VectorExpression( xl );
}

// Forward declaration.
static expression simplify_BinopExpression( BinopExpression x, mangle_data *ctx );

// Given two expression 'xright' and xleft' that should refer to tuples,
// and an operator 'op', and the length of the tuple 'length', return a
// new tuple that contains the result of pair-wise application of the
// operator to the elements of the tuple.
static expression build_tuple_tuple_operation(
    mangle_data *ctx,
    const_expression xleft,
    BINOP op,
    const_expression xright,
    unsigned int length
)
{
    expression_list xl = setroom_expression_list( new_expression_list(), length );

    expression_list leftvec = expression_listNIL;
    expression_list rightvec = expression_listNIL;
    if( xleft->tag == TAGVectorExpression ){
        leftvec = to_const_VectorExpression(xleft)->fields;
	assert( leftvec->sz == length );
    }
    if( xright->tag == TAGVectorExpression ){
        rightvec = to_const_VectorExpression(xright)->fields;
	assert( rightvec->sz == length );
    }
    for( unsigned int ix=0; ix<length; ix++ ){
	expression l;
	expression r;

	if( leftvec != expression_listNIL ){
	    l = rdup_expression( leftvec->arr[ix] );
	}
	else {
	    l = new_VectorSubscriptExpression( rdup_expression( xleft ), ix );
	}
	if( rightvec != expression_listNIL ){
	    r = rdup_expression( rightvec->arr[ix] );
	}
	else {
	    r = new_VectorSubscriptExpression( rdup_expression( xright ), ix );
	}
	BinopExpression x1 = new_BinopExpression( l, op, r );
	xl = append_expression_list( xl, simplify_BinopExpression( x1, ctx ) );
    }
    return constant_fold_expression( new_VectorExpression( xl ) );
}

// Given two expression 'xright' and xleft' that should refer to a
// scalar and a tuple respectively, and an operator 'op', return a
// new tuple that contains the result of the repeated application of the
// operator to the elements of the tuple and the scalar.
static expression build_tuple_scalar_operation(
 mangle_data *ctx,
 const_expression xleft,
 BINOP op,
 const_expression xright,
 unsigned int length
)
{
    expression res;

    if( xleft->tag == TAGVectorExpression ){
	// We know this is [<l0>,<l1>,..] <op> <r>
	// rewrite immediately to [<l0> <op> <r>,<l1> <op> <r>, ...]
        VectorExpression r = to_VectorExpression( rdup_expression( xleft ) );
	expression_list fields = r->fields;

	assert( fields->sz == length );
	for( unsigned int ix=0; ix<fields->sz; ix++ ){
	    fields->arr[ix] = simplify_BinopExpression(
		new_BinopExpression(
		    fields->arr[ix],
		    op,
		    rdup_expression( xright )
		),
		ctx
	    );
	}
	res = r;
    }
    else {
	expression_list xl = setroom_expression_list( new_expression_list(), length );

	for( unsigned int ix=0; ix<length; ix++ ){
	    BinopExpression x1 = new_BinopExpression(
		new_VectorSubscriptExpression( rdup_expression( xleft ), ix ),
		op,
		rdup_expression( xright )
	    );
	    xl = append_expression_list( xl, simplify_BinopExpression( x1, ctx ) );
	}
	res = new_VectorExpression( xl );
    }
    return constant_fold_expression( res );
}

// Given two expression 'xright' and xleft' that should refer to a
// scalar and a tuple respectively, and an operator 'op', return a
// new tuple that contains the result of the repeated application of the
// operator to the elements of the tuple and the scalar.
static expression build_scalar_tuple_operation(
 mangle_data *ctx,
 const_expression xleft,
 BINOP op,
 const_expression xright,
 unsigned int length
)
{
    expression res;

    if( xright->tag == TAGVectorExpression ){
        // We know this is <l> <op> [<r0>,<r1>,<r2>, ... ]
	VectorExpression r = to_VectorExpression( rdup_expression( xright ) );
	expression_list fields = r->fields;

	assert( fields->sz == length );
	for( unsigned int ix=0; ix<fields->sz; ix++ ){
	    fields->arr[ix] = simplify_BinopExpression(
		new_BinopExpression(
		    rdup_expression( xleft ),
		    op,
		    fields->arr[ix]
		),
		ctx
	    );
	}
	res = r;
    }
    else {
	expression_list xl = setroom_expression_list( new_expression_list(), length );
	for( unsigned int ix=0; ix<length; ix++ ){
	    BinopExpression x1 = new_BinopExpression(
		rdup_expression( xleft ),
		op,
		new_VectorSubscriptExpression( rdup_expression( xright ), ix )
	    );
	    xl = append_expression_list( xl, simplify_BinopExpression( x1, ctx ) );
	}
	res = new_VectorExpression( xl );
    }
    return constant_fold_expression( res );
}

static UnopExpression mangle_scalar_UnopExpression_action( UnopExpression x, mangle_data *ctx )
{
    switch( x->optor ){
	case UNOP_INVERT:
	case UNOP_PLUS:
	case UNOP_NEGATE:
	    x->operand = do_unary_numeric_promotion( ctx->symtab, x->operand );
	    break;

	case UNOP_NOT:
	    break;
    }
    return x;
}

// Forward declaration.
static expression scalarize_UnopExpression( UnopExpression x, mangle_data *ctx );

// Given an expression 'xright' that should refer to a a tuple, and an
// operator 'op', return a new tuple expression that contains the result
// of the repeated application of the operator to the elements of the tuple.
static VectorExpression build_tuple_unary_operation(
 mangle_data *ctx,
 UNOP op,
 const_expression x,
 unsigned int length
)
{
    // TODO: do something smarter when x is an explicit vector.

    expression_list xl = setroom_expression_list( new_expression_list(), length );

    for( unsigned int ix=0; ix<length; ix++ ){
	UnopExpression x1 = new_UnopExpression(
	    op,
	    new_VectorSubscriptExpression( rdup_expression( x ), ix )
	);

	xl = append_expression_list(
	    xl,
	    scalarize_UnopExpression( x1, ctx )
	);
    }
    return new_VectorExpression( xl );
}

// Given an unary expression 'x', rewrite operations to tuples to scalars.
static expression scalarize_UnopExpression( UnopExpression x, mangle_data *ctx )
{
    type t = derive_type_expression( ctx->symtab, x->operand );
    expression res;

    if( is_tuple_type( t ) ){
	unsigned int length;

	if( !extract_tuple_length( ctx->org, t, &length ) ){
	    length = 0;
	}
	res = build_tuple_unary_operation(
	    ctx,
	    x->optor,
	    x->operand,
	    length
	);
	rfre_expression( x );
    }
    else {
	res = mangle_scalar_UnopExpression_action( x, ctx );
    }
    rfre_type( t );
    return res;
}

// Given an operator, return true if this operator works on strings.
static bool is_string_operator( BINOP op )
{
    bool res = false;

    switch( op ){
	case BINOP_TIMES:
	case BINOP_XOR:
	case BINOP_DIVIDE:
	case BINOP_AND:
	case BINOP_GREATER:
	case BINOP_GREATEREQUAL:
	case BINOP_LESS:
	case BINOP_LESSEQUAL:
	case BINOP_MINUS:
	case BINOP_MOD:
	case BINOP_OR:
	case BINOP_SHIFTRIGHT:
	case BINOP_USHIFTRIGHT:
	case BINOP_SHIFTLEFT:
	    res = false;
	    break;

	case BINOP_EQUAL:
	case BINOP_NOTEQUAL:
	case BINOP_PLUS:
	    res = true;
	    break;
    }
    return res;
}

static expression simplify_BinopExpression( BinopExpression x, mangle_data *ctx )
{
    // We must do constant folding now to accomodate constant string
    // concatenation, since this is mandatory according to JLS2 3.10.6,
    // and we want to catch the expression before it is wrapped in
    // internalization calls.
    expression res = constant_fold_expression( x );
    if( res->tag != TAGBinopExpression ){
	return res;
    }
    x = (BinopExpression) res;
    type tleft = derive_type_expression( ctx->symtab, x->left );
    type tright = derive_type_expression( ctx->symtab, x->right );
    if( tright == typeNIL || tleft == typeNIL ){
	rfre_type( tright );
	rfre_type( tleft );
        return x;
    }

    if( is_tuple_type( tleft ) ){
	unsigned int sz_left = 0;

	if( !extract_tuple_length( ctx->org, tleft, &sz_left ) ){
	    sz_left = 0;
	}
	if( is_tuple_type( tright ) ){
	    unsigned int sz_right = 0;

	    if( !extract_tuple_length( ctx->org, tright, &sz_right ) ){
		sz_right = 0;
	    }
	    // An operation on two tuples
	    if( sz_left != sz_right ){
		origin_error(
		    ctx->org,
		    "A binary operator on two tuples requires equal lengths"
		);
		res = expressionNIL;
	    }
	    else {
		// An operation on two tuples of the same length.
		res = build_tuple_tuple_operation(
		    ctx,
		    x->left,
		    x->optor,
		    x->right,
		    sz_left
		);
	    }
	}
	else {
	    unsigned int sz;

	    // A tuple-scalar operation
	    if( !extract_tuple_length( ctx->org, tleft, &sz ) ){
		sz = 0;
	    }
	    res = build_tuple_scalar_operation(
		ctx,
		x->left,
		x->optor,
		x->right,
		sz
	    );
	}
	rfre_expression( x );
	rfre_type( tleft );
	rfre_type( tright );
	return res;
    }
    else if( is_tuple_type( tright ) ){
	unsigned int sz;

	// A tuple-scalar operation
	if( !extract_tuple_length( ctx->org, tright, &sz ) ){
	    sz = 0;
	}
	// A tuple-scalar operation
	res = build_scalar_tuple_operation(
	    ctx,
	    x->left,
	    x->optor,
	    x->right,
	    sz
	);
	rfre_expression( x );
	rfre_type( tleft );
	rfre_type( tright );
	return res;
    }
    switch( x->optor ){
	case BINOP_AND:
	case BINOP_DIVIDE:
	case BINOP_EQUAL:
	case BINOP_GREATER:
	case BINOP_GREATEREQUAL:
	case BINOP_LESS:
	case BINOP_LESSEQUAL:
	case BINOP_MINUS:
	case BINOP_MOD:
	case BINOP_NOTEQUAL:
	case BINOP_OR:
	case BINOP_PLUS:
	case BINOP_TIMES:
	case BINOP_XOR:
	{
	    if( is_string_operator( x->optor ) && is_vnusstring_type( tleft ) ){
		x->left = internalize_Vnus_string( ctx, x->left );
		rfre_type( tleft );
		tleft = new_ObjectType( add_origsymbol( "java.lang.String" ) );
	    }
	    if( is_string_operator( x->optor ) && is_vnusstring_type( tright ) ){
		x->right = internalize_Vnus_string( ctx, x->right );
		rfre_type( tright );
		tright = new_ObjectType( add_origsymbol( "java.lang.String" ) );
	    }
	    if(
	        x->optor == BINOP_PLUS &&
		(is_String_type( tleft ) || is_String_type( tright ) )
	    ){
		// TODO: delete this test. build_string_Convert_expression
		// does the right thing for strings, and it also
		// generates a test that puts in the string "null" when
		// the string is a null pointer.
		// It may produce an internal error, though.
		if( !is_String_type( tleft ) ){
		   x->left = build_stringConvert_expression( ctx, x->left );
		}
		x->right = build_stringConvert_expression( ctx, x->right );
		expression new_x = build_string_concat( ctx, x->left, x->right );
		rfre_expression( x );
		res = new_x;
	    }
	    else {
		type tx = max_types( tleft, tright );

		x->left = force_type( ctx->symtab, x->left, tx );
		x->right = force_type( ctx->symtab, x->right, tx );
		rfre_type( tx );
	    }
	    break;
	}


	case BINOP_SHIFTRIGHT:
	case BINOP_USHIFTRIGHT:
	case BINOP_SHIFTLEFT:
	    x->left = do_unary_numeric_promotion( ctx->symtab, x->left );
	    x->right = do_unary_numeric_promotion( ctx->symtab, x->right );
	    // This below is required by Vnus.
	    x->right = force_basetype( ctx->symtab, x->right, BT_INT );
	    break;
    }
    rfre_type( tleft );
    rfre_type( tright );
    return res;
}

static expression simplify_ShortopExpression( ShortopExpression x, mangle_data *ctx )
{
    // We must do constant folding now to accomodate constant string
    // concatenation, since this is mandatory according to JLS2 3.10.6,
    // and we want to catch the expression before it is wrapped in
    // internalization calls.
    expression res = constant_fold_expression( x );
    if( res->tag != TAGShortopExpression ){
	return res;
    }
    x = (ShortopExpression) res;
    type tleft = derive_type_expression( ctx->symtab, x->left );
    type tright = derive_type_expression( ctx->symtab, x->right );
    if( tright == typeNIL || tleft == typeNIL ){
	rfre_type( tright );
	rfre_type( tleft );
        return x;
    }

    if( is_tuple_type( tleft ) || is_tuple_type( tright ) ){
	origin_error(
	    ctx->org,
	    "A shortcircuit operator does not work on tuples"
	);
	rfre_type( tright );
	rfre_type( tleft );
        return x;
    }
    if( !is_boolean_type( tleft ) || !is_boolean_type( tright ) ){
	origin_error(
	    ctx->org,
	    "A shortcircuit operator requires boolean operands"
	);
        return x;
    }
    rfre_type( tright );
    rfre_type( tleft );
    switch( x->optor ){
	case SHORTOP_AND:
	    if( x->left->tag == TAGBooleanExpression ){
		vnus_boolean val = to_BooleanExpression( x->left )->b;

		if( val ){
		    // rewrite true && y => y
		    res = x->right;
		    x->right = expressionNIL;
		}
		else {
		    // rewrite false && y => false
		    res = x->left;
		    x->left = expressionNIL;
		}
		rfre_expression( x );
		return res;
	    }
	    if( is_true_constant( x->right ) ){
		// rewrite y && true => y
		res = x->left;
		x->left = expressionNIL;
		rfre_expression( x );
		return res;
	    }
	    if(
	        is_false_constant( x->right ) &&
		!maybe_has_sideeffect( x->left, NO_SE_ARRAY_NEW )
	    ){
		// rewrite y && false => false
		res = x->right;
		x->right = expressionNIL;
		rfre_expression( x );
		return res;
	    }
	    break;

	case SHORTOP_OR:
	    if( x->left->tag == TAGBooleanExpression ){
		vnus_boolean val = to_BooleanExpression( x->left )->b;

		if( val ){
		    // rewrite true || y => true
		    res = x->left;
		    x->left = expressionNIL;
		}
		else {
		    // rewrite false || y => y
		    res = x->right;
		    x->right = expressionNIL;
		}
		rfre_expression( x );
		rfre_type( tleft );
		rfre_type( tright );
		return res;
	    }
	    if( is_false_constant( x->right ) ){
		// rewrite y || false => y
		res = x->left;
		x->left = expressionNIL;
		rfre_expression( x );
		return res;
	    }
	    if(
	        is_true_constant( x->right ) &&
		!maybe_has_sideeffect( x->left, NO_SE_ARRAY_NEW )
	    ){
		// rewrite y || true => true
		res = x->right;
		x->right = expressionNIL;
		rfre_expression( x );
		return res;
	    }
	    break;

    }
    return res;
}

// Given a list of types, register them as throwable types in this context.
static void register_allowed_throw( mangle_data *ctx, const_type t )
{
    switch( t->tag ){
	case TAGPragmaType:
	    register_allowed_throw( ctx, to_const_PragmaType(t)->t );
	    break;

	case TAGPrimitiveType:
	case TAGTypeType:
	case TAGTupleType:
	case TAGVectorType:
	case TAGNullType:
	case TAGFunctionType:
	case TAGTypeOf:
	case TAGTypeOfIf:
	case TAGVoidType:
	case TAGArrayType:
	case TAGPrimArrayType:
	case TAGExceptionVariableType:
	case TAGGCRefLinkType:
	case TAGGCTopRefLinkType:
	case TAGGenericObjectType:
	{
	    tmstring tnm = typename_type( t );
	    internal_error( "A type '%s' is not throwable", tnm );
	    break;
	}

	case TAGObjectType:
	    ctx->allowed_throws = append_tmsymbol_list(
		ctx->allowed_throws,
		to_const_ObjectType(t)->name->sym
	    );
	    break;
    }
}

// Given a list of types, register them as throwable types in this context.
static void register_allowed_throws( mangle_data *ctx, const_type_list tl )
{
    for( unsigned int ix=0; ix<tl->sz; ix++ ){
	register_allowed_throw( ctx, tl->arr[ix] );
    }
}

// Given an index, delete all throwable types at and beyond this index.
static void zap_allowed_throws( mangle_data *ctx, unsigned int ix )
{
    if( ctx->allowed_throws->sz>ix ){
	// In general we should use delete_tmsymbol_list to delete
	// the elements one by one. Since we know that rfre_tmsymbol
	// is a null operation, all that does is update the size
	// of the array. We may as well do that ourselves, and save
	// a lot of bother.
	ctx->allowed_throws->sz = ix;
    }
}

// Given a type name, return true iff it is an unchecked exception according
// to JLS2 11.2. That is, if the type is a subclass of
// java.lang.RuntimeException or java.lang.Error.
//
// Note that we test for unchecked exceptions instead of checked exceptions,
// since this way we can without lying return 'false' for classes that are not
// valid exceptions at all.
static bool is_unchecked_exception(
 const_TypeEntry_list typelist,
 tmsymbol tnm
)
{
    if( is_subclass( typelist, tnm, add_tmsymbol( "java.lang.RuntimeException" ) ) ){
	return true;
    }
    if( is_subclass( typelist, tnm, add_tmsymbol( "java.lang.Error" ) ) ){
	return true;
    }
    return false;
}

// Given a type name 'tnm' and a list of types that may be thrown,
// return true if this exception may be thrown.
static bool is_valid_thrown_type(
 const_TypeEntry_list typelist,
 origsymbol tnm,
 tmsymbol_list allowed_throws
)
{
    tmsymbol tsym = tnm->sym;
    // This implements JLS2 14.17
    // Exceptions that are subclass of RuntimeException don't have
    // to be declared explicitly as a thrown class.
    if( is_unchecked_exception( typelist, tsym ) ){
	return true;
    }
    for( unsigned int ix=0; ix<allowed_throws->sz; ix++ ){
	if( is_subclass( typelist, tsym, allowed_throws->arr[ix] ) ){
	    return true;
	}
    }
    return false;
}

static bool check_invoked_throws( mangle_data *ctx, const_type_list throws )
{
    bool ok = true;

    for( unsigned int ix=0; ix<throws->sz; ix++ ){
	const_type t = throws->arr[ix];

	if( t->tag != TAGObjectType ){
	    tmstring tstr = typename_type( t );
	    origin_error(
		ctx->org,
		"Only classes can be thrown, not %s",
		tstr
	    );
	    rfre_tmstring( tstr );
	    return false;
	}
	origsymbol tnm = to_const_ObjectType(t)->name;
	ok &= visit_type( ctx->prog, tnm );
	if( !is_valid_thrown_type( ctx->typelist, tnm, ctx->allowed_throws ) ){
	    origin_error(
		ctx->org,
		"Exception %s must be caught, or must be declared in the throws clause of this method",
		tnm->sym->name
	    );
	    ok = false;
	}
    }
    return ok;
}


// Given the current context and an unbound variable from a local
// class, enforce:
//
// Any local variable, formal method parameter or exception handler
// parameter used but not declared in an inner class must be declared
// final, and must be definitely assigned before the body of the
// inner class. -- JLS2 8.1.2.
static HiddenParameter build_hiddenparm(
 mangle_data *ctx,
 const_origsymbol var
)
{
    unsigned int ix;
    const_VarTranslation_list tab = ctx->var_translations;

    if( !search_VarTranslation( tab, var->sym, &ix ) ){
	// No translation found. Presumably this unbound variable
	// is a type or package.
        return HiddenParameterNIL;
    }
    if( showmangling ){
	fprintf(
	    stderr,
	    "hidden parameter '%s' maps to '%s'\n",
	    var->sym->name,
	    tab->arr[ix]->to->name
	);
    }
    tmsymbol mangled_name = tab->arr[ix]->to;

    if( mangled_name == tmsymbolNIL ){
	// Aparently there is a problem. Don't make it worse by complaining.
	return HiddenParameterNIL;
    }
    const_VariableEntry e = lookup_VariableEntry( ctx->symtab, mangled_name );
    type t = typeNIL;

    switch( e->tag ){
	case TAGFormalParameterEntry:
	    t = rdup_type( to_const_FormalParameterEntry(e)->t );
	    break;

	case TAGCardinalityVariableEntry:
	    t = new_PrimitiveType( BT_INT );
	    break;

	case TAGLocalVariableEntry:
	    t = rdup_type( to_const_LocalVariableEntry(e)->t );
	    break;

	default:
	    break;

    }
    if( t == typeNIL ){
	// This is not a hidden parameter, stop.
	return HiddenParameterNIL;
    }
    if( !has_any_flag( e->flags, ACC_FINAL ) ){
	origsymbol_error( var, "Variable should be declared 'final'" );
    }
    check_is_initialized( ctx, mangled_name, var->org );
    return new_HiddenParameter( var->sym, t );
}

// Given the current context and a list of unbound variables from a local
// class, enforce:
//
// Any local variable, formal method parameter or exception handler
// parameter used but not declared in an inner class must be declared
// final, and must be definitely assigned before the body of the
// inner class. -- JLS2 8.1.2.
static HiddenParameter_list build_hiddenparms(
 mangle_data *ctx,
 const_origsymbol_list unbounds
)
{
    HiddenParameter_list parms = new_HiddenParameter_list();

    parms = setroom_HiddenParameter_list( parms, unbounds->sz );
    for( unsigned int ix=0; ix<unbounds->sz; ix++ ){
	HiddenParameter parm = build_hiddenparm( ctx, unbounds->arr[ix] );

	if( parm != HiddenParameterNIL ){
	    parms = append_HiddenParameter_list( parms, parm );
	}
    }
    return parms;
}

// Given the superclass type of the anonymous class, the parameters passed to
// its constructor and the body, construct an anonymous class.
static ClassDeclaration build_anonymous_class(
 mangle_data *ctx,
 type cl,
 const_expression_list parameters,
 const_statement_list body
)
{
    tmsymbol tnm = translate_type( ctx, cl );
    if( tnm == tmsymbolNIL ){
	tmstring tstr = typename_type( cl );

	internal_error( "Cannot translate type '%s'", tstr );
    }
    (void) visit_type( ctx->prog, ctx->org, tnm );
    FormalParameter_list cons_formals = new_FormalParameter_list();
    tmsymbol classname = gen_tmsymbol( "anonymous" );
    origin org = originNIL;
    if( cl->tag == TAGObjectType ){
	org = rdup_origin( to_ObjectType( cl )->name->org );
	to_ObjectType(cl)->name->sym = tnm;
    }
    if( org == originNIL ){
	org = gen_origin();
    }
    statement_list an_body = rdup_statement_list( body );
    statement_list conssmts = new_statement_list();
    expression_list actuals = new_expression_list();

    for( unsigned int ix=0; ix<parameters->sz; ix++ ){
	const_expression parm = parameters->arr[ix];

	tmsymbol nm = gen_tmsymbol( "p" );
	type tp = derive_type_expression( ctx->symtab, parm );
	FormalParameter formal = new_FormalParameter(
	    add_origsymbol( nm ),
	    Pragma_listNIL,
	    0,				// flags
	    tp
	);
	cons_formals = append_FormalParameter_list( cons_formals, formal );
	expression actual = new_VariableNameExpression( add_origsymbol( nm ), 0 );
	actuals = append_expression_list( actuals, actual );
    }
    SuperConstructorInvocationStatement supercall = new_SuperConstructorInvocationStatement(
	gen_origin(),
	Pragma_listNIL,
	new_origsymbol_list(),		// labels
	actuals
    );
    conssmts = append_statement_list( conssmts, supercall );
    Block consbody = new_Block(
	tmsymbolNIL,			// Scope name
	Pragma_listNIL,
	conssmts
    );
    // Construct list of constructor formals from the parameter list.
    ConstructorDeclaration constructor = new_ConstructorDeclaration(
	gen_origin(),
	Pragma_listNIL,
	new_origsymbol_list(),
	0,				// Modifiers
	false,				// Used?
	new_origsymbol( classname, org ),	// Constructor name is class name.
	cons_formals,			// Formal parameters
	new_type_list(),		// Throws clause. TODO: Should be copied from superclass.
	consbody
    );
    type_list interfaces = new_type_list();
    type super = rdup_type( cl );
    const_TypeEntry super_e = lookup_TypeEntry( ctx->typelist, tnm );
    if( super_e != TypeEntryNIL && super_e->tag == TAGInterfaceEntry ){
	// We're subclassing an interface. Rearrange some stuff.
	interfaces = append_type_list( interfaces, super );
	super = new_ObjectType( add_origsymbol( "java.lang.Object" ) );
    }
    an_body = append_statement_list( an_body, constructor );
    ClassDeclaration res = new_ClassDeclaration(
	gen_origin(),
	Pragma_listNIL,
	new_origsymbol_list(),
	ACC_FINAL|ACC_LOCAL_OBJECT,
	false,				// used?
	new_origsymbol( classname, rdup_origin( org ) ),
	new_FormalParameter_list(),	// This is not a parameterized class.
	interfaces,			// No interfaces 
	an_body,
	tmsymbolNIL,			// name of dynamic init fn.
	tmsymbolNIL,			// name of static init fn.
	tmsymbolNIL,			// name of static init 'done' var.
	false,				// Trivial local init block?
	HiddenParameter_listNIL,	// Hidden parms to constructors.
	super				// Superclass.
    );
    if( trace_innerclasses ){
	dump_statement( stderr, res, "Anonymous class is transformed to the following local class" );
    }
    return res;
}

// Given an expression, add a new local variable definition to the
// pre-spill statements, and return an expression that refers to
// this variable.
static expression breakout_expression( mangle_data *ctx, expression x )
{
    if( ctx->in_typeof ){
	return x;
    }
    origsymbol nm = gen_origsymbol( "breakout" );
    FieldDeclaration d = new_FieldDeclaration(
	rdup_origin( ctx->org ),
	Pragma_listNIL,
	origsymbol_listNIL,	// Labels
	ACC_FINAL,
	false,
	rdup_origsymbol( nm ),
	new_TypeOf( rdup_expression( x ) ),
	new_OptExprNone()
    );
    context oldwhere = ctx->where;
    assert( oldwhere != CTX_GLOBAL && oldwhere != CTX_OBJECT );
    if( oldwhere == CTX_STATICINIT ){
	ctx->where = CTX_STATICROUTINE;
    }
    else if( oldwhere == CTX_DYNAMICINIT ){
	ctx->where = CTX_DYNAMICROUTINE;
    }
.call generate_descent_call "    " d FieldDeclaration FieldDeclaration
    ctx->breakout_declarations = append_statement_list( ctx->breakout_declarations, d );
    VariableNameExpression lhs = new_VariableNameExpression( rdup_origsymbol( nm ), VAR_GENERATED|VAR_LOCAL );
    AssignStatement smt = new_AssignStatement(
	gen_origin(),
	Pragma_listNIL,
	new_origsymbol_list(),
	ASSIGN,
	lhs,
	x
    );
.call generate_descent_call "    " smt AssignStatement AssignStatement
    ctx->where = oldwhere;
    ctx->mangled_pre_spill_smts = append_statement_list(
	ctx->mangled_pre_spill_smts,
	smt
    );
    VariableNameExpression res = new_VariableNameExpression( nm, VAR_FINAL|VAR_GENERATED|VAR_LOCAL );
    return res;
}

// Given a context, a type name and a field of that type, return true iff
// the given field is a compile-time constant.
static expression get_compiletime_constant_class_field(
 SparProgram *prog,
 const_Entry_list symtab,
 const_TypeEntry_list typelist,
 tmsymbol from_where,
 tmsymbol in_where,
 const_origsymbol fieldnm
)
{
    if( strcmp( fieldnm->sym->name, "class" ) == 0 ){
	return expressionNIL;
    }
    // TODO: do we need this?
    if( !visit_type( prog, originNIL, in_where ) ){
	return expressionNIL;
    }
    const_FieldMapping field = bind_Field_to_Mapping(
	prog,
	symtab,
	typelist,
	in_where,
	from_where,
	fieldnm
    );
    if( field == FieldMappingNIL ){
	origsymbol_error( fieldnm, "Unknown field in type '%s'", in_where->name );
	return expressionNIL;
    }
    if( !has_flags( field->realname->flags, ACC_FINAL ) ){
	// This cannot possibly be a compile-time constant.
	return expressionNIL;
    }
    const_Entry e = search_Entry( symtab, field->mangledname );
    if( e == EntryNIL ){
	// This field does not yet have a symbol-table entry, so
	// do it the hard way.
	return get_compiletime_constant_SparProgram_field( prog, fieldnm, field->classname );
    }
    if( has_any_flag( e->flags, ACC_COMPILECONSTANT ) ){
	origsymbol fullnm = rdup_origsymbol( fieldnm );
	fullnm->sym = qualify_tmsymbol( in_where, fullnm->sym );
	return new_VariableNameExpression( fullnm, 0 );
    }
    const_expression init = get_init_expression( e );
    if( init != expressionNIL ){
	// TODO: do something smarter than this.
	if( is_compiletime_constant( init, origsymbol_listNIL ) ){
	    origsymbol fullnm = rdup_origsymbol( fieldnm );
	    fullnm->sym = qualify_tmsymbol( in_where, fullnm->sym );
	    return new_VariableNameExpression( fullnm, 0 );
	}
    }
    return expressionNIL;
}

// Given a context, a type and a field of that type, return its value if
// the given field is a compile-time constant, else return expressionNIL.
static expression get_compiletime_constant_class_field(
 SparProgram *prog,
 const_Entry_list symtab,
 const_TypeEntry_list typelist,
 tmsymbol from_where,
 const_type t,
 const_origsymbol fieldnm
)
{
    expression res = expressionNIL;

    if( t == typeNIL ){
        return expressionNIL;
    }
    switch( t->tag ){
	case TAGPragmaType:
	    res = get_compiletime_constant_class_field( prog, symtab, typelist, from_where, to_const_PragmaType( t )->t, fieldnm );
	    break;

	case TAGObjectType:
	    res = get_compiletime_constant_class_field( prog, symtab, typelist, from_where, to_const_ObjectType( t )->name->sym, fieldnm );
	    break;

	case TAGPrimitiveType:
	case TAGTypeOf:
	case TAGTypeOfIf:
	case TAGTypeType:
	case TAGNullType:
	case TAGVoidType:
	case TAGExceptionVariableType:
	case TAGGCRefLinkType:
	case TAGGCTopRefLinkType:
	case TAGArrayType:
	case TAGPrimArrayType:
	case TAGGenericObjectType:
	case TAGFunctionType:
	case TAGTupleType:
	case TAGVectorType:
	    res = expressionNIL;
	    break;

    }
    return res;
}

// Given a variable and a context, return its value if the variable
// is a compile-time constant, else return expressionNIL.
static expression get_compiletime_constant_var(
 mangle_data *ctx,
 const_origsymbol nm
)
{
    unsigned int pos;

    if( trace_analysis ){
	fprintf(
	    stderr,
	    "Deciding whether %s:%ld:%s is a compile-time constant\n",
	    nm->org->file->name,
	    (long int) nm->org->line,
	    nm->sym->name
	);
    }
    bool old_in_typeof = ctx->in_typeof;
    ctx->in_typeof = true;
    expression resx = expressionNIL;

    if( is_qualified_origsymbol( nm ) ){
	origsymbol first;
	origsymbol last;

	break_qualified_name( nm, &first, &last );
	if( search_VarTranslation( ctx->var_translations, first->sym, &pos ) ){
	    // This is a reference to a field of a variable.
	    if( showmangling ){
		fprintf(
		    stderr,
		    "qualified name '%s' is a field reference of a local variable\n",
		    nm->sym->name
		);
	    }
	    // TODO: It's nonsense to call bind_variable, since we already
	    // have found it in var_translations.
	    expression x = bind_variable( first, ctx );
	    type t = derive_type_expression( ctx->symtab, x );
	    rfre_expression( x );
	    resx = get_compiletime_constant_class_field(
		ctx->prog,
		ctx->symtab,
		ctx->typelist,
		ctx->owner,
		t,
		last
	    );
	    rfre_type( t );
	}
	else {
	    tmsymbol trt = canonify_type(
		ctx->prog,
		ctx->packagename,
		ctx->owner,
		ctx->ondemands,
		&ctx->typebindings,
		first
	    );
	    if( trt != tmsymbolNIL ){
		if( showmangling ){
		    fprintf(
			stderr,
			"qualified name '%s' is a static field reference\n",
			nm->sym->name
		    );
		}
		resx = get_compiletime_constant_class_field(
		    ctx->prog,
		    ctx->symtab,
		    ctx->typelist,
		    ctx->owner,
		    trt,
		    last
		);
	    }
	    else {
		// We assume this is a reference to a field of a variable.
		if( showmangling ){
		    fprintf(
			stderr,
			"qualified name '%s' uses a variable name, so this cannot be a compiletime constant expression\n",
			nm->sym->name
		    );
		}
	    }
	}
	rfre_origsymbol( first );
	rfre_origsymbol( last );
    }
    else {
	// Not a qualified symbol.
	if( search_VarTranslation( ctx->var_translations, nm->sym, &pos ) ){
	    const_VarTranslation tr = ctx->var_translations->arr[pos];

	    if( tr->classname == tmsymbolNIL ){
		if( showmangling ){
		    fprintf(
			stderr,
			"simple name '%s' refers to local variable '%s'\n",
			nm->sym->name,
			tr->to->name
		    );
		}
		const_Entry e = lookup_Entry( ctx->symtab, tr->to );
		if( e == EntryNIL ){
		    // We're in trouble, but lookup_Entry has reported it,
		    // so leave quietly.
		    return expressionNIL;
		}
		if( has_any_flag( e->flags, ACC_COMPILECONSTANT ) ){
		    // Since this already is a known compile-time constant,
		    // return its value.
		    optexpression init = optexpressionNIL;
		    type t = typeNIL;
		    if( e->tag == TAGGlobalVariableEntry ){
		        init = to_const_GlobalVariableEntry(e)->init;
		        t = to_const_GlobalVariableEntry(e)->t;
		    }
		    else if( e->tag == TAGLocalVariableEntry ){
		        init = to_const_LocalVariableEntry(e)->init;
		        t = to_const_LocalVariableEntry(e)->t;
		    }
		    assert( init != optexpressionNIL );
		    assert( init->tag == TAGOptExpr );
		    resx = new_CastExpression(
			rdup_type( t ),
			rdup_expression( to_const_OptExpr( init )->x )
		    );
		}
		goto done;
	    }
	}
	if( !visit_type( ctx->prog, ctx->org, ctx->owner ) ){
	    internal_error( "The visit to type '%s' failed", ctx->owner->name );
	}
	resx = get_compiletime_constant_class_field(
	    ctx->prog,
	    ctx->symtab,
	    ctx->typelist,
	    ctx->owner,
	    ctx->owner,
	    nm
	);
    }
done:
    ctx->in_typeof = old_in_typeof;
    if( trace_analysis ){
	fprintf(
	    stderr,
	    "Conclusion: %s:%ld:%s is %sa compile-time constant\n",
	    nm->org->file->name,
	    (long int) nm->org->line,
	    nm->sym->name,
	    (resx==expressionNIL)?"not ":""
	);
    }
    return resx;
}

// Given an expression 'x', return a possibly rewritten expression,
// and fill '*isconstant' with a flag indicating wether the expression
// is a compile-time constant according to JLS2 15.28.
//
// Some or all variable references and field references refering to
// compile-time constants may be replaced by the corresponding constant
// value during this process. This is done to break mutual dependencies
// that may later hamper value binding.
static expression derive_compiletime_constant(
 mangle_data *ctx,
 expression x,
 bool *isconstant
)
{
    *isconstant = false;
    if( x == expressionNIL ){
	return x;
    }
    switch( x->tag ){
	case TAGByteExpression:
	case TAGShortExpression:
	case TAGIntExpression:
	case TAGLongExpression:
	case TAGFloatExpression:
	case TAGDoubleExpression:
	case TAGCharExpression:
	case TAGBooleanExpression:
	case TAGTypeExpression:
	case TAGSizeofExpression:
	case TAGStringExpression:
	    *isconstant = true;
	    break;

	case TAGNullExpression:
	    // According to the JLS null is not a compiletime constant,
	    // but that's because of implementation problems, not
	    // anything logical.
	    *isconstant = !pref_strictanalysis;
	    break;

	case TAGDefaultValueExpression:
	case TAGArrayInitExpression:
	case TAGAssignOpExpression:
	case TAGClassExpression:
	case TAGClassIdExpression:
	case TAGClassInstanceOfExpression:
	case TAGFieldInvocationExpression:
	case TAGGetLengthExpression:
	case TAGGetSizeExpression:
	case TAGGetBufExpression:
	case TAGInstanceOfExpression:
	case TAGInterfaceInstanceOfExpression:
	case TAGMethodInvocationExpression:
	case TAGNewArrayExpression:
	case TAGNewClassExpression:
	case TAGNewInitArrayExpression:
	case TAGNewRecordExpression:
	case TAGOuterSuperFieldExpression:
	case TAGOuterSuperInvocationExpression:
	case TAGPostDecrementExpression:
	case TAGPostIncrementExpression:
	case TAGPreDecrementExpression:
	case TAGPreIncrementExpression:
	case TAGSubscriptExpression:
	case TAGSuperFieldExpression:
	case TAGSuperInvocationExpression:
	case TAGTypeFieldExpression:
	case TAGOuterThisExpression:
	case TAGTypeInstanceOfExpression:
	case TAGTypeInvocationExpression:
	case TAGVectorExpression:
	case TAGVectorSubscriptExpression:
	case TAGWhereExpression:
	    *isconstant = false;
	    break;

	case TAGNotNullAssertExpression:
	{
	    NotNullAssertExpression cx = to_NotNullAssertExpression( x );
	    cx->x = derive_compiletime_constant( ctx, cx->x, isconstant );
	    break;
	}

	case TAGInternalizeExpression:
	{
	    InternalizeExpression cx = to_InternalizeExpression( x );
	    cx->x = derive_compiletime_constant( ctx, cx->x, isconstant );
	    break;
	}

	case TAGBracketExpression:
	{
	    BracketExpression cx = to_BracketExpression( x );
	    cx->x = derive_compiletime_constant( ctx, cx->x, isconstant );
	    break;
	}

	case TAGAnnotationExpression:
	{
	    AnnotationExpression cx = to_AnnotationExpression( x );
	    cx->x = derive_compiletime_constant( ctx, cx->x, isconstant );
	    break;
	}

	case TAGVariableNameExpression:
	{
	    VariableNameExpression vx = to_VariableNameExpression( x );

	    expression newx = get_compiletime_constant_var( ctx, vx->name );
	    if( newx == expressionNIL ){
		*isconstant = false;
	    }
	    else {
		*isconstant = true;
		rfre_expression( x );
		x = newx;
	    }
	    break;
	}

	case TAGFieldExpression:
	    // TODO: be more precise than this.
	    *isconstant = false;
	    break;

	case TAGForcedCastExpression:
	{
	    ForcedCastExpression vx = to_ForcedCastExpression( x );
	    vx->x = derive_compiletime_constant( ctx, vx->x, isconstant );
	    break;
	}

	case TAGCastExpression:
	{
	    CastExpression vx = to_CastExpression( x );
	    if( is_compiletime_constant_type( vx->t ) ){
		vx->x = derive_compiletime_constant( ctx, vx->x, isconstant );
	    }
	    else {
		*isconstant = false;
	    }
	    break;
	}

	case TAGComplexExpression:
	{
	    ComplexExpression cx = to_ComplexExpression( x );
	    bool isconst_re;
	    bool isconst_im;

	    cx->re = derive_compiletime_constant( ctx, cx->re, &isconst_re );
	    cx->im = derive_compiletime_constant( ctx, cx->im, &isconst_im );
	    *isconstant = isconst_re && isconst_im;
	    break;
	}

	case TAGIfExpression:
	{
	    IfExpression cx = to_IfExpression( x );
	    bool isconst_cond;
	    bool isconst_then;
	    bool isconst_else;

	    cx->cond = derive_compiletime_constant( ctx, cx->cond, &isconst_cond );
	    cx->thenval = derive_compiletime_constant( ctx, cx->thenval, &isconst_then );
	    cx->elseval = derive_compiletime_constant( ctx, cx->elseval, &isconst_else );
	    *isconstant = isconst_cond && isconst_then && isconst_else;
	    break;
	}

	case TAGUnopExpression:
	{
	    UnopExpression cx = to_UnopExpression( x );
	    cx->operand = derive_compiletime_constant( ctx, cx->operand, isconstant );
	    break;
	}

	case TAGBinopExpression:
	{
	    BinopExpression cx = to_BinopExpression( x );
	    if( is_compiletime_constant_operator( cx->optor ) ){
		bool isconst_left;
		bool isconst_right;

		cx->left = derive_compiletime_constant( ctx, cx->left, &isconst_left );
		cx->right = derive_compiletime_constant( ctx, cx->right, &isconst_right );
		*isconstant = isconst_left && isconst_right;
	    }
	    else {
		*isconstant = false;
	    }
	    break;
	}

	case TAGShortopExpression:
	{
	    bool isconst_left;
	    bool isconst_right;
	    ShortopExpression cx = to_ShortopExpression( x );

	    cx->left = derive_compiletime_constant( ctx, cx->left, &isconst_left );
	    cx->right = derive_compiletime_constant( ctx, cx->right, &isconst_right );
	    *isconstant = isconst_left && isconst_right;
	    break;
	}

    }
    return x;
}

// Given a context and an unmangled expression, return true iff it
// looks like a constant after mangling.
static bool is_constant_unmangled_expression( mangle_data *ctx, const_expression x )
{
    bool res = false;

    expression dx = derive_compiletime_constant(
	ctx,
	rdup_expression( x ),
	&res
    );
    if( !res ){
        res = is_constant( dx );
    }
    rfre_expression( dx );
    return res;
}

// Given a list of expressions, return the list of expressions if none
// of them has a side-effect, or else generate local variables for all
// of the non-constant expressions, and return a list of expressions for them.
//
// This is done to enforce left-to-right evaluation order of expressions.
static expression_list enforce_eval_order( mangle_data *ctx, expression_list xl )
{
    if( xl == expression_listNIL ){
	return expression_listNIL;
    }
    if( maybe_has_sideeffect( xl, NO_SE_ARRAY_NEW ) ){
	// Generate new locals for all expressions in the list, and
	// construct a list of these locals.

	for( unsigned int ix=0; ix<xl->sz; ix++ ){
	    expression x = xl->arr[ix];

	    if( x != expressionNIL && !is_constant_unmangled_expression( ctx, x ) ){
		xl->arr[ix] = breakout_expression( ctx, x );
	    }
	}
    }
    return xl;
}

/* Given a list of spill statements, the shape of the array to
 * initialize, and a list of initialization expressions, 
 * generate initialization statements for all array elements.
 */
static void generate_array_element_inits_slice(
    statement_list *post_spill_decls,
    statement_list *post_spill_smt,
    const_expression x,
    const_origin org,
    const_type elmtype,
    const_expression_list vec,
    const_tmuint_list shape,
    const_expression_list inits,
    unsigned int dim
)
{
    if( dim+1 == shape->sz ){
	// We're at the last dimension of the shape, so it's time
	// to generate real code.
	for( unsigned int ix=0; ix<inits->sz; ix++ ){
	    expression_list vec1 = append_expression_list(
		rdup_expression_list( vec ),
		new_IntExpression( (vnus_int) ix )
	    );
	    expression init = rdup_expression( inits->arr[ix] );
	    if( init->tag == TAGArrayInitExpression ){
		if( to_ArrayInitExpression(init)->t == typeNIL ){
		    to_ArrayInitExpression(init)->t = rdup_type( elmtype );
		}
		origsymbol s = gen_origsymbol( "ai" );
		FieldDeclaration decl = new_FieldDeclaration(
		    gen_origin(),
		    Pragma_listNIL,
		    origsymbol_listNIL,	// Labels
		    ACC_STATIC,
		    false,
		    rdup_origsymbol( s ),
		    rdup_type( elmtype ),
		    new_OptExprNone()
		);
		*post_spill_decls = append_statement_list(
		    *post_spill_decls,
		    decl
		);
		*post_spill_smt = append_statement_list(
		    *post_spill_smt,
		    new_AssignStatement(
			rdup_origin( org ),
			Pragma_listNIL,
			origsymbol_listNIL,	// Labels
			ASSIGN,
			new_VariableNameExpression( rdup_origsymbol( s ), VAR_LOCAL|VAR_GENERATED ),
			init
		    )
		);
		init = new_VariableNameExpression( s, VAR_FINAL|VAR_LOCAL|VAR_GENERATED );
	    }
	    *post_spill_smt = append_statement_list(
		*post_spill_smt,
		new_AssignStatement(
		    rdup_origin( org ),
		    Pragma_listNIL,
		    origsymbol_listNIL,	// Labels
		    ASSIGN,
		    new_SubscriptExpression(
			rdup_expression( x ),
			new_VectorExpression( vec1 )
		    ),
		    init
		)
	    );
	}
    }
    else {
	if( shape->arr[dim]>0 ){
	    for( unsigned int ix=0; ix<inits->sz; ix++ ){
		expression_list vec1 = append_expression_list(
		    rdup_expression_list( vec ),
		    new_IntExpression( (vnus_int) ix )
		);
		expression ai = inits->arr[ix];

		assert( ai->tag == TAGArrayInitExpression );
		if( dim+1<shape->sz ){
		    generate_array_element_inits_slice(
			post_spill_decls,
			post_spill_smt,
			x,
			org,
			elmtype,
			vec1,
			shape,
			to_ArrayInitExpression( ai )->elements,
			dim+1
		    );
		}
		rfre_expression_list( vec1 );
	    }
	}
    }
}

// Given a statement, return true iff this statement is inlinable.
static bool is_inlinable_statement( const_statement s )
{
    bool ok = true;

    if( pref_no_inlining ){
	return false;
    }
    switch( s->tag ){
	case TAGFieldDeclaration:
	    ok = is_trivial_initialization( to_const_FieldDeclaration(s)->init );
	    break;

	case TAGAssignStatement:
	    ok = is_trivial_initialization( to_const_AssignStatement(s)->rhs )
	      &&
		is_trivial_initialization( to_const_AssignStatement(s)->lhs );
	    break;

	case TAGValueReturnStatement:
	    ok = is_trivial_initialization( to_const_ValueReturnStatement(s)->v );
	    break;

	case TAGEmptyStatement:
	case TAGDeleteStatement:
	case TAGReturnStatement:
	    ok = true;
	    break;

	default:
	    ok = false;
	    break;
    }
    return ok;
}

// Given a list of statements that presumably form an initializer, return
// true iff the statements are trivial enough to label the function they
// live in as a macro.
static bool is_inlinable_initializer( const_statement_list sl )
{
    if(
        pref_no_inlining ||
	code_size_statement_list( sl, inlinable_codesize )>inlinable_codesize
    ){
	return false;
    }
    for( unsigned int ix=0; ix<sl->sz; ix++ ){
	if( !is_inlinable_statement( sl->arr[ix] ) ){
	     return false;
	}
    }
    return true;
}

// Given a type 't', make sure that we are allowed to access that
// type from the current context.
static void check_type_accessrights( mangle_data *ctx, const_type t )
{
    if( t == typeNIL ){
        return;
    }
    switch( t->tag ){
        case TAGPrimitiveType:
	case TAGTypeType:
	case TAGNullType:
	case TAGVoidType:
	case TAGFunctionType:
	case TAGExceptionVariableType:
	case TAGGCRefLinkType:
	case TAGGCTopRefLinkType:
	    // These types are never a problem.
	    break;

	case TAGPragmaType:
	    check_type_accessrights( ctx, to_const_PragmaType(t)->t );
	    break;

	case TAGTupleType:
	{
	    const_type_list tl = to_const_TupleType(t)->fields;

	    for( unsigned int ix=0; ix<tl->sz; ix++ ){
	        check_type_accessrights( ctx, tl->arr[ix] );
	    }
	    break;
	}

	case TAGVectorType:
	    check_type_accessrights( ctx, to_const_VectorType(t)->elmtype );
	    break;

	case TAGPrimArrayType:
	    check_type_accessrights( ctx, to_const_PrimArrayType(t)->elmtype );
	    break;

	case TAGArrayType:
	    check_type_accessrights( ctx, to_const_ArrayType(t)->elmtype );
	    break;

	case TAGTypeOf:
	    internal_error( "typeof should have been rewritten" );
	    break;

	case TAGTypeOfIf:
	    internal_error( "typeofif should have been rewritten" );
	    break;

	case TAGGenericObjectType:
	    internal_error( "generic type should have been rewritten" );
	    break;

	case TAGObjectType:
	{
	    origsymbol tnm = to_const_ObjectType(t)->name;
	    if( tnm != origsymbolNIL ){
		TypeEntry te = lookup_TypeEntry( ctx->typelist, tnm );
	        bool ok = is_valid_access( ctx->typelist, te->flags, tnm->sym, ctx->owner );
		if( !ok ){
		    origsymbol_error( tnm, "Not accessible from '%s'", ctx->owner->name );
		}

	    }
	}

    }
}

// Mangle a class field.
static FieldDeclaration mangle_classfield( FieldDeclaration dcl, mangle_data *ctx )
{
    Entry e = EntryNIL;
    origsymbol realname = rdup_origsymbol( dcl->name );

    assert( ctx->where == CTX_STATICINIT || ctx->where == CTX_DYNAMICINIT );
    if( dcl == FieldDeclarationNIL ){
        return dcl;
    }
.call generate_descent_call "    " dcl->name VariableName VariableName
    ForwardFieldEntry fe = new_ForwardFieldEntry( 
	dcl->name->sym,
	rdup_Pragma_list( dcl->pragmas ),
	dcl->flags,
	ctx->owner,
	ctx->packagename,
	false,
	rdup_origsymbol( realname ),
	rdup_type( dcl->t )
    );
    ctx->symtab = add_symtab( ctx->symtab, fe );
    register_variable_declaration( ctx, dcl->name, has_final_flag( dcl->flags ) );
.call generate_descent_call "    " dcl->pragmas Pragma_list Pragma_list
    if( !visit_type( ctx, dcl->t ) ){
        rfre_type( dcl->t );
	dcl->t = typeNIL;
	return dcl;
    }
.call generate_descent_call "    " dcl->t type type
    if( dcl->init->tag == TAGOptExpr ){
	expression init = to_OptExpr( dcl->init )->x;

	if( init->tag == TAGArrayInitExpression ){
	    AssignStatement smt = new_AssignStatement(
		rdup_origin( dcl->org ),
		Pragma_listNIL,
		origsymbol_listNIL,	// Labels
		ASSIGN,
		new_VariableNameExpression( rdup_origsymbol( realname ), 0 ),
		init
	    );
	    fre_optexpression( dcl->init );
	    dcl->init = new_OptExprNone();
	    if( has_any_flag( dcl->flags, ACC_STATIC ) ){
		// This enforces JLS2 8.1.2
		if( has_any_flag( ctx->classflags, ACC_LOCAL_OBJECT ) ){
		    origin_error( dcl->org, "An inner class may not declare static array members" );
		    rfre_statement( smt );
		}
		else {
		    ctx->static_inits = append_statement_list( ctx->static_inits, smt );
		}
	    }
	    else {
		ctx->dynamic_inits = append_statement_list( ctx->dynamic_inits, smt );
	    }
	}
    }
    if( has_any_flag( dcl->flags, ACC_FINAL ) ){
	if( dcl->init->tag == TAGOptExpr ){
	    bool isconstant = false;

	    to_OptExpr( dcl->init )->x = derive_compiletime_constant(
		ctx,
		to_OptExpr( dcl->init )->x,
		&isconstant
	    );
	    if( isconstant ){
		// This declaration is a constant as per JLS2
		dcl->flags |= ACC_COMPILECONSTANT;
		if( trace_analysis ){
		    fprintf(
			stderr,
			"Field %s is a compile-time constant\n",
			dcl->name->sym->name
		    );
		}
	    }
	}
    }
    if( dcl->init->tag == TAGOptExpr ){
	// This is a field declaration. See if there are init expressions
	// that must be shoved into an initialization function.
	expression init = to_OptExpr( dcl->init )->x;

	// We must break out initializers of fields that are not
	// compile-time constants. 
	// TODO: for static fields we only have to break out of the
	// variable is not a constant, which is a lighter restriction.
	if(
	    has_any_flag( dcl->flags, ACC_COMPILECONSTANT ) ||
	    (
		has_any_flag( dcl->flags, ACC_STATIC ) &&
		is_compiletime_constant( init, origsymbol_listNIL )
	    )
	){
	}
	else {
	    fre_optexpression( dcl->init );
	    dcl->init = new_OptExprNone();
	    statement smt = new_AssignStatement(
		rdup_origin( dcl->org ),
		Pragma_listNIL,
		origsymbol_listNIL,	// Labels
		ASSIGN,
		new_VariableNameExpression(
		    rdup_origsymbol( realname ),
		    has_any_flag( dcl->flags, ACC_STATIC )?VAR_STATFIELD:VAR_DYNFIELD
		),
		init
	    );
	    if( has_any_flag( dcl->flags, ACC_STATIC ) ){
		ctx->static_inits = append_statement_list(
		    ctx->static_inits,
		    smt
		);
	    }
	    else {
		ctx->dynamic_inits = append_statement_list(
		    ctx->dynamic_inits,
		    smt
		);
	    }
	}
    }
    if(
        has_any_flag( ctx->classflags, ACC_INNER_CLASS ) &&
        has_any_flag( dcl->flags, ACC_STATIC )
    ){
	// This enforces a rule in JLS2 8.1.2:
	// Inner classes may not declare static members, unless they are
	// compile-time constant fields.
	if( !has_any_flag( dcl->flags, ACC_COMPILECONSTANT ) ){
	    // This enforces a rule in JLS2 8.1.2
	    origsymbol_error( realname, "An inner class may not declare static members, unless they are compile-time constant fields" );
	}
    }
.call generate_descent_call "    " dcl->init optexpression optexpression
    if( dcl->init->tag == TAGOptExpr ){
	OptExpr init = to_OptExpr( dcl->init );

	if( !is_vnusstring_type( dcl->t ) ){
	    type it = derive_type_expression( ctx->symtab, init->x );

	    if( is_vnusstring_type( it ) ){
		init->x = internalize_Vnus_string( ctx, init->x );
	    }
	    rfre_type( it );
	}
    }
    if( has_any_flag( dcl->flags, ACC_STATIC ) ){
	e = new_GlobalVariableEntry(
	    dcl->name->sym,
	    rdup_Pragma_list( dcl->pragmas ),
	    dcl->flags,
	    ctx->owner,
	    ctx->packagename,
	    false,
	    realname,
	    rdup_type( dcl->t ),
	    rdup_optexpression( dcl->init )
	);
    }
    else {
	e = new_FieldEntry(
	    dcl->name->sym,
	    rdup_Pragma_list( dcl->pragmas ),
	    dcl->flags,
	    ctx->owner,
	    ctx->packagename,
	    false,
	    realname,
	    rdup_type( dcl->t ),
	    rdup_optexpression( dcl->init )
	);
    }
    ctx->symtab = add_symtab( ctx->symtab, e );
    if( visit_type( ctx, dcl->t ) ){
	check_type_accessrights( ctx, dcl->t );
    }
    else {
        rfre_type( dcl->t );
	dcl->t = typeNIL;
    }
    return dcl;
}

static statement build_delete_statement( tmsymbol nm )
{
    return new_DeleteStatement(
	originNIL,
	Pragma_listNIL,
	origsymbol_listNIL,
	new_VariableNameExpression( new_origsymbol( nm, originNIL ), 0 )
    );
}

static statement build_delete_statement( const_origin org, const_expression x )
{
    return new_DeleteStatement(
	rdup_origin( org ),
	Pragma_listNIL,
	origsymbol_listNIL,
	rdup_expression( x )
    );
}

static tmsymbol_list collect_deletables( mangle_data *ctx )
{
    tmsymbol_list res = new_tmsymbol_list();
    ProgramState_list states = ctx->states;

    for( unsigned int six=0; six<states->sz; six++ ){
        ProgramState st = states->arr[six];
	VarState_list varstates = st->varStates;

	for( unsigned int vix=0; vix<varstates->sz; vix++ ){
	    VarState vst = varstates->arr[vix];

	    if( is_deletable_variable( ctx, vst ) ){
	        res = add_tmsymbol_list( res, vst->name );
	    }
	    else {
		// This is not a deletable variable. Remove it from the
		// list if necessary.
		unsigned int pos;

		if( search_tmsymbol_list( res, vst->name, &pos ) ){
		    res = delete_tmsymbol_list( res, pos );
		}
	    }
	}
    }
    return res;
}

static statement_list build_all_deletes( mangle_data *ctx )
{
    tmsymbol_list dl = collect_deletables( ctx );
    statement_list res = setroom_statement_list( new_statement_list(), dl->sz );

    for( unsigned int ix=0; ix<dl->sz; ix++ ){
	tmsymbol var = dl->arr[ix];
	const_VariableEntry e = lookup_VariableEntry( ctx->symtab, var );
	if( e->tag == TAGLocalVariableEntry ){
	    res = append_statement_list(
		res,
		build_delete_statement( var )
	    );
	}
    }
    rfre_tmsymbol_list( dl );
    return res;
}

static void enforce_deletables( mangle_data *ctx )
{
    statement_list sl = build_all_deletes( ctx );
    ctx->mangled_pre_spill_smts = concat_statement_list(
	ctx->mangled_pre_spill_smts,
	sl
    );
}

// All variables with a VarTranslation higher than 'level' now go
// out of scope. If any of these variables is deletable, we may
// as well delete it at this point.
static statement_list implement_locals_delete( mangle_data *ctx, statement_list sl, int level )
{
    if( completes_abruptly( ctx ) ){
	// Since any deletes we would generate couldn't be reached
	// anyway, we shouldn't generate them.
        return sl;
    }
    VarTranslation_list l = ctx->var_translations;
    for( unsigned int ix=0; ix<l->sz; ix++ ){
	VarTranslation tr = l->arr[ix];

	if( tr->level>level ){
	    tmsymbol nm = tr->to;

	    if( is_deletable_variable( ctx, nm ) ){
		if( trace_analysis ){
		    fprintf( stderr, "Variable '%s' at translation level %d can be __delete-ed\n", nm->name, tr->level );
		}
		sl = append_statement_list(
		    sl,
		    build_delete_statement( nm )
		);
	    }
	    else {
		if( trace_analysis ){
		    fprintf( stderr, "Variable '%s' at translation level %d can not be deleted\n", nm->name, tr->level );
		}
	    }
	}
    }
    return sl;
}

// Given the current analysis state and the lists of formal explicit
// and this parameters, return a list of formal parameters that does
// not escape the method.
static tmsymbol_list collect_noescape(
 tmsymbol_list el,
 const_ProgramState_list states,
 const_FormalParameter parm
)
{
    tmsymbol nm = parm->name->sym;

    if( !is_escaping_variable( states, nm ) ){
        el = append_tmsymbol_list( el, nm );
    }
    return el;
}

// Given the current analysis state and the lists of formal explicit
// and this parameters, return a list of formal parameters that does
// not escape the method.
static tmsymbol_list collect_noescapes(
 const_ProgramState_list states,
 const_FormalParameter_list parms,
 const_FormalParameter_list this_parms
)
{
     tmsymbol_list el = new_tmsymbol_list();

     for( unsigned int iy=0; iy<parms->sz; iy++ ){
         el = collect_noescape( el, states, parms->arr[iy] );
     }
     for( unsigned int ix=0; ix<this_parms->sz; ix++ ){
         el = collect_noescape( el, states, this_parms->arr[ix] );
     }
     return el;
}

// Given a list of unescaped formal parameters, build a pragma
// that list them. Iff there are none, return PragmaNIL.
static Pragma build_noescapes_pragma( const_tmsymbol_list noescapes )
{
    if( noescapes == tmsymbol_listNIL || noescapes->sz == 0 ){
        return PragmaNIL;
    }
    PragmaExpression_list pl = new_PragmaExpression_list();

    for( unsigned int ix=0; ix<noescapes->sz; ix++ ){
        PragmaExpression px = new_ExternalNamePragmaExpression(
	    add_origsymbol( noescapes->arr[ix] )
	);
	pl = append_PragmaExpression_list( pl, px );
    }
    return new_ValuePragma(
        add_origsymbol( "noescapes" ),
	new_ListPragmaExpression( pl )
    );
}

/* -------- actors ---------- */

// Given an ArrayInitExpression, rewrite it.
//
// The array init expression '{ e1, e2,  ... en }' is rewritten to
//
// int[] tmp;
// 
// tmp = new <type>[n];
// tmp[0] = e1;
// tmp[1] = e2;
//  :
// tmp[n-1] = en;
// 
// ... tmp ...
//
// That is, the initialization expression is rewritten to the declaration
// of a new array variable, followed by initialization statements.
static expression mangle_ArrayInitExpression_action(
    ArrayInitExpression elm,
    mangle_data *ctx
)
{
    (void) mangle_ArrayInitExpression_walker;
    type t = elm->t;

    assert( t != typeNIL );
    if( t->tag != TAGArrayType ){
	tmstring tnm = typename_type( t );
	origin_error( ctx->org, "You can only initialize an array, not a %s", tnm );
	rfre_tmstring( tnm );
	return elm;
        
    }
    origsymbol s = gen_origsymbol( "arr" );
    FieldDeclaration d = new_FieldDeclaration(
	gen_origin(),
	Pragma_listNIL,
	origsymbol_listNIL,	// Labels
	ACC_STATIC|ACC_FINAL,
	false,
	rdup_origsymbol( s ),
	rdup_type( elm->t ),
	new_OptExprNone()
    );
.call generate_descent_call "    " d FieldDeclaration FieldDeclaration
    ctx->breakout_declarations = append_statement_list( ctx->breakout_declarations, d );
    expression_list elms = elm->elements;
    const_ArrayType at = to_const_ArrayType( t );
    const_expression rankexpr = at->rank;
    unsigned int rank;

    if( !extract_array_rank( ctx->org, rankexpr, &rank ) ){
	rank = 0;
    }
    tmuint_list shape = setroom_tmuint_list( new_tmuint_list(), rank );
    for( unsigned int ix=0; ix<rank; ix++ ){
	shape = append_tmuint_list( shape, 0 );
    }
    shape = calculate_array_shape( ctx->org, elms, shape, 0, rank );

    // Construct the statement
    //  arr = new <type>[shape];
    NewArrayExpression init = new_NewArrayExpression(
	rdup_type( at->elmtype ),
	append_ActualDim_list(
	    new_ActualDim_list(),
	    build_ActualDim( shape )
	),
	new_OptExprNone()		// Will be overwritten anyway
    );
    AssignStatement smt = new_AssignStatement(
        gen_origin(),
	Pragma_listNIL,
	new_origsymbol_list(),
	ASSIGN,
	new_VariableNameExpression( rdup_origsymbol( s ), VAR_LOCAL|VAR_GENERATED ),
	init
    );
.call generate_descent_call "    " smt AssignStatement AssignStatement
    ctx->mangled_pre_spill_smts = append_statement_list(
	ctx->mangled_pre_spill_smts,
	smt
    );

    // Now generate assignments for the individual array elements.
    expression_list vec = new_expression_list();

    if( shape->sz != 0 ){
	statement_list postspills = new_statement_list();
	statement_list postdecls = new_statement_list();
	expression arr = new_VariableNameExpression( rdup_origsymbol( s ), VAR_LOCAL|VAR_GENERATED );

	generate_array_element_inits_slice(
	    &postdecls,
	    &postspills,
	    arr,
	    ctx->org,
	    at->elmtype,
	    vec,
	    shape,
	    elms,
	    0
	);
	rfre_expression( arr );
.call generate_descent_call "	" postdecls statement_list statement_list
	ctx->breakout_declarations = concat_statement_list( ctx->breakout_declarations, postdecls );
.call generate_descent_call "	" postspills statement_list statement_list
	ctx->mangled_pre_spill_smts = concat_statement_list( ctx->mangled_pre_spill_smts, postspills );
    }
    rfre_expression_list( vec );
    rfre_tmuint_list( shape );

    rfre_expression( elm );
    VariableNameExpression res = new_VariableNameExpression( s, VAR_FINAL|VAR_LOCAL|VAR_GENERATED );
.call generate_walker_call "    " res VariableNameExpression VariableNameExpression
    return res;
}

// Given an NewInitArrayExpression, rewrite it.
//
// The expression '... new int[] { ... } ...' is rewritten to
//
// int[] x;
// :
// x = { ... };
// ... x ...
//
// That is, the initialization expression is rewritten to the declaration
// of a new initialized array variable, and the expression is replaced
// by a reference to the new variable.
static expression mangle_NewInitArrayExpression_action(
    NewInitArrayExpression elm,
    mangle_data *ctx
)
{
    (void) mangle_NewInitArrayExpression_walker;
    origsymbol s = gen_origsymbol( "arr" );
    FieldDeclaration d = new_FieldDeclaration(
	gen_origin(),
	Pragma_listNIL,
	origsymbol_listNIL,	// Labels
	ACC_STATIC|ACC_FINAL,
	false,
	rdup_origsymbol( s ),
	elm->t,
	new_OptExprNone()
    );
    assert( elm->init->tag == TAGArrayInitExpression );
    to_ArrayInitExpression(elm->init)->t = rdup_type( elm->t );
.call generate_descent_call "    " d FieldDeclaration FieldDeclaration
    ctx->breakout_declarations = append_statement_list( ctx->breakout_declarations, d );
    AssignStatement smt = new_AssignStatement(
        gen_origin(),
	Pragma_listNIL,
	new_origsymbol_list(),
	ASSIGN,
	new_VariableNameExpression( rdup_origsymbol( s ), VAR_LOCAL|VAR_GENERATED ),
	elm->init
    );
.call generate_descent_call "    " smt AssignStatement AssignStatement
    ctx->mangled_pre_spill_smts = append_statement_list(
	ctx->mangled_pre_spill_smts,
	smt
    );
    check_type_accessrights( ctx, elm->t );
    fre_expression( elm );
    VariableNameExpression res = new_VariableNameExpression( s, VAR_FINAL|VAR_LOCAL|VAR_GENERATED );
.call generate_walker_call "    " res VariableNameExpression VariableNameExpression
    return res;
}

// Action for type 'StaticInitializer'.
static StaticInitializer mangle_StaticInitializer_action( StaticInitializer init, mangle_data *ctx )
{
    if( init == StaticInitializerNIL ){
	return StaticInitializerNIL;
    }
    context oldwhere = ctx->where;

    (void) mangle_StaticInitializer_walker;
    ctx->where = CTX_STATICROUTINE;
    // This enforces JLS2 8.1.2
    if( has_any_flag( ctx->classflags, ACC_LOCAL_OBJECT ) ){
	origin_error( init->org, "Static initializer not allowed in local class" );
	return init;
    }
    if( init->body->statements->sz != 0 ){
	// The static initializer does in fact contain something.
	ctx->static_inits = append_statement_list(
	    ctx->static_inits,
	    new_BlockStatement(
		rdup_origin( init->org ),
		Pragma_listNIL,
		origsymbol_listNIL,	// Labels
		init->body
	    )
	);
	init->body = BlockNIL;
    }
    ctx->where = oldwhere;
    return init;
}

// Action for type 'InstanceInitializer'.
static InstanceInitializer mangle_InstanceInitializer_action( InstanceInitializer init, mangle_data *ctx )
{
    context oldwhere = ctx->where;

    if( init == InstanceInitializerNIL ){
	return InstanceInitializerNIL;
    }
    ctx->where = CTX_DYNAMICROUTINE;
    (void) mangle_InstanceInitializer_walker;
..call generate_walker_call "    " init InstanceInitializer InstanceInitializer
    if( init->body->statements->sz != 0 ){
	// The static initializer does in fact contain something.
	ctx->dynamic_inits = append_statement_list(
	    ctx->dynamic_inits,
	    new_BlockStatement(
		rdup_origin( init->org ),
		Pragma_listNIL,
		origsymbol_listNIL,	// Labels
		init->body
	    )
	);
	init->body = BlockNIL;
    }
    ctx->where = oldwhere;
    return init;
}

// Action for type 'CastExpression'.
static expression mangle_CastExpression_action( CastExpression x, mangle_data *ctx )
{
.call generate_walker_call "    " x CastExpression CastExpression
    if( is_String_type( x->t ) ){
	type tx = derive_type_expression( ctx->symtab, x->x );

	if( is_vnusstring_type( tx ) ){
	    // This casts a vnusstring to a String. Since that's
	    // just a string internalization, we may as well generate
	    // the right code for it.
	    expression res = internalize_Vnus_string( ctx, x->x );
	    x->x = expressionNIL;
	    rfre_expression( x );
	    rfre_type( tx );
	    return res;
	}
	rfre_type( tx );
    }
    return x;
}

// Action for type 'expression_list'.
static expression_list mangle_expression_list_action( expression_list xl, mangle_data *ctx )
{
    if( xl == expression_listNIL ){
	return xl;
    }
    xl = enforce_eval_order( ctx, xl );
.call generate_walker_call "    " xl expression_list expression_list
    return xl;
}

/* Given an PostIncrementExpression, e.g.
 *   .. i++ ..
 * lower it to:
 *   typeof(i) inc;	// Shoved somewhere else.
 *    :
 *   inc = i;
 *   i += 1;
 *       .. inc ..
 *
 * and call lower again.
 */
static expression mangle_PostIncrementExpression_action(
    PostIncrementExpression elm,
    mangle_data *ctx
)
{
    if( ctx->in_typeof ){
.call generate_walker_call "	" elm PostIncrementExpression PostIncrementExpression
	return elm;
    }
    origsymbol s = gen_origsymbol( "inc" );
    FieldDeclaration d = new_FieldDeclaration(
	rdup_origin( ctx->org ),
	Pragma_listNIL,
	origsymbol_listNIL,	// Labels
	0,
	false,
	rdup_origsymbol( s ),
	new_TypeOf( rdup_expression( elm->x ) ),
	new_OptExprNone()
    );
.call generate_descent_call "    " d FieldDeclaration FieldDeclaration
    ctx->breakout_declarations = append_statement_list( ctx->breakout_declarations, d );
    AssignStatement smt = new_AssignStatement(
        gen_origin(),
	Pragma_listNIL,
	new_origsymbol_list(),
	ASSIGN,
	new_VariableNameExpression( rdup_origsymbol( s ), VAR_LOCAL|VAR_GENERATED ),
	rdup_expression( elm->x )
    );
.call generate_descent_call "    " smt AssignStatement AssignStatement
    ctx->mangled_pre_spill_smts = append_statement_list(
	ctx->mangled_pre_spill_smts,
	smt
    );
    AssignStatement incsmt = new_AssignStatement(
	rdup_origin( ctx->org ),
	Pragma_listNIL,
	origsymbol_listNIL,	// Labels
	ASSIGN_PLUS,
	elm->x,
	new_IntExpression( 1 )
    );
.call generate_descent_call "    " incsmt AssignStatement AssignStatement
    ctx->mangled_pre_spill_smts = append_statement_list(
	ctx->mangled_pre_spill_smts,
	incsmt
    );
    fre_expression( elm );
    VariableNameExpression res = new_VariableNameExpression( s, VAR_FINAL|VAR_LOCAL|VAR_GENERATED );
.call generate_descent_call "    " res VariableNameExpression VariableNameExpression
    return res;
}

/* Given an PostDecrementExpression,  e.g.
 *   .. i-- ..
 * lower it to:
 *   typeof(i) dec;	// Shoved somewhere else.
 *    :
 *   dec = i;
 *   i -= 1;
 *       .. dec ..
 *
 * and call lower again.
 */
static expression mangle_PostDecrementExpression_action(
    PostDecrementExpression elm,
    mangle_data *ctx
)
{
    if( ctx->in_typeof ){
.call generate_walker_call "	" elm PostDecrementExpression PostDecrementExpression
	return elm;
    }
    origsymbol s = gen_origsymbol( "dec" );
    FieldDeclaration d = new_FieldDeclaration(
	rdup_origin( ctx->org ),
	Pragma_listNIL,
	origsymbol_listNIL,	// Labels
	0,
	false,
	rdup_origsymbol( s ),
	new_TypeOf( rdup_expression( elm->x ) ),
	new_OptExprNone()
    );
.call generate_descent_call "    " d FieldDeclaration FieldDeclaration
    ctx->breakout_declarations = append_statement_list( ctx->breakout_declarations, d );
    AssignStatement smt = new_AssignStatement(
        gen_origin(),
	Pragma_listNIL,
	new_origsymbol_list(),
	ASSIGN,
	new_VariableNameExpression( rdup_origsymbol( s ), VAR_LOCAL|VAR_GENERATED ),
	rdup_expression( elm->x )
    );
.call generate_descent_call "    " smt AssignStatement AssignStatement
    ctx->mangled_pre_spill_smts = append_statement_list(
	ctx->mangled_pre_spill_smts,
	smt
    );
    AssignStatement decsmt = new_AssignStatement(
	rdup_origin( ctx->org ),
	Pragma_listNIL,
	origsymbol_listNIL,	// Labels
	ASSIGN_MINUS,
	elm->x,
	new_IntExpression( 1 )
    );
.call generate_descent_call "    " decsmt AssignStatement AssignStatement
    ctx->mangled_pre_spill_smts = append_statement_list(
	ctx->mangled_pre_spill_smts,
	decsmt
    );
    fre_expression( elm );
    VariableNameExpression res = new_VariableNameExpression( s, VAR_FINAL|VAR_LOCAL|VAR_GENERATED );
.call generate_descent_call "    " res VariableNameExpression VariableNameExpression
    return res;
}

/* Given an AssignOpExpression, lower it to factor out side-effects. */
static expression mangle_AssignOpExpression_action(
    AssignOpExpression elm,
    mangle_data *ctx
)
{
    expression res;

    if( ctx->in_typeof ){
.call generate_descent_call "	" elm->left expression expression
.call generate_descent_call "	" elm->right expression expression
	res = elm;
    }
    else {
	AssignStatement smt = transmog_AssignmentExpression( elm, ctx->org );
	(void) mangle_AssignOpExpression_walker;
	if(
	    (smt->op == ASSIGN && smt->rhs->tag == TAGBooleanExpression) ||
	    (smt->op == ASSIGN_AND && is_false_constant( smt->rhs )) ||
	    (smt->op == ASSIGN_OR && is_true_constant( smt->rhs ))
	){
	    // Since this is a constant expression, propagate that,
	    // instead of the variable that is assigned here.
	    res = rdup_expression( smt->rhs );
	}
	else {
	    res = rdup_expression( smt->lhs );
	}
.call generate_descent_call "	" smt AssignStatement AssignStatement
	ctx->mangled_pre_spill_smts = append_statement_list( ctx->mangled_pre_spill_smts, smt );
.call generate_descent_call "	" res expression expression
    }
    return res;
}


// Mangle a block.
static Block mangle_Block_action( Block blk, mangle_data *ctx )
{
    if( blk == BlockNIL ){
	return blk;
    }

    int oldlevel = ctx->scopelevel++;
    tmsymbol *oldscope = ctx->scopeptr;
    statement_list old_breakout_declarations = ctx->breakout_declarations;
    ctx->breakout_declarations = new_statement_list();

    ctx->scopeptr = &blk->scope;
    TypeBinding_list old_typebindings = ctx->typebindings;
    ctx->typebindings = rdup_TypeBinding_list( ctx->typebindings );
.call generate_walker_call "    " blk Block Block
    blk->statements = concat_statement_list(
	ctx->breakout_declarations,
	blk->statements
    );
    rfre_TypeBinding_list( ctx->typebindings );
    ctx->typebindings = old_typebindings;
    blk->statements = implement_locals_delete( ctx, blk->statements, oldlevel );
    delete_scopelevels( ctx, oldlevel );
    ctx->scopeptr = oldscope;
    ctx->breakout_declarations = old_breakout_declarations;
    return blk;
}

/* Mangle an 'instanceof' expression. */
static expression mangle_InstanceOfExpression_action( InstanceOfExpression x, mangle_data *ctx )
{
    if( !visit_type( ctx, x->t ) ){
        rfre_expression( x );
	return expressionNIL;
    }
    if( maybe_has_sideeffect( x->x, NO_SE_EXCEPTION|NO_SE_NULLPOINTER|NO_SE_CLASSINIT ) ){
	// Must break out this statement, since in the code generation of
	// instanceof we will generate the same expression twice.
	x->x = breakout_expression( ctx, x->x );
    }
.call generate_walker_call "    " x InstanceOfExpression InstanceOfExpression
    expression res = x;
    type tx = derive_type_expression( ctx->symtab, x->x );
    if( is_ReferenceType(x->t) != is_ReferenceType( tx ) ){
	rfre_expression( x );
	res = new_BooleanExpression( false );
    }
    else if( is_ReferenceType(x->t) ){
	if( !pref_strictanalysis ){
	    if( !is_valid_cast( ctx->symtab, ctx->typelist, tx, x->t ) ){
		rfre_expression( x );
		res =  new_BooleanExpression( false );
	    }
	    else {
		if( is_subclass( ctx->typelist, tx, x->t ) ){
		    rfre_expression( x );
		    res =  new_BooleanExpression( true );
		}
	    }
	}
    }
    else {
	// We should be able to resolve that right now, since we can
	// derive the type of the expression.
	bool val = is_identity_conv_type( ctx->symtab, tx, x->t );
	rfre_expression( x );
	return new_BooleanExpression( val );
    }
    rfre_type( tx );
    return res;
}

// Mangle a 'delete' statement.
static DeleteStatement mangle_DeleteStatement_action( DeleteStatement smt, mangle_data *ctx )
{
.call generate_walker_call "    " smt DeleteStatement DeleteStatement
    register_escapes( ctx, smt->adr, "deleted" );
    return smt;
}

/* Mangle a '<type> instanceof' expression. */
static expression mangle_TypeInstanceOfExpression_action( TypeInstanceOfExpression x, mangle_data *ctx )
{

    if(
	!visit_type( ctx, x->left ) ||
	!visit_type( ctx, x->right )
    ){
        rfre_expression( x );
	return expressionNIL;
    }

.call generate_walker_call "    " x TypeInstanceOfExpression TypeInstanceOfExpression
    bool val = is_identity_conv_type( ctx->symtab, x->left, x->right );
    if( !val && is_ReferenceType(x->left) ){
	val = is_subclass( ctx->typelist, x->left, x->right );
    }
    rfre_expression( x );
    return new_BooleanExpression( val );
}

/* Mangle a 'where' expression. */
static WhereExpression mangle_WhereExpression_action( WhereExpression x, mangle_data *ctx )
{
    int oldlevel = ctx->scopelevel;
    tmsymbol *oldscope = ctx->scopeptr;

    if( x == WhereExpressionNIL ){
	return x;
    }
    ctx->scopeptr = &x->scope;
    origsymbol_list locals = new_origsymbol_list();
    locals = collect_vardeclaration_names( locals, x->defs );
    if( check_double_symbols( "local variable", locals ) ){
	build_local_translations( ctx, locals );
.call generate_walker_call "        " x WhereExpression WhereExpression
	delete_scopelevels( ctx, oldlevel );
    }
    rfre_origsymbol_list( locals );
    ctx->scopeptr = oldscope;
    return x;
}

// Given a tuple type 'vt' and a subscript expression 'x', return a
// TupleExpression where each element of the vector 'x' is explicitly
// addressed.
static VectorExpression build_TupleType_subscript(
    TupleType tt,
    expression x
)
{
    unsigned int sz = tt->fields->sz;
    expression_list xl = setroom_expression_list( new_expression_list(), sz );

    for( unsigned int ix=0; ix<sz; ix++ ){
	xl = append_expression_list(
	    xl,
	    new_VectorSubscriptExpression( rdup_expression( x ), ix )
	);
    }
    return new_VectorExpression( xl );
}

static expression mangle_FieldInvocationExpression_action(
 FieldInvocationExpression x,
 mangle_data *ctx
)
{
    if( x == FieldInvocationExpressionNIL ){
	return x;
    }
    expression_list this_parameters = new_expression_list();
    bool use_static_call;
    expression res;

    if( maybe_has_sideeffect( x->var, NO_SE_ARRAY_NEW ) ){
	x->var = breakout_expression( ctx, x->var );
    }
.call generate_walker_call "    " x FieldInvocationExpression FieldInvocationExpression
    expression_list parameters = rdup_expression_list( x->parameters );
    MethodEntry me = bind_expression_method(
	ctx,
	x->var,
	x->field,
	&this_parameters,
	&use_static_call,
	&parameters
    );
    if( me == MethodEntryNIL ){
	rfre_expression( x );
	rfre_expression_list( parameters );
	rfre_expression_list( this_parameters );
	return expressionNIL;
    }
    if( is_special_method( me ) ){
	res = construct_special_method_expression(
	    ctx,
	    me,
	    this_parameters,
	    parameters
	);
	rfre_expression_list( this_parameters );
	rfre_expression_list( parameters );
    }
    else {
	register_actual_escapes( ctx, me, parameters, this_parameters );
	register_method_throws( ctx->states, me->throws );
	if(
	    me->tag == TAGFunctionEntry &&
	    ctx->expand_inlines &&
	    use_static_call &&
	    has_flags( me->flags, ACC_INLINE )
	){
	    this_parameters = build_notnullassert( ctx, this_parameters );
	    res = expand_inlined_expression(
		ctx,
		me,
		ctx->org,
		this_parameters,
		parameters,
		false
	    );
	    rfre_expression_list( this_parameters );
	    rfre_expression_list( parameters );
	}
	else {
	    expression vtab = expressionNIL;

	    if( !use_static_call ){
		vtab = build_notnullassert( ctx, rdup_expression( x->var ) );
	    }
	    else {
		this_parameters = build_notnullassert( ctx, this_parameters );
	    }
	    res = new_MethodInvocationExpression(
		new_MethodInvocation(
		    vtab,
		    new_origsymbol( me->name, rdup_origin( x->field->org ) ),
		    this_parameters,
		    parameters,
		    0
		)
	    );
	}
    }
    rfre_expression( x );
    return res;
}

// Action for a SubscriptExpression.
// Given an SubscriptExpression, lower it to factor out side-effects.
// According to JLS2 15.13.2, in the subscript expression a[b] it must
// be ensured that 'a' is evaluated before 'b' (as long as it matters).
static expression mangle_SubscriptExpression_action( SubscriptExpression x, mangle_data *ctx )
{
    expression res = x;

    // TODO: have a better look at the conditions for breakout.
    // Note that we shouldn't breakout tuple subscripts. Luckily these
    // are always constant, so the second clause takes care of them.
    if(
        maybe_has_sideeffect( x->array, NO_SE_ARRAY_NEW ) &&
	!is_constant_unmangled_expression( ctx, x->subscripts ) &&
        maybe_has_sideeffect( x->subscripts, 0 )
    ){
	x->array = breakout_expression( ctx, x->array );
    }
    // TODO: have a better look at the conditions for breakout.
    if( x->subscripts->tag != TAGVectorExpression && x->subscripts->tag != TAGVariableNameExpression ){
	x->subscripts = breakout_expression( ctx, x->subscripts );
    }
    // If 'a' is a class that implements spar.lang.Array, rewrite
    // this to a.getElement( v, x );
    {
	expression array = rdup_expression( x->array );

	bool old_in_typeof = ctx->in_typeof;
	ctx->in_typeof = true;
.call generate_walker_call "	" array expression expression
	ctx->in_typeof = old_in_typeof;
	type tarray = derive_type_expression( ctx->symtab, array );
	rfre_expression( array );
	if( tarray != typeNIL && tarray->tag == TAGObjectType ){
	    // Yes, this should be transformed to a getElement call.
	    rfre_type( tarray );

	    expression call = new_FieldInvocationExpression(
		x->array,
		add_origsymbol( "getElement" ),
		append_expression_list(
		    new_expression_list(),
		    x->subscripts
		)
	    );
	    x->array = expressionNIL;
	    x->subscripts = expressionNIL;
	    rfre_expression( x );
.call generate_descent_call "	    " call FieldInvocationExpression expression
	    return call;
	}
	rfre_type( tarray );
    }
.call generate_walker_call "    " x SubscriptExpression SubscriptExpression
    type t = derive_type_expression( ctx->symtab, x->array );
    if( t == typeNIL ){
	return x;
    }
    type ct = clean_type( t );
    if( ct->tag == TAGVectorType || ct->tag == TAGTupleType ){
	expression subscripts = x->subscripts;

	if( subscripts->tag != TAGVectorExpression ){
	    origin_error( ctx->org, "The subscript of a vector should be an explicit vector" );
	    return x;
	}
	expression_list sl = to_VectorExpression(subscripts)->fields;
	if( sl->sz != 1 ){
	    origin_error( ctx->org, "The subscript of a vector should be a vector of length 1" );
	    return x;
	}
	expression sx = sl->arr[0];

	if( sx->tag != TAGIntExpression ){
	    if( is_LiteralExpression(x) ){
		origin_error( ctx->org, "The subscript of a vector should be of type int" );
	    }
	    else {
		origin_error( ctx->org, "The subscript of a vector should be a constant" );
	    }
	    return x;
	}
	vnus_int sz = to_IntExpression( sx )->v;
	if( sz<0 ){
	    origin_error( ctx->org, "The index of a vector cannot have a negative value" );
	    return x;
	}
	unsigned int len = 0;

	if( ct->tag == TAGVectorType ){
	    if( !extract_vector_power( ctx->org, to_VectorType(ct)->power, &len ) ){
		return x;
	    }
	}
	else if( ct->tag == TAGTupleType ){
	    len = to_TupleType(ct)->fields->sz;
	}
	else {
	    origin_error( ctx->org, "Unreasonably large vector index" );
	    len = 10000;
	}
	if( (unsigned int) sz>= len ){
	    sprintf( errarg, "there are only %u elements, no element %u", len, sz );
	    origin_error( ctx->org, "vector index too large" );
	}
	else {
	    res = new_VectorSubscriptExpression(
		x->array,
		(unsigned int) sz
	    );
	    x->array = expressionNIL;
	    rfre_expression( x );
	}
    }
    else {
	expression subscripts = x->subscripts;
	x->array = build_notnullassert( ctx, x->array );

	if(
	    subscripts->tag != TAGVectorExpression &&
	    subscripts->tag != TAGVariableNameExpression
	){
	    // Write out the vector expression into an explicit vector
	    // that subscripts each individual element.
	    // We assume here that 'subscripts' has no side-effects.
	    type st = derive_type_expression( ctx->symtab, subscripts );
	    switch( st->tag ){
		case TAGVectorType:
		    x->subscripts = build_VectorType_subscript(
			ctx->org,
			to_VectorType(st),
			subscripts
		    );
		    rfre_expression( subscripts );
		    break;

		case TAGTupleType:
		    x->subscripts = build_TupleType_subscript(
			to_TupleType(st),
			subscripts
		    );
		    rfre_expression( subscripts );
		    break;

		default:
		    // This is wrong, but we leave it to the type checker.
		    break;
	    }
	    rfre_type( st );
	}
    }
    rfre_type( t );
    return res;
}

/* Action for a GenericObjectType. */
static ReferenceType mangle_GenericObjectType_action(
 GenericObjectType t,
 mangle_data *ctx
)
{
.call generate_walker_call "    " t GenericObjectType GenericObjectType
    ObjectType res = bind_GenericObjectType( ctx, t );
    rfre_type( t );
    return res;
}

/* Given an NewClassExpression, rewrite it to a NewRecord expression and a
 * method invocation.
 */
static expression mangle_NewClassExpression_action(
    NewClassExpression elm,
    mangle_data *ctx
)
{
    (void) mangle_NewClassExpression_walker;

    if( elm == NewClassExpressionNIL ){
	return NewClassExpressionNIL;
    }
    if( !ctx->in_typeof && elm->outer != expressionNIL ){
	expression outer = rdup_expression( elm->outer );
	bool old_in_typeof = ctx->in_typeof;

	ctx->in_typeof = true;
.call generate_descent_call "	" outer expression expression
	ctx->in_typeof = old_in_typeof;
        type t_out = derive_type_expression( ctx->symtab, outer );
	rfre_expression( outer );
	if( t_out != typeNIL ){
	    if( t_out->tag == TAGGenericObjectType ){
		origin_internal_error( ctx->org, "Generic object type should have been rewritten" );
	    }
	    if( t_out->tag != TAGObjectType ){
		tmstring cl_tnm = typename_type( t_out );
		origin_error( ctx->org, "Only a class can serve as outer class, not a %s", cl_tnm );
		rfre_tmstring( cl_tnm );
		rfre_expression( elm );
		rfre_type( t_out );
		return expressionNIL;
	    }
	    if( elm->cl->tag == TAGObjectType ){
		tmsymbol outnm = to_ObjectType(t_out)->name->sym;
		tmsymbol tnm = to_ObjectType(elm->cl)->name->sym;
		to_ObjectType(elm->cl)->name->sym = qualify_tmsymbol(
		    outnm,
		    tnm
		);
	    }
	    rfre_type( t_out );
	}
    }
.call generate_descent_call "    " elm->cl type type
    if( !visit_type( ctx, elm->cl ) ){
	return elm;
    }
    if( ctx->in_typeof ){
	return elm;
    }
    check_type_accessrights( ctx, elm->cl );
    if( elm->body != statement_listNIL ){
	// This is an anonymous class.
	// Make it an inner class, and rewrite the constructor to refer
	// to the anonymous class.
	expression_list parms = rdup_expression_list( elm->parameters );
	bool old_in_typeof = ctx->in_typeof;
	ctx->in_typeof = true;
.call generate_descent_call "	" parms expression_list expression_list
	ctx->in_typeof = old_in_typeof;
	ClassDeclaration anonymous = build_anonymous_class(
	    ctx,
	    elm->cl,
	    parms,
	    elm->body
	);
	rfre_expression_list( parms );
	origsymbol classnm = rdup_origsymbol( anonymous->name );
.call generate_descent_call "	" anonymous ClassDeclaration ClassDeclaration
	rfre_statement( anonymous );
	rfre_type( elm->cl );
	elm->cl = new_ObjectType( classnm );
	rfre_statement_list( elm->body );
	elm->body = statement_listNIL;
    }
    // Rewrite an expression
    //     ... new T( <parms> ) ...
    // to:
    //     T <tmp> = newrecord T;
    //     <constructor> T( <tmp>, <parms> );
    // 
    //     ... <tmp> ...
    expression newrec = new_NewRecordExpression( rdup_type( elm->cl ) );
    expression res = breakout_expression( ctx, newrec );
    ConstructorInvocationStatement ccall = new_ConstructorInvocationStatement(
	rdup_origin( ctx->org ),
	Pragma_listNIL,
	origsymbol_listNIL,	// Labels
	rdup_expression( res ),
	elm->cl,
	elm->outer,
	elm->parameters
    );
    fre_expression( elm );
.call generate_descent_call "    " ccall ConstructorInvocationStatement ConstructorInvocationStatement
    ctx->mangled_pre_spill_smts = append_statement_list(
	ctx->mangled_pre_spill_smts,
	ccall
    );
.call generate_descent_call "    " res expression expression
    return res;
}

// Given an NewArrayExpression, rewrite any nested NewArrayExpressions
// to separate initialization expressions.
static expression mangle_NewArrayExpression_action(
    NewArrayExpression x,
    mangle_data *ctx
)
{
    if( x->sizes->sz>1 ){
	origsymbol arrnm = gen_origsymbol( "arr" );
	origsymbol ixnm = gen_origsymbol( "ix" );

	ActualDim_list subsizes;
	x->sizes = extractlist_ActualDim_list(
	    x->sizes,
	    1,
	    x->sizes->sz,
	    &subsizes
	);
	ActualDim topdim = x->sizes->arr[0];
	expression topsize = topdim->vector;
	Cardinality card = new_Cardinality(
	    ixnm,
	    new_Pragma_list(),
	    expressionNIL,
	    rdup_expression( topsize ),
	    expressionNIL
	);
	Cardinality_list cards = append_Cardinality_list(
	    new_Cardinality_list(),
	    card
	);
	AssignStatement fill = new_AssignStatement(
	    rdup_origin( ctx->org ),
	    Pragma_listNIL,
	    origsymbol_listNIL,	// Labels
	    ASSIGN,
	    new_SubscriptExpression(
		new_VariableNameExpression(
		    rdup_origsymbol( arrnm ),
		    VAR_FINAL|VAR_LOCAL|VAR_GENERATED
		),
		new_VariableNameExpression(
		    rdup_origsymbol( ixnm ),
		    VAR_LOCAL|VAR_GENERATED
		)
	    ),
	    new_NewArrayExpression(
		rdup_type( x->t ),
		rdup_ActualDim_list( subsizes ),
		x->initval
	    )
	);
	// We don't have to initialize the toplevel array, since it will
	// be filled by the code we generate anyway.
	x->initval = new_OptExprNone();
	ForStatement smt = new_ForStatement(
	    rdup_origin( ctx->org ),
	    Pragma_listNIL,
	    origsymbol_listNIL,	// Labels
	    false,		// Not an inline for
	    cards,
	    new_Block(
		tmsymbolNIL,
		Pragma_listNIL,
		append_statement_list( new_statement_list(), fill )
	    )
	);
	ctx->post_spill_smts = append_statement_list( ctx->post_spill_smts, smt );
	// Construct the type of the array from the dimension wrappers.
	unsigned int n = subsizes->sz;
	while( n>0 ){
	    n--;
	    ActualDim dim = subsizes->arr[n];
	    x->t = new_ArrayType(
		x->t,
		new_GetLengthExpression( rdup_expression( topsize ) )
	    );
	    if( dim->pragmas != Pragma_listNIL && dim->pragmas->sz != 0 ){
		x->t = new_PragmaType( rdup_Pragma_list( dim->pragmas ), x->t );
	    }
	}
	rfre_ActualDim_list( subsizes );
	type at = new_ArrayType(
	    rdup_type( x->t ),
	    new_GetLengthExpression( rdup_expression( topsize ) )
	);
	if( topdim->pragmas != Pragma_listNIL && topdim->pragmas->sz != 0 ){
	    at = new_PragmaType( rdup_Pragma_list( topdim->pragmas ), at );
	}
	FieldDeclaration d = new_FieldDeclaration(
	    gen_origin(),
	    Pragma_listNIL,
	    origsymbol_listNIL,	// Labels
	    ACC_FINAL,
	    false,		// used
	    rdup_origsymbol( arrnm ),
	    at,
	    new_OptExprNone()
	);
.call generate_descent_call "	" d FieldDeclaration FieldDeclaration
	ctx->breakout_declarations = append_statement_list( ctx->breakout_declarations, d );
	VariableNameExpression lhs = new_VariableNameExpression( rdup_origsymbol( arrnm ), VAR_GENERATED|VAR_LOCAL );
	AssignStatement asmt = new_AssignStatement(
	    gen_origin(),
	    Pragma_listNIL,
	    new_origsymbol_list(),
	    ASSIGN,
	    lhs,
	    x
	);
.call generate_descent_call "	" asmt AssignStatement AssignStatement
	ctx->mangled_pre_spill_smts = append_statement_list(
	    ctx->mangled_pre_spill_smts,
	    asmt
	);

	VariableNameExpression x_arr = new_VariableNameExpression( arrnm, VAR_FINAL|VAR_LOCAL|VAR_GENERATED );
.call generate_descent_call "	" x_arr VariableNameExpression VariableNameExpression
	return x_arr;
    }
.call generate_walker_call "    " x NewArrayExpression NewArrayExpression
    return x;
}

/* Action for a statement. */
static statement mangle_statement_action(
 statement smt,
 mangle_data *ctx
)
{
    jumpchain_element jmpelm;
    origsymbol breaktarget = origsymbolNIL;
    origin old_org = ctx->org;
    origsymbol_list labels = smt->labels;
    bool pushed_programstate = false;

    if(
        !is_labeled_statement( smt ) &&
	completes_abruptly( ctx )
    ){
	// This implements JLS2 14.20
	origin_error( smt->org, "Unreachable statement" );
	rfre_statement( smt );
	// Don't try to do anything more, since that may spill further
	// unreachable statements.
	return statementNIL;
    }
    if( !is_declaration( smt ) ){
	push_programstate( ctx->states, false, "break/continue analysis" );
	pushed_programstate = true;
    }
    if( labels != origsymbol_listNIL ){
	for( unsigned int ix=0; ix<labels->sz; ix++ ){
	    origsymbol lbl = labels->arr[ix];
	    const jumpchain_element *e = search_jumpchain( ctx->jumpchain, lbl );
	    if( e != NULL ){
		origsymbol_error( lbl, "Label already defined in an outer block" );
	    }
	}
    }
    jmpelm.smt = smt;			// The labels on the start of the block
    jmpelm.breaklabel = &breaktarget;	// The label on the end of the block
    jmpelm.analysis_level = ctx->states->sz;
    jmpelm.next = ctx->jumpchain;
    jmpelm.used_for_break = false;
    jmpelm.used_for_continue = false;
    jmpelm.breaksource_states = ProgramState_listNIL;
    ctx->jumpchain = &jmpelm;		// Insert our smt in the jump chain.
    ctx->org = smt->org;

    // Make sure that there are no duplicate labels in the active blocks.
    // TODO: be smarter than this.
.call generate_walker_call "    " smt statement statement
    if( jmpelm.used_for_continue ){
	register_jump_target( ctx->states );
	if( breaktarget != origsymbolNIL ){
	    smt = breakwrap_statement( smt, breaktarget );
	}
	// TODO: don't zap all analysis information
	assert( pushed_programstate );
	pop_possibletrip_programstate( ctx->symtab, ctx->states, "continue target" );
    }
    else if( jmpelm.used_for_break ){
	if( breaktarget != origsymbolNIL ){
	    smt = breakwrap_statement( smt, breaktarget );
	}
	assert( pushed_programstate );
	ProgramState_list sl = jmpelm.breaksource_states;
	if( sl == ProgramState_listNIL || sl->sz == 0 ){
	    // Nobody breaks to here, so we can simply use the
	    // current program state (but how dit used_for_break get set)?
	    pop_onetrip_programstate( ctx->symtab, ctx->states, "unused break target" );
	}
	else {
	    if( trace_analysis ){
		fprintf( stderr, "Break target: registering the following break states:\n" );
		dump_programstates( stderr, sl );
	    }
	    // There are alternative program states coming from break
	    // statements.
	    // First, merge them down to one alternative program state.
	    while( sl->sz>1 ){
		ProgramState thenstate = sl->arr[0];
		ProgramState elsestate = sl->arr[1];

		// Merge the first two program states in the list.
		ProgramState snew = merge_thenelse_programstates(
		    thenstate,
		    elsestate
		);
		rfre_ProgramState( thenstate );
		rfre_ProgramState( elsestate );

		// Replace the first program state with the merged one.
		sl->arr[0] = snew;

		if( sl->sz>2 ){
		    // There are more states left, grab one from the
		    // top and put it in the empty slot. This way we save
		    // a list move operation.
		    sl->arr[1] = sl->arr[sl->sz-1];
		}
		sl->sz--;
	    }
	    // We now have the main program state, and a single program
	    // state in sl.
	    assert( sl->sz == 1 );
	    if( trace_analysis ){
		fprintf( stderr, "Break state merging resulted in:\n" );
		dump_programstate( stderr, 0, sl->arr[0] );
	    }

	    // Now merge the main program state and the remaining state
	    // in sl.
	    pop_thenelse_programstate( ctx->symtab, ctx->states, sl->arr[0], "break target analysis" );

	    // The merged state is consumed by the pop_thenelse_programstate.
	    // Empty the list.
	    sl->sz = 0;
	    register_jump_target( ctx->states );
	}
    }
    else {
	if( pushed_programstate ){
	    pop_onetrip_programstate( ctx->symtab, ctx->states, "no break/continue" );
	}
    }
    if( jmpelm.breaksource_states != ProgramState_listNIL ){
        // For the moment, simply throw away the collected program states
	// from jump positions.
	// TODO: do this better.
	rfre_ProgramState_list( jmpelm.breaksource_states );
    }
    register_notnull_asserted( ctx );
    ctx->org = old_org;
    ctx->jumpchain = jmpelm.next;	// Restore old jump chain.
    return smt;
}


/* Action for a statement list. */
static statement_list mangle_statement_list_action( statement_list sl, mangle_data *ctx )
{
    if( sl == statement_listNIL ){
	return sl;
    }
    statement_list old_post_spill = ctx->post_spill_smts;
    statement_list old_mangled_pre_spill = ctx->mangled_pre_spill_smts;
    bool allow_decl = true;

    (void) mangle_statement_list_walker;
    ctx->mangled_pre_spill_smts = new_statement_list();
    ctx->post_spill_smts = new_statement_list();
    unsigned int ix = 0;
    while( ix<sl->sz ){
	if( is_declaration( sl->arr[ix] ) ){
	    if( !allow_decl ){
		// We cannot allow a declaration after a statement, so
		// create a new block at this point.

		statement_list tail;

		sl = extractlist_statement_list( sl, ix, sl->sz, &tail );
		sl = append_statement_list(
		    sl,
		    new_BlockStatement(
			rdup_origin( tail->arr[0]->org ),
			Pragma_listNIL,
			origsymbol_listNIL,
			new_Block( tmsymbolNIL, Pragma_listNIL, tail )
		    )
		);
	    }
	}
	else {
	    allow_decl = false;
	}
.call generate_descent_call "	" sl->arr[ix] statement statement
	if( sl->arr[ix] == statementNIL ){
	    // There was an error in this statement, delete it to prevent
	    // trouble later on.
	    sl = delete_statement_list( sl, ix );
	}
	if( ctx->mangled_pre_spill_smts->sz != 0 ){
	    unsigned int skipsz = ctx->mangled_pre_spill_smts->sz;
	    sl = insertlist_statement_list( sl, ix, ctx->mangled_pre_spill_smts );
	    ix += skipsz;
	    ctx->mangled_pre_spill_smts = new_statement_list();
	}
	if( ctx->post_spill_smts->sz != 0 ){
	    sl = insertlist_statement_list( sl, ix+1, ctx->post_spill_smts );
	    ctx->post_spill_smts = new_statement_list();
	}
	statement smt = sl->arr[ix];
	if( smt != statementNIL && smt->tag == TAGBlockStatement ){
	    BlockStatement bsmt = to_BlockStatement( smt );
	    Block body = bsmt->body;
	    statement_list bsl = body->statements;
	    if(
		(bsmt->pragmas == Pragma_listNIL || smt->pragmas->sz == 0) &&
		(bsmt->labels == origsymbol_listNIL || smt->labels->sz == 0) &&
		body->scope == tmsymbolNIL &&
		(bsl->sz == 0 || !is_declaration( bsl->arr[0] ))
	    ){
		// We might as well inline this block.
		// Make sure 'bsl' is not deleted when the block
		// statement is deleted.
		body->statements = statement_listNIL;
		sl = delete_statement_list( sl, ix );
		unsigned int step = bsl->sz;
		// We now have the 'bsl' left from the block statement.
		sl = insertlist_statement_list( sl, ix, bsl );
		ix += step;
		continue;
	    }
	}
	if( smt != statementNIL && smt->tag == TAGEmptyStatement ){
	    if(
		(smt->labels == NULL || smt->labels->sz == 0) &&
		(smt->pragmas == NULL || smt->pragmas->sz == 0)
	    ){
		sl = delete_statement_list( sl, ix );
		continue;
	    }
	}
	ix++;
    }
    assert( ctx->post_spill_smts->sz == 0 );
    assert( ctx->mangled_pre_spill_smts->sz == 0 );
    rfre_statement_list( ctx->post_spill_smts );
    rfre_statement_list( ctx->mangled_pre_spill_smts );
    ctx->post_spill_smts = old_post_spill;
    ctx->mangled_pre_spill_smts = old_mangled_pre_spill;
    return sl;
}

/* Action for a TypeOf. */
static type mangle_TypeOf_action(
 TypeOf t,
 mangle_data *ctx
)
{
    bool old_expand_inlines = ctx->expand_inlines;
    bool old_in_typeof = ctx->in_typeof;
    ctx->in_typeof = true;
    ctx->expand_inlines = false;
    push_programstate( ctx->states, false, "typeof" );
.call generate_walker_call "    " t TypeOf TypeOf
    // Throw away any side-effects from a typeof expression, since in
    // reality it won't be evaluated.
    pop_zerotrip_programstate( ctx->states, "typeof" );
    zap_notnull_asserted( ctx );
    type res = derive_type_expression( ctx->symtab, t->x );
    rfre_type( t );
.call generate_descent_call "    " res type type
    ctx->expand_inlines = old_expand_inlines;
    ctx->in_typeof = old_in_typeof;
    return res;
}

/* Action for a TypeOfIf. */
static type mangle_TypeOfIf_action(
 TypeOfIf t,
 mangle_data *ctx
)
{
    bool old_expand_inlines = ctx->expand_inlines;
    bool old_in_typeof = ctx->in_typeof;
    ctx->in_typeof = true;
    ctx->expand_inlines = false;
    push_programstate( ctx->states, false, "typeofif" );
.call generate_walker_call "    " t TypeOfIf TypeOfIf
    // Throw away any side-effects from a typeof expression, since in
    // reality it won't be evaluated.
    pop_zerotrip_programstate( ctx->states, "typeofif" );
    zap_notnull_asserted( ctx );
    type res = calculate_ifexpression_type( ctx->symtab, t->org, t->thenval, t->elseval );
    rfre_type( t );
.call generate_descent_call "    " res type type
    ctx->expand_inlines = old_expand_inlines;
    ctx->in_typeof = old_in_typeof;
    return res;
}

static statement mangle_FieldInvocationStatement_action(
 FieldInvocationStatement smt,
 mangle_data *ctx
)
{
    if( smt == FieldInvocationStatementNIL ){
	return smt;
    }

    expression_list this_parameters = new_expression_list();
    bool use_static_call;
    statement res = statementNIL;

    if( maybe_has_sideeffect( smt->var, NO_SE_ARRAY_NEW ) ){
	smt->var = breakout_expression( ctx, smt->var );
    }
.call generate_walker_call "    " smt FieldInvocationStatement FieldInvocationStatement
    expression_list parameters = rdup_expression_list( smt->parameters );
    MethodEntry me = bind_expression_method(
	ctx,
	smt->var,
	smt->field,
	&this_parameters,
	&use_static_call,
	&parameters
    );
    if( me == MethodEntryNIL ){
	return smt;
    }
    if( is_special_method( me ) ){
	res = construct_special_method_statement(
	    ctx,
	    smt->pragmas,
	    me
	);
	rfre_expression_list( this_parameters );
	rfre_statement( smt );
	return res;
    }
    register_actual_escapes( ctx, me, parameters, this_parameters );
    register_method_throws( ctx->states, me->throws );
    if(
	me->tag == TAGFunctionEntry &&
	ctx->expand_inlines &&
	use_static_call &&
	has_flags( me->flags, ACC_INLINE )
    ){
	this_parameters = build_notnullassert( ctx, this_parameters );
	Block blk = expand_inlined_method(
	    ctx,
	    me,
	    smt->org,
	    this_parameters,
	    parameters,
	    tmsymbolNIL
	);
	res = new_BlockStatement(
	    rdup_origin( smt->org ),
	    rdup_Pragma_list( smt->pragmas ),
	    origsymbol_listNIL,	// Labels
	    blk
	);
	rfre_expression_list( this_parameters );
	rfre_expression_list( parameters );
    }
    else {
	origsymbol proc = new_origsymbol( me->name, rdup_origin( smt->org ) );
	MethodInvocation call = new_MethodInvocation(
	    expressionNIL,
	    proc,
	    this_parameters,
	    parameters,
	    0
	);
	if( !use_static_call ){
	    call->vtab = build_notnullassert( ctx, rdup_expression( smt->var ) );
	}
	else {
	    this_parameters = build_notnullassert( ctx, this_parameters );
	}
	if( me->t->tag != TAGVoidType ){
	    if( warn_ignoredvalue ){
		origin_warning( smt->org, "returned value is ignored" );
	    }
	    expression x = new_MethodInvocationExpression( call );
	    res = new_ExpressionStatement(
		rdup_origin( smt->org ),
		rdup_Pragma_list( smt->pragmas ),
		origsymbol_listNIL,	// Labels
		x
	    );
	}
	else {
	    res = new_MethodInvocationStatement(
		rdup_origin( smt->org ),
		rdup_Pragma_list( smt->pragmas ),
		origsymbol_listNIL,	// Labels
		call
	    );
	}
    }
    rfre_statement( smt );
    return res;
}

// Given an expression 'x', return true iff it represents the variable 'this'.
static bool is_this_variable( const_expression x )
{
    bool res = false;

    switch( x->tag ){
        case TAGAnnotationExpression:
	    return is_this_variable( to_const_AnnotationExpression(x)->x );

	case TAGVariableNameExpression:
	{
	    const_VariableNameExpression vx = to_const_VariableNameExpression(x);

	    res = has_any_flag( vx->flags, VAR_THIS );
	    break;
	}

	default:
	    res = false;
	    break;
    }
    return res;
}

// Given an expression 'x', return true iff a blank final may occur
// at the lhs of an assignment in this form. The check is purely
// structural.
//
// See JLS2 16.
static bool is_ok_blank_final_lhs( const_expression x )
{
    bool res = false;

    switch( x->tag ){
        case TAGAnnotationExpression:
	    return is_ok_blank_final_lhs( to_const_AnnotationExpression(x)->x );

	case TAGVariableNameExpression:
	{
	    origsymbol nm = to_const_VariableNameExpression(x)->name;

	    if( is_qualified_origsymbol( nm ) ){
		origsymbol first;
		origsymbol last;

		break_qualified_name( nm, &first, &last );
		res = strcmp( first->sym->name, "this" ) == 0;
		rfre_origsymbol( first );
		rfre_origsymbol( last );
	    }
	    else {
		res = true;
	    }
	    break;
	}

	case TAGFieldExpression:
	{
	    const_FieldExpression fx = to_const_FieldExpression(x);

	    res = is_this_variable( fx->rec );
	    break;
	}

	default:
	    res = false;
	    break;
    }
    return res;

}

// Given an expression 'x', return true iff it refers to a blank final.
static bool is_blank_final( mangle_data *ctx, const_expression x )
{
    bool res = false;

    if( x == expressionNIL ){
        return res;
    }
    switch( x->tag ){
        case TAGAnnotationExpression:
	    return is_blank_final( ctx, to_const_AnnotationExpression(x)->x );

	case TAGVariableNameExpression:
	{
	    origsymbol nm = to_const_VariableNameExpression(x)->name;

	    const_VariableEntry ve = lookup_VariableEntry( ctx->symtab, nm->sym );
	    if( ve == VariableEntryNIL ){
		// There is trouble, don't make it worse.
	        res = false;
	    }
	    else {
		if( has_any_flag( ve->flags, ACC_FINAL ) ){
		    if( ve->tag == TAGGlobalVariableEntry ){
			res = is_initialization( get_init_expression( ve ) );
		    }
		}
	    }
	    break;
	}

	case TAGFieldExpression:
	{
	    origsymbol field = to_const_FieldExpression(x)->field;

	    const_VariableEntry ve = search_VariableEntry( ctx->symtab, field->sym );
	    if( ve == VariableEntryNIL ){
		// There is trouble, don't make it worse.
	        res = false;
	    }
	    else {
		if( has_any_flag( ve->flags, ACC_FINAL ) ){
		    if( ve->tag == TAGFieldEntry ){
			res = is_initialization( get_init_expression( ve ) );
		    }
		}
	    }
	    break;
	}

	default:
	    res = false;
	    break;
    }
    return res;
}

// Given an expression 'x', return true iff we don't mind repeating
// this expression. Thus, it shouldn't have side-effects, and shouldn't
// be too costly evaluating.
static bool is_variablename( const_expression x )
{
    if( x->tag == TAGAnnotationExpression ){
        return is_variablename( to_const_AnnotationExpression(x)->x );
    }
    if( x->tag == TAGBracketExpression ){
        return is_variablename( to_const_BracketExpression(x)->x );
    }
    if( x->tag == TAGVariableNameExpression ){
        return true;
    }
    return false;
}

// Given an expression 'x', return true iff we don't mind repeating
// this expression. Thus, it shouldn't have side-effects, and shouldn't
// be too costly evaluating.
static bool is_repeatable( const_expression x )
{
    if( x->tag == TAGAnnotationExpression ){
        return is_repeatable( to_const_AnnotationExpression(x)->x );
    }
    if( x->tag == TAGBracketExpression ){
        return is_repeatable( to_const_BracketExpression(x)->x );
    }
    if( x->tag == TAGVariableNameExpression ){
        return true;
    }
    if( x->tag == TAGVectorSubscriptExpression ){
        return is_repeatable( to_const_VectorSubscriptExpression(x)->vector );
    }
    if( x->tag == TAGFieldExpression ){
        return is_variablename( to_const_FieldExpression(x)->rec );
    }
    return false;
}

/* Action for a AssignStatement. */
static statement mangle_AssignStatement_action(
 AssignStatement smt,
 mangle_data *ctx
)
{
    if( smt->lhs->tag == TAGVectorExpression ){
	// This is an assignment of the form
	//     [a,b] = ...
	expression_list lhs_fields = to_VectorExpression(smt->lhs)->fields;
	expression simple_rhs;

	if( !is_trivial_initialization( smt->rhs ) ){
	    simple_rhs = breakout_expression( ctx, rdup_expression( smt->rhs ) );
	}
	else {
	    simple_rhs = rdup_expression( smt->rhs );
	}
	// Now generate assignment statements to all fields in the tuple
	// pattern.
	for( unsigned int ix=0; ix<lhs_fields->sz; ix++ ){
	    AssignStatement subsmt = new_AssignStatement(
		rdup_origin( smt->org ),
		smt->pragmas==NULL?Pragma_listNIL:rdup_Pragma_list( smt->pragmas ),
		origsymbol_listNIL,	// Labels
		ASSIGN,
		rdup_expression( lhs_fields->arr[ix] ),
		new_VectorSubscriptExpression(
		    rdup_expression( simple_rhs ),
		    ix
		)
	    );
.call generate_descent_call "	    " subsmt AssignStatement AssignStatement
	    ctx->mangled_pre_spill_smts = append_statement_list(
		ctx->mangled_pre_spill_smts,
		subsmt
	    );
	}
	rfre_expression( simple_rhs );
	rfre_statement( smt );
	return new_EmptyStatement(
	    gen_origin(),
	    Pragma_listNIL,
	    new_origsymbol_list()
	);
    }
    // If the assignment looks like
    // a[..] = x
    // a@v = x
    // and 'a' is a class that implements spar.lang.Array, rewrite
    // this to a.setElement( v, x );
    if( smt->lhs->tag == TAGSubscriptExpression ){
	SubscriptExpression s = to_SubscriptExpression(smt->lhs);
	expression array = rdup_expression( s->array );

	bool old_in_typeof = ctx->in_typeof;
	ctx->in_typeof = true;
.call generate_descent_call "	" array expression expression
	ctx->in_typeof = old_in_typeof;
	type tarray = derive_type_expression( ctx->symtab, array );
	rfre_expression( array );
	if( tarray != typeNIL && tarray->tag == TAGObjectType ){
	    // We are in fact subscribing a class.
	    if( smt->op != ASSIGN ){
		// For the moment, get rid of an operator in the assignment
		smt->rhs = new_BinopExpression(
		    rdup_expression( smt->lhs ),
		    assignop_to_binop( smt->op ),
		    smt->rhs
		);
		smt->op = ASSIGN;
	    }
	    FieldInvocationStatement call = new_FieldInvocationStatement(
		smt->org,
		smt->pragmas,
		smt->labels,
		s->array,
		new_origsymbol( add_tmsymbol( "setElement" ), rdup_origin( smt->org ) ),
		append_expression_list(
		    append_expression_list(
			new_expression_list(),
			s->subscripts
		    ),
		    smt->rhs
		)
	    );
#if 0
	    if( call == FieldInvocationStatementNIL ){
		tmstring cl_tnm = typename_type( tarray );
		origin_error(
		    smt->org,
		    "You try to subscript class %s, but that class does not have a method setElement(<vector>,<value>)",
		    cl_tnm
		);
		rfre_tmstring( cl_tnm );
	    }
#endif
	    smt->org = originNIL;
	    smt->pragmas = Pragma_listNIL;
	    smt->labels = origsymbol_listNIL;
	    smt->rhs = expressionNIL;
	    s->array = expressionNIL;
	    s->subscripts = expressionNIL;
	    rfre_statement( smt );
	    rfre_type( tarray );
.call generate_descent_call "	    " call FieldInvocationStatement FieldInvocationStatement
	    return call;
	}
	rfre_type( tarray );
    }

    bool ok_blank_final_lhs = is_ok_blank_final_lhs( smt->lhs );

    // mangle_AssignStatement_walker is inlined, since we must set
    // in_assign_lhs while walking the lhs.
    (void) mangle_AssignStatement_walker;
.call generate_descent_call "    " smt->pragmas Pragma_list Pragma_list
    register_notnull_asserted( ctx );
    // lhs of an expression must be evaluated first.
    bool old_in_assign_lhs = ctx->in_assign_lhs;
    ctx->in_assign_lhs = smt->op == ASSIGN;
    bool old_in_pure_expression = ctx->in_pure_expression;
    ctx->in_pure_expression = is_pure( smt->lhs );
.call generate_descent_call "    " smt->lhs expression expression
    ctx->in_pure_expression = is_pure( smt->rhs );
    ctx->in_assign_lhs = old_in_assign_lhs;
.call generate_descent_call "    " smt->rhs expression expression
    ctx->in_pure_expression = old_in_pure_expression;
    register_notnull_asserted( ctx );
    smt->rhs = constant_fold_expression( smt->rhs );
    if( is_blank_final( ctx, smt->lhs ) ){
        if( !ok_blank_final_lhs ){
	    origin_error(
		smt->org,
		"A blank final field may only be assigned by a simple name or this.name"
	    );
	}
    }
    type trhs = derive_type_expression( ctx->symtab, smt->rhs );
    type tlhs = typeNIL;
    if( is_vnusstring_type( trhs ) ){
	tlhs = derive_type_expression( ctx->symtab, smt->lhs );
	if( !is_vnusstring_type( tlhs ) ){
	    smt->rhs = internalize_Vnus_string( ctx, smt->rhs );
	}
    }
#if 0
    if(
	smt->rhs->tag == TAGVectorExpression &&
	is_repeatable( smt->lhs )
    ){
	tlhs = derive_type_expression( ctx->symtab, smt->lhs );
        if( is_tuple_type( tlhs ) ){
	    // We have an assignment of the form
	    //   <lhs> <op>= [ <expr0>, <expr1>, ... ]
	    // where lhs is a tuple expression that we don't mind replicating.
	    // Rewrite this to:
	    //   <lhs>[0] <op>= <expr0>
	    //   <lhs>[1] <op>= <expr1>
	    //      :
	    //      :

	    expression_list rv = to_VectorExpression(smt->rhs)->fields;

	    for( unsigned int ix=0; ix<rv->sz; ix++ ){
		AssignStatement subsmt = new_AssignStatement(
		    rdup_origin( smt->org ),
		    smt->pragmas==Pragma_listNIL?Pragma_listNIL:rdup_Pragma_list( smt->pragmas ),
		    origsymbol_listNIL,	// Labels
		    smt->op,
		    new_VectorSubscriptExpression( rdup_expression( smt->lhs ), ix ),
		    rdup_expression( rv->arr[ix] )
		);
		register_escapes( ctx, rv->arr[ix], "assigned" );
		// TODO: also do something clever for resulting assignments.
		ctx->mangled_pre_spill_smts = append_statement_list(
		    ctx->mangled_pre_spill_smts,
		    subsmt
		);
	    }
	    rfre_statement( smt );
	    rfre_type( tlhs );
	    rfre_type( trhs );
	    return new_EmptyStatement(
		gen_origin(),
		Pragma_listNIL,
		new_origsymbol_list()
	    );
	}
    }
#endif
    if( smt->op != ASSIGN ){
	if( tlhs == typeNIL ){
	    tlhs = derive_type_expression( ctx->symtab, smt->lhs );
	}
	if( is_String_type( tlhs ) ){
	    if( smt->op != ASSIGN_PLUS ){
		origin_error(
		    smt->org,
		    "Only operator += can be used on a String"
		);
	    }
	    else {
		// TODO: we know this is a concat operation. We could do
		// something smarter than just rewriting the += operator.
		smt->rhs = simplify_BinopExpression(
		    new_BinopExpression(
			rdup_expression( smt->lhs ),
			assignop_to_binop( smt->op ),
			smt->rhs
		    ),
		    ctx
		);
		smt->op = ASSIGN;
	    }
	}
	else if( is_tuple_type( tlhs ) ){
	    smt->rhs = simplify_BinopExpression(
		new_BinopExpression(
		    rdup_expression( smt->lhs ),
		    assignop_to_binop( smt->op ),
		    smt->rhs
		),
		ctx
	    );
	    smt->op = ASSIGN;
	}
    }
    rfre_type( tlhs );
    rfre_type( trhs );
    if( is_deletable( ctx, smt->lhs ) ){
	if( trace_analysis ){
	    dump_expression(
	        stderr,
		smt->lhs, 
		"Variable is overwritten, previous value can be __delete-ed"
	    );
	    (void) is_deletable( ctx, smt->lhs );
	}
	statement dsmt = build_delete_statement( ctx->org, smt->lhs );
	ctx->mangled_pre_spill_smts = append_statement_list(
	    ctx->mangled_pre_spill_smts,
	    dsmt
	);
    }
    register_escapes( ctx, smt->rhs, "assigned" );
    if( smt->lhs != expressionNIL && smt->lhs->tag == TAGVariableNameExpression ){
	const_VariableNameExpression nmx = to_const_VariableNameExpression(smt->lhs);
	origsymbol nm = nmx->name;
	varflags flags = nmx->flags;
	bool ok = true;

	if( !has_any_flag( flags, VAR_GENERATED ) ){
	    if( has_any_flag( flags, VAR_THIS ) ){
		origin_error( nm->org, "Cannot assign to a 'this' expression" );
		ok = false;
	    }
	    if( has_any_flag( flags, VAR_CLASS ) ){
		origin_error( nm->org, "Cannot assign to a 'class' expression" );
		ok = false;
	    }
	}
	if( ok ){
	    check_final_violation( ctx, nm->sym, nm->org );
	}
	register_variable_assignment( ctx, nm, smt->rhs );
    }
    return smt;
}

/* Action for a ThrowStatement. */
static ThrowStatement mangle_ThrowStatement_action(
 ThrowStatement smt,
 mangle_data *ctx
)
{
.call generate_walker_call "    " smt ThrowStatement ThrowStatement
    type t = derive_type_expression( ctx->symtab, smt->x );
    // This should always be true for a valid program, but if not
    // it is not our place to report the error.
    if( t->tag == TAGObjectType ){
	origsymbol tnm = to_ObjectType(t)->name;

	if( tnm != origsymbolNIL ){
	    if( !is_subclass( ctx->typelist, tnm->sym, add_tmsymbol( "java.lang.Throwable" ) ) ){
		origin_error(
		    smt->org,
		    "Cannot throw '%s', since it is not a subclass of java.lang.Throwable",
		    tnm->sym->name
		);
	    }
	    if( !is_valid_thrown_type( ctx->typelist, tnm, ctx->allowed_throws ) ){
		origin_error(
		    smt->org,
		    "Exception %s must be caught, or must be declared in the throws clause of this method",
		    tnm->sym->name
		);
	    }
	    register_throws_exception( ctx->states, t );
	}
    }
    register_escapes( ctx, smt->x, "throw" );
    rfre_type( t );
    return smt;
}

/* Action for a InternalThrowStatement. */
static InternalThrowStatement mangle_InternalThrowStatement_action(
 InternalThrowStatement smt,
 mangle_data *ctx
)
{
.call generate_walker_call "    " smt InternalThrowStatement InternalThrowStatement
    register_escapes( ctx, smt->x, "throw" );
    type t = derive_type_expression( ctx->symtab, smt->x );
    register_throws_exception( ctx->states, t );
    rfre_type( t );
    return smt;
}

/* Action for a ValueReturnStatement. */
static ValueReturnStatement mangle_ValueReturnStatement_action(
 ValueReturnStatement smt,
 mangle_data *ctx
)
{
.call generate_walker_call "    " smt ValueReturnStatement ValueReturnStatement
    // TODO: make sure we don't in fact *want* to return a Vnus string.
    if( !is_vnusstring_type( ctx->rettype ) ){
	type tv = derive_type_expression( ctx->symtab, smt->v );
	if( is_vnusstring_type( tv ) ){
	    smt->v = internalize_Vnus_string( ctx, smt->v );
	}
	rfre_type( tv );
    }
    register_escapes( ctx, smt->v, "return" );
    register_return_value( ctx, smt->v );
    enforce_deletables( ctx );
    register_returns( ctx->states );
    return smt;
}

/* Action for a ReturnStatement. */
static ReturnStatement mangle_ReturnStatement_action(
 ReturnStatement smt,
 mangle_data *ctx
)
{
.call generate_walker_call "    " smt ReturnStatement ReturnStatement
    enforce_deletables( ctx );
    register_returns( ctx->states );
    return smt;
}

/* Action for a declaration. */
static declaration mangle_declaration_action( declaration d, mangle_data *ctx )
{
    if( has_flags( d->flags, ACC_INLINE ) ){
	return d;
    }
    d->used = true;
.call generate_walker_call "    " d declaration declaration
    return d;
}

/* Mangle action for a TypeDeclaration */
static TypeDeclaration mangle_TypeDeclaration_action(
 TypeDeclaration d,
 mangle_data *ctx
)
{
    tmsymbol old_dynamic_init = ctx->dynamic_init;
    context oldwhere = ctx->where;

    ctx->where = CTX_OBJECT;
    ctx->dynamic_init = d->dynInit;
.call generate_walker_call "    " d TypeDeclaration TypeDeclaration
    ctx->dynamic_init = old_dynamic_init;
    ctx->where = oldwhere;
    return d;
}

// Given a class declaration 'cl' and a name to rename it to 'to', rename
// the class.
static ClassDeclaration rename_class( ClassDeclaration cl, tmsymbol to )
{
    statement_list body = cl->body;

    for( unsigned int ix=0; ix<body->sz; ix++ ){
	statement d = body->arr[ix];

	if( d->tag == TAGConstructorDeclaration ){
	    ConstructorDeclaration cd = to_ConstructorDeclaration(d);

	    // TODO: if this is not checked elsewhere, make sure the
	    // original name of the constructor is the name of the class.
	    cd->name->sym = to;
	}
    }
    cl->name->sym = to;
    return cl;
}

// Mangle action for a ClassDeclaration
static statement mangle_ClassDeclaration_action(
 ClassDeclaration cl,
 mangle_data *ctx
)
{
    (void) mangle_ClassDeclaration_walker;
    const_TypeEntry super_te = TypeEntryNIL;

    if( !has_any_flag( cl->flags, ACC_LOCAL_OBJECT ) ){
	internal_error( "mangle_ClassDeclaration_action should only be invoked for local class" );
    }

    // TODO: should this translate_type be done?
    if( !visit_type( ctx->prog, ctx->org, translate_type( ctx, cl->super ) ) ){
	return cl;
    }
    tmsymbol supernm = translate_type( ctx, cl->super );
    if( supernm != tmsymbolNIL ){
	super_te = lookup_TypeEntry( ctx->typelist, supernm );
    }

    if( ctx->static_context ){
	// A lot of things are not allowed in a static context. Enforce this.
	const_statement_list body = cl->body;

	for( unsigned int i=0; i<body->sz; i++ ){
	    const_statement smt = body->arr[i];

	    if( is_declaration( smt ) ){
	        const_declaration d = to_const_declaration( smt );

		if( has_any_flag( d->flags, ACC_STATIC ) ){
		    // TODO: dig up the name and use it in the error message
		    origin_error( smt->org, "A local class in a static context may not have a static member" );
		}

	    }
	    if( smt->tag == TAGStaticInitializer ){
		origin_error( smt->org, "A local class in a static context may not have a static initializer" );
	    }
	}
    }
    // Traverse the class declaration and collect external references.
    origsymbol_list unbounds;
    unbounds = new_origsymbol_list();
    if( super_te != TypeEntryNIL && super_te->tag == TAGClassEntry ){
	const_HiddenParameter_list super_unbounds = to_const_ClassEntry(super_te)->hiddenparms;

	if( super_unbounds != NULL ){
	    for( unsigned int i=0; i<super_unbounds->sz; i++ ){
		const_HiddenParameter p = super_unbounds->arr[i];

		unbounds = append_origsymbol_list(
		    unbounds,
		    new_origsymbol( p->name, rdup_origin( cl->org ) )
		);
	    }
	}
    }
    // TODO: fill this list with the names of the superclass fields.
    tmsymbol_list super_fields = new_tmsymbol_list();
    getunbounds_declaration( cl, unbounds, super_fields );
    rfre_tmsymbol_list( super_fields );

    // Enforce:
    //
    // Any local variable, formal method parameter or exception handler
    // parameter used but not declared in an inner class must be delcared
    // final, and must be definitely assigned before the body of the
    // inner class. -- JLS2 8.1.2.
    // Based on the unbound variables we've collected, construct a list of
    // formal parameters.
    HiddenParameter_list hiddenparms = build_hiddenparms( ctx, unbounds );
    rfre_origsymbol_list( unbounds );

    ClassDeclaration clone = rdup_ClassDeclaration( cl );
    if( clone->hiddenparms != HiddenParameter_listNIL ){
	rfre_HiddenParameter_list( clone->hiddenparms );
    }
    clone->hiddenparms = hiddenparms;

    // Also add these hidden parameters as field to the class.
    for( unsigned int ix=0; ix<hiddenparms->sz; ix++ ){
	const_HiddenParameter p = hiddenparms->arr[ix];

	FieldDeclaration d = new_FieldDeclaration(
	    gen_origin(),
	    Pragma_listNIL,
	    new_origsymbol_list(),	// Labels
	    ACC_PRIVATE,
	    false,			// used?
	    add_origsymbol( p->name ),
	    rdup_type( p->t ),
	    new_OptExprNone()
	);
	clone->body = append_statement_list( clone->body, d );
    }

    // Think up a mangled name for this type.
    tmsymbol clone_name = gen_role_tmsymbol( clone->name, "localclass" );

    // Enforce this mangled name on the class and its constructors.
    clone = rename_class( clone, clone_name );
    // The class we're constructing no longer has the role of a local
    // class, but of an inner class.
    clone->flags &= ~ACC_LOCAL_OBJECT;
    clone->flags |= ACC_MEMBER_OBJECT;
    if( ctx->where == CTX_STATICROUTINE ){
	clone->flags |= ACC_STATIC;
    }
    ctx->unit->decls = append_statement_list( ctx->unit->decls, clone );
    // Add a type mapping for this type.
    ctx->typebindings = register_TypeBinding(
	ctx->typebindings,
	ctx->unit->packagename->sym,
	new_TypeBinding( cl->name->sym, clone_name )
    );

    regtype_TypeDeclaration( ctx->prog, clone, ctx->unit, &ctx->typebindings, ctx->owner );

    if( trace_innerclasses ){
	dump_statement(
	    stderr,
	    clone,
	    "Implementation of local class '%s'",
	    cl->name->sym->name
	);
    }

    EmptyStatement res = new_EmptyStatement( cl->org, cl->pragmas, cl->labels );
    cl->org = originNIL;
    cl->pragmas = Pragma_listNIL;
    cl->labels = origsymbol_listNIL;
    rfre_statement( cl );
    return res;
}

/* Mangle action for an InterfaceDeclaration */
static InterfaceDeclaration mangle_InterfaceDeclaration_action(
    InterfaceDeclaration inf,
    mangle_data *ctx
)
{
    (void) inf;
    (void) ctx;
    (void) mangle_InterfaceDeclaration_walker;
    internal_error( "mangle_InterfaceDeclaration_action should never be invoked" );
    /* NOTREACHED */
    return inf;
}

/* Mangle action for an MethodDeclaration */
static MethodDeclaration mangle_MethodDeclaration_action(
    MethodDeclaration d,
    mangle_data *ctx
)
{
    if( has_flags( ctx->classflags, ACC_FINAL ) ){
	if( !has_flags( d->flags, ACC_STATIC ) ){
	    // If the type is final, its MethodDeclarations can be labeled
	    // final too. Implied by JLS2 8.1.1.2.
	    d->flags |= ACC_FINAL;
	}
    }

    // Now see if there are variables or parameters that, judging from
    // the way they are used, can be declared `final'.
    d = markfinal_MethodDeclaration( d );

    // If this is an initializer function, say that we're in a constructor
    bool old_in_constructor = ctx->in_constructor;
    ctx->in_constructor = has_any_flag( d->flags, ACC_INIT );
.call generate_walker_call "    " d MethodDeclaration MethodDeclaration
    ctx->in_constructor = old_in_constructor;
    // TODO: use the collected analysis information to say something
    // about this method.
    return d;
}

/* Extract symboltable info from a FormalParameter_list.  */
static FormalParameter_list mangle_FormalParameter_list_action( FormalParameter_list pl, mangle_data *ctx )
{
.call generate_walker_call "    " pl FormalParameter_list FormalParameter_list
    register_FormalParameter_list( ctx->states, pl, false );
    return pl;
}

/* Mangle action for a FunctionDeclaration */
static FunctionDeclaration mangle_FunctionDeclaration_action(
 FunctionDeclaration fn,
 mangle_data *ctx
)
{
    Block blk = fn->body;
    tmsymbol *oldscope = ctx->scopeptr;
    int oldlevel = ctx->scopelevel;
    context oldwhere = ctx->where;
    tmsymbol mangled_name;
    origsymbol this_sym;
    type old_rettype = ctx->rettype;

    (void) check_duplicate_FormalParameters( fn->parameters );
    // Continue, even if the above check failed.
    if( fn->flags & ACC_INIT ){
	TypeEntry me = lookup_TypeEntry( ctx->typelist, ctx->owner );

	if( me != TypeEntryNIL && me->tag == TAGClassEntry ){
	    statement static_init_smt = build_static_init_statement(
		ctx,
		to_ClassEntry( me )->super
	    );
	    if( static_init_smt != statementNIL ){
		blk->statements = insert_statement_list(
		    blk->statements,
		    0,
		    static_init_smt
		);
	    }
	    if( blk->statements->sz<2 && is_ObjectTypeEntry( me ) ){
		// The static initializer only contains 'need = false;';
		// no initializers, and no call to a superclass.
		// Ergo, not interesting, so zap it.
		to_ObjectTypeEntry(me)->staticInit = tmsymbolNIL;
		to_ObjectTypeEntry(me)->staticInitNeed = tmsymbolNIL;
		if( trace_analysis ){
		    fprintf(
			stderr,
			"Class %s does not need static initialization\n",
			me->name->sym->name
		    );
		}
	    }
	    // We don't have to do static init of the class we're in...
	    (void) register_staticInit_done( ctx, me->name->sym );
	}
    }
    else {
	// If the method is dynamic, we assume that the constructor has done
	// our duty for us. This is almost water-proof, except some dumbo
	// might invoke a dynamic routine on a null object, but that crashes
	// horribly anyway (and shouldn't occur).
	if( oldwhere != CTX_OBJECT || has_flags( fn->flags, ACC_STATIC ) ){
	    statement static_init_smt = build_static_init_statement(
		ctx,
		ctx->owner
	    );
	    if( static_init_smt != statementNIL ){
		blk->statements = insert_statement_list(
		    blk->statements,
		    0,
		    static_init_smt
		);
	    }
	}
    }
    ctx->scopeptr = &blk->scope;
    origsymbol_list locals = collect_function_names( fn->parameters, 0 );
    if( oldwhere == CTX_OBJECT && !has_flags( fn->flags, ACC_STATIC ) ){
	ctx->where = CTX_DYNAMICROUTINE;
	this_sym = create_variable( "this", rdup_origin( fn->name->org ) );
	locals = append_origsymbol_list( locals, rdup_origsymbol( this_sym ) );
    }
    else {
	ctx->where = CTX_STATICROUTINE;
	this_sym = origsymbolNIL;
    }
    build_local_translations( ctx, locals );
    rfre_origsymbol_list( locals );
    FormalParameter_list this_parms = new_FormalParameter_list();

    if( this_sym != origsymbolNIL ){
	FormalParameter this_parm = new_FormalParameter(
	    this_sym,
	    new_Pragma_list(),
	    ACC_DEDUCED_FINAL,
	    new_ObjectType( add_origsymbol( ctx->owner ) )
	);
	this_parms = append_FormalParameter_list( this_parms, this_parm );
.call generate_descent_call "	" this_parms FormalParameter_list FormalParameter_list
    }
    register_FormalParameter_list( ctx->states, this_parms, true );
    ctx->rettype = fn->rettype;
.call generate_descent_call "	" ctx->rettype type type
.call generate_walker_call "    " fn FunctionDeclaration FunctionDeclaration

    Signature s = construct_Method_Signature( fn );
    mangled_name = translate_method( ctx, s );
    if( mangled_name == tmsymbolNIL ){
	tmstring snm = typename_Signature( s );

	internal_error( "cannot mangle method '%s'", snm );
    }
    else {
	tmsymbol_list noescapes = collect_noescapes( ctx->states, fn->parameters, this_parms );
	Pragma noescapes_pragma = build_noescapes_pragma( noescapes );
	Pragma_list pragmas;
	if( fn->pragmas == Pragma_listNIL ){
	    if( noescapes_pragma == PragmaNIL ){
		pragmas = Pragma_listNIL;
	    }
	    else {
	        pragmas = append_Pragma_list( new_Pragma_list(), noescapes_pragma );
	    }
	}
	else {
	    pragmas = rdup_Pragma_list( fn->pragmas );
	    if( noescapes_pragma != PragmaNIL ){
	        pragmas = append_Pragma_list( pragmas, noescapes_pragma );
	    }
	}
	FunctionEntry e = new_FunctionEntry(
	    mangled_name,
	    pragmas,
	    fn->flags,
	    ctx->owner,
	    ctx->packagename,
	    false,		// virtually used?
	    0,			// direct use count
	    false,		// overridden
	    s,
	    this_parms,
	    rdup_FormalParameter_list( fn->parameters ),
	    rdup_type_list( fn->throws ),
	    rdup_type( fn->rettype ),
	    noescapes,
	    ctx->retval,
	    rdup_Block( fn->body )
	);
	ctx->retval = AbstractValueNIL;
	fn->name->sym = mangled_name;
	ctx->symtab = add_symtab( ctx->symtab, e );
    }
    ctx->scopeptr = oldscope;
    ctx->where = oldwhere;
    ctx->rettype = old_rettype;
    delete_scopelevels( ctx, oldlevel );
    if( !completes_abruptly( ctx ) && fn->rettype->tag != TAGVoidType ){
        origin_error( fn->org, "A non-void function should return a value or always complete abruptly" ); 
    }
    return fn;
}

// Given the body of a constructor, convert it to a function body
// to implement the constructor. This means
// - Add a call to the dynamic initializer method of this class.
static Block build_constructor_implementation(
 mangle_data *ctx,
 tmsymbol t,			// For which type are we doing all this
 tmsymbol dynamic_init,		// dynamic init function of this type (if any)
 Block body
)
{
    if( dynamic_init != tmsymbolNIL ){
	// Generate:
	//    <dynamic_init>( this )
	//
	// But only when we do not invoke a 'this' constructor.
	if(
	    body->statements->sz == 0 ||
	    body->statements->arr[0]->tag != TAGThisConstructorInvocationStatement 
	){
	    statement smt = new_MethodInvocationStatement(
		gen_origin(),
		Pragma_listNIL,
		origsymbol_listNIL,	// Labels
		new_MethodInvocation(
		    expressionNIL,
		    add_origsymbol( dynamic_init ),
		    new_expression_list(),	// This parameters
		    new_expression_list(),	// Normal parameters
		    CALL_DYNAMICINIT
		)
	    );
	    if(
		body->statements->sz>0 &&
		body->statements->arr[0]->tag == TAGSuperConstructorInvocationStatement
	    ){
		// Put the initialization of our own variables after the 
		// invocation of the superclass constructor.
		body->statements = insert_statement_list( body->statements, 1, smt );
	    }
	    else {
		// This should only occur when there is no superclass.
		// In other words, when we are 'java.lang.Object'.
		body->statements = insert_statement_list( body->statements, 0, smt );
	    }
	}
    }
    statement static_init_smt = build_static_init_statement( ctx, t );
    if( static_init_smt != statementNIL ){
	body->statements = insert_statement_list( body->statements, 0, static_init_smt );
    }
    return body;
}

// Mangle action for a ConstructorDeclaration
static ConstructorDeclaration mangle_ConstructorDeclaration_action(
 ConstructorDeclaration fn,
 mangle_data *ctx
)
{
    Block blk = fn->body;
    tmsymbol *oldscope = ctx->scopeptr;
    int oldlevel = ctx->scopelevel;
    origsymbol_list locals;
    context oldwhere = ctx->where;

    (void) check_duplicate_FormalParameters( fn->parameters );
    // Continue, even if the above check failed.
    ctx->scopeptr = &blk->scope;
    ctx->where = CTX_CONSTRUCTOR;
    blk = build_constructor_implementation(
	ctx,
	ctx->owner,
	ctx->dynamic_init,
	blk
    );
    locals = collect_function_names( fn->parameters, 0 );
    origsymbol this_sym = create_variable(
	"this",
	rdup_origin( fn->name->org )
    );
    locals = append_origsymbol_list( locals, this_sym );
    FormalParameter_list this_parms = new_FormalParameter_list();
    FormalParameter this_parm = new_FormalParameter(
	create_variable( "this", rdup_origin( fn->name->org ) ),
	new_Pragma_list(),
	ACC_DEDUCED_FINAL,
	new_ObjectType( add_origsymbol( ctx->owner ) )
    );
    this_parms = append_FormalParameter_list( this_parms, this_parm );
    TypeEntry me = lookup_TypeEntry( ctx->typelist, ctx->owner );
    assert( is_ConcreteTypeEntry( me ) );
    ConcreteTypeEntry cte = to_ConcreteTypeEntry( me );
    if( has_any_flag( me->flags, ACC_LOCAL_OBJECT|ACC_MEMBER_OBJECT ) ){
	if( !has_any_flag( me->flags, ACC_STATIC ) ){
	    origsymbol outerthis_sym = create_variable( "outerthis", rdup_origin( fn->name->org ) );
	    locals = append_origsymbol_list( locals, outerthis_sym );
	    if( trace_innerclasses ){
		fprintf(
		    stderr,
		    "Class constructor for '%s' gets outer this field '%s'\n",
		    me->name->sym->name,
		    outerthis_sym->sym->name
		);
	    }
	    FormalParameter outerthis_parm = new_FormalParameter(
		create_variable( "outerthis", rdup_origin( fn->name->org ) ),
		new_Pragma_list(),
		ACC_DEDUCED_FINAL,
		new_ObjectType( add_origsymbol( cte->enclosingtype ) )
	    );
	    this_parms = append_FormalParameter_list( this_parms, outerthis_parm );

	    // Add a statement to the constructor body to initialize the outer
	    // this field of the class.
	    AssignStatement smt = new_AssignStatement(
		gen_origin(),
		Pragma_listNIL,
		new_origsymbol_list(),
		ASSIGN,
		new_VariableNameExpression( add_origsymbol( cte->outerthis ), VAR_THIS ),
		new_VariableNameExpression( rdup_origsymbol( outerthis_sym ), VAR_THIS|VAR_FINAL )
	    );
	    blk->statements = insert_statement_list( blk->statements, 0, smt );
	}

	if( me->tag == TAGClassEntry ){
	    // Also add the hidden parameters, if any, to the this parameter
	    // list and to the initialization code.
	    const_HiddenParameter_list hiddenparms = to_const_ClassEntry(me)->hiddenparms;
	    if( hiddenparms != NULL ){
		for( unsigned int ix=0; ix<hiddenparms->sz; ix++ ){
		    HiddenParameter p = hiddenparms->arr[ix];

		    this_parms = append_FormalParameter_list(
			this_parms,
			new_FormalParameter(
			    add_origsymbol( p->name ),
			    Pragma_listNIL,
			    0,
			    rdup_type( p->t )
			)
		    );
		    origsymbol nm = add_origsymbol( p->name );
		    locals = append_origsymbol_list( locals, nm );
		    origsymbol thisnm = rdup_origsymbol( nm );
		    thisnm->sym = qualify_tmsymbol( "this", thisnm->sym );
		    AssignStatement smt1 = new_AssignStatement(
			gen_origin(),
			Pragma_listNIL,
			new_origsymbol_list(),
			ASSIGN,
			new_VariableNameExpression( thisnm, 0 ),
			new_VariableNameExpression( rdup_origsymbol( nm ), 0 )
		    );
		    blk->statements = insert_statement_list( blk->statements, 0, smt1 );
		    if( trace_innerclasses ){
			fprintf(
			    stderr,
			    "Class constructor for '%s' gets hidden parameter '%s'\n",
			    me->name->sym->name,
			    nm->sym->name
			);
		    }
		}
	    }
	}
    }
    build_local_translations( ctx, locals );
    rfre_origsymbol_list( locals );
.call generate_descent_call "	" this_parms FormalParameter_list FormalParameter_list
    register_FormalParameter_list( ctx->states, this_parms, true );
    bool old_in_constructor = ctx->in_constructor;
    ctx->in_constructor = true;
.call generate_walker_call "    " fn ConstructorDeclaration ConstructorDeclaration
    ctx->in_constructor = old_in_constructor;
    Signature s = construct_Method_Signature( fn );
    tmsymbol mangled_name = translate_constructor( ctx, s );
    if( mangled_name == tmsymbolNIL ){
	tmstring snm = typename_Signature( s );

	internal_error( "cannot mangle constructor %s", snm );
    }
    else {
	tmsymbol_list noescapes = collect_noescapes( ctx->states, fn->parameters, this_parms );
	Pragma noescapes_pragma = build_noescapes_pragma( noescapes );
	Pragma_list pragmas;
	if( fn->pragmas == Pragma_listNIL ){
	    if( noescapes_pragma == PragmaNIL ){
		pragmas = Pragma_listNIL;
	    }
	    else {
	        pragmas = append_Pragma_list( new_Pragma_list(), noescapes_pragma );
	    }
	}
	else {
	    pragmas = rdup_Pragma_list( fn->pragmas );
	    if( noescapes_pragma != PragmaNIL ){
	        pragmas = append_Pragma_list( pragmas, noescapes_pragma );
	    }
	}
	FunctionEntry e = new_FunctionEntry(
	    mangled_name,
	    pragmas,
	    fn->flags,
	    ctx->owner,
	    ctx->packagename,
	    false,			// virtually used?
	    0,				// direct use count
	    false,			// overridden
	    s,
	    this_parms,
	    rdup_FormalParameter_list( fn->parameters ),
	    rdup_type_list( fn->throws ),
	    new_VoidType(),
	    noescapes,			// TODO: put in real noescapes.
	    AbstractValueNIL,		// Constructors are void functions.
	    rdup_Block( fn->body )
	);
	fn->name->sym = mangled_name;
	ctx->symtab = add_symtab( ctx->symtab, e );
    }
    ctx->scopeptr = oldscope;
    ctx->where = oldwhere;
    delete_scopelevels( ctx, oldlevel );
    return fn;
}

static VariableName mangle_VariableName_action( VariableName s, mangle_data *ctx )
{
    if( s == origsymbolNIL ){
	return s;
    }
    s->sym = mangle_variable_symbol( ctx, s->sym, s->org );
.call generate_walker_call "    " s VariableName VariableName
    return s;
}

/* Given a type, bind it by referring to the type mappings list. */
static origsymbol bind_type_origsymbol( mangle_data *ctx, const_origsymbol s )
{
    if( s == origsymbolNIL ){
	return origsymbolNIL;
    }
    tmsymbol trt = canonify_type(
	ctx->prog,
	ctx->packagename,
	ctx->owner,
	ctx->ondemands,
	&ctx->typebindings,
	s
    );
    if( trt == tmsymbolNIL ){
	origsymbol_error( s, "undefined type" );
	return origsymbolNIL;
    }
    origsymbol res = rdup_origsymbol( s );
    res->sym = trt;
    return res;
}

static TypeName mangle_TypeName_action( TypeName s, mangle_data *ctx )
{
    if( s == origsymbolNIL ){
	return s;
    }
.call generate_walker_call "    " s TypeName TypeName
    origsymbol res = bind_type_origsymbol( ctx, s );
    rfre_origsymbol( s );
    return res;
}

/* Mangle a 'Cardinality'. */
static Cardinality mangle_Cardinality_action( Cardinality t, mangle_data *ctx )
{
    tmsymbol nw = mangle_Cardinality_symbol( t->name->sym );
    origsymbol realname = rdup_origsymbol( t->name );

    ctx->scopelevel++;
    add_variable_translation( ctx, realname, nw, tmsymbolNIL );
.call generate_walker_call "    " t Cardinality Cardinality
    Entry e = new_CardinalityVariableEntry(
	rdup_tmsymbol( nw ),
	rdup_Pragma_list( t->pragmas ),
	0,		// flags
	ctx->owner,
	ctx->packagename,
	false,		// used?
	realname
    );
    ctx->symtab = add_symtab( ctx->symtab, e );
    register_cardinality( ctx, t );
    return t;
}

/* Mangle a 'ClassicForStatement'. */
static ClassicForStatement mangle_ClassicForStatement_action( ClassicForStatement smt, mangle_data *ctx )
{
    // Classic for statements should have been rewritten. We should
    // never come here.
    (void) ctx;
    (void) mangle_ClassicForStatement_walker;
    internal_error( "Classic for statement should have been rewritten" );
    /* NOTREACHED */
    return smt;
}

/* Mangle a 'TryStatement'. */
static TryStatement mangle_TryStatement_action( TryStatement t, mangle_data *ctx )
{
    push_programstate( ctx->states, false, "try" );
.call generate_walker_call "    " t TryStatement TryStatement
    pop_possibletrip_programstate( ctx->symtab, ctx->states, "try" );
    return t;
}

/* Given the list of caught exceptions of this try statement, see
 * if the null pointer exception or array bounds exception are caught,
 * since we'll then have to generate code to actually construct these
 * exceptions.
 */
static bool register_implicit_catches( mangle_data *ctx, const_type_list caught )
{
    if( nullptr_is_caught && boundviolation_is_caught ){
	// Don't bother to check, we're doomed anyway :-)
        return true;
    }
    tmsymbol nullexcept = add_tmsymbol( "java.lang.NullPointerException" );
    tmsymbol boundsexcept = add_tmsymbol( "java.lang.ArrayIndexOutOfBoundsException" );
    if(
        !visit_type( ctx->prog, originNIL, nullexcept ) ||
        !visit_type( ctx->prog, originNIL, boundsexcept )
    ){
        return false;
    }
    for( unsigned int ix=0; ix<caught->sz; ix++ ){
	TypeEntry te = lookup_TypeEntry( ctx->typelist, caught->arr[ix] );

	if( is_subclass( ctx->typelist, nullexcept, te ) ){
	    nullptr_is_caught = true;
	}
	if( is_subclass( ctx->typelist, boundsexcept, te ) ){
	    boundviolation_is_caught = true;
	}
    }
    return true;
}

/* Mangle a 'SimpleTryStatement'. */
static SimpleTryStatement mangle_SimpleTryStatement_action( SimpleTryStatement t, mangle_data *ctx )
{
    const int oldlevel = ctx->scopelevel++;

    // TODO: check that these exceptions are in fact caught.

    push_programstate( ctx->states, false, "simple try body" );
    build_local_translation( ctx, t->catchvar->name );
    // We write out the walker code, since we want to zap de static_init
    // list of the try block.
    (void)  mangle_SimpleTryStatement_walker;
.call generate_descent_call "    " t->pragmas Pragma_list Pragma_list
    tmsymbol *old_scopeptr = ctx->scopeptr;
    ctx->scopeptr = &t->catches->scope;
.call generate_descent_call "    " t->catchvar FormalParameter FormalParameter
    ctx->scopeptr = old_scopeptr;
    unsigned int old_allowed_level = ctx->allowed_throws->sz;
    register_allowed_throws( ctx, t->caught );
.call generate_descent_call "    " t->body Block Block
    zap_allowed_throws( ctx, old_allowed_level );
    ProgramState bodystate = extract_programstate( ctx->states );
    merge_possibletrip_programstate( ctx->symtab, ctx->states, bodystate, "simple try body" );
    push_programstate( ctx->states, false, "simple try catch block" );
    register_catch_variable( ctx->states, t->catchvar->name );
.call generate_descent_call "    " t->catches Block Block
    delete_scopelevels( ctx, oldlevel );
    bool exception_handlers_complete_abruptly = completes_abruptly( ctx );
    if( exception_handlers_complete_abruptly ){
	// Since the exception handlers complete abruptly, we know that
	// once we are past this try block no exception was caught by
	// a handler (or we wouldn't be there).
	// It is therefore safe to assume that all of the try block was
	// executed, and none of the exception handler block.
	pop_zerotrip_programstate( ctx->states, "simple try, abruptly completing catch block" );
	merge_onetrip_programstate( ctx->symtab, ctx->states, bodystate, "simple try, abruptly completing catch block" );
    }
    else {
	pop_possibletrip_programstate( ctx->symtab, ctx->states, "simple try catch block" );
    }
    rfre_ProgramState( bodystate );
    (void) register_implicit_catches( ctx, t->caught );
    return t;
}

// Mangle a 'Catch' clause.
static Catch mangle_Catch_action( Catch blk, mangle_data *ctx )
{
    origsymbol realname = rdup_origsymbol( blk->parm->name );
    tmsymbol nw = mangle_Cardinality_symbol( realname->sym );
    int oldlevel = ctx->scopelevel++;
    origin oldorg = ctx->org;

    ctx->org = blk->org;
    register_catch_variable( ctx->states, blk->parm->name );
    add_variable_translation( ctx, realname, nw, tmsymbolNIL );
.call generate_walker_call "    " blk Catch Catch
    delete_scopelevels( ctx, oldlevel );
    ctx->org = oldorg;
    return blk;
}

// Mangle a 'ClassExpression' clause.
static ClassExpression mangle_ClassExpression_action( ClassExpression x, mangle_data *ctx )
{
.call generate_walker_call "    " x ClassExpression ClassExpression
    (void) visit_type( ctx, x->t );
    return x;
}

// Mangle a 'ClassIdExpression' clause.
static ClassIdExpression mangle_ClassIdExpression_action( ClassIdExpression x, mangle_data *ctx )
{
.call generate_walker_call "    " x ClassIdExpression ClassIdExpression
    (void) visit_type( ctx->prog, x->cl );
    return x;
}

// Mangling action for an abstract function.
static AbstractFunctionDeclaration mangle_AbstractFunctionDeclaration_action(
    AbstractFunctionDeclaration fn,
    mangle_data *ctx
)
{
    const int oldlevel = ctx->scopelevel;
    tmsymbol *oldscope = ctx->scopeptr;
    context oldwhere = ctx->where;
    origsymbol this_sym = origsymbolNIL;

    if( !visit_type( ctx, fn->rettype ) ){
        rfre_type( fn->rettype );
	fn->rettype = typeNIL;
	return fn;
    }
    origsymbol_list locals = collect_function_names(
	fn->parameters,
	statement_listNIL
    );
    if( oldwhere == CTX_OBJECT && !has_any_flag( fn->flags, ACC_STATIC ) ){
	ctx->where = CTX_DYNAMICROUTINE;
	this_sym = create_variable( "this", rdup_origin( fn->name->org ) );
	locals = append_origsymbol_list( locals, rdup_origsymbol( this_sym ) );
    }
    else {
	ctx->where = CTX_STATICROUTINE;
    }
    Signature s = construct_Method_Signature( fn );
    tmsymbol mangled_name = translate_method( ctx, s );
    ctx->scopeptr = &mangled_name;
    build_local_translations( ctx, locals );
    rfre_origsymbol_list( locals );
    FormalParameter_list this_parms = new_FormalParameter_list();

    if( this_sym != origsymbolNIL ){
	this_parms = append_FormalParameter_list(
	    this_parms,
	    new_FormalParameter(
		this_sym,
		new_Pragma_list(),
		ACC_DEDUCED_FINAL,
		new_ObjectType( add_origsymbol( ctx->owner ) )
	    )
	);
.call generate_descent_call "	" this_parms FormalParameter_list FormalParameter_list
    }
.call generate_walker_call "    " fn AbstractFunctionDeclaration AbstractFunctionDeclaration
    Entry e = new_AbstractFunctionEntry(
	mangled_name,
	rdup_Pragma_list( fn->pragmas ),
	fn->flags,
	ctx->owner,
	ctx->packagename,
	false,			// virtually used?
	0,			// direct use count
	false,			// overridden
	s,
	this_parms,
	rdup_FormalParameter_list( fn->parameters ),
	rdup_type_list( fn->throws ),
	rdup_type( fn->rettype )
    );
    ctx->symtab = add_symtab( ctx->symtab, e );
    fn->name->sym = mangled_name;
    ctx->scopeptr = oldscope;
    ctx->where = oldwhere;
    delete_scopelevels( ctx, oldlevel );
    return fn;
}

static NativeFunctionDeclaration mangle_NativeFunctionDeclaration_action(
    NativeFunctionDeclaration fn,
    mangle_data *ctx
)
{
    const int oldlevel = ctx->scopelevel;
    tmsymbol *oldscope = ctx->scopeptr;
    context oldwhere = ctx->where;
    origsymbol this_sym = origsymbolNIL;

    if( !visit_type( ctx, fn->rettype ) ){
	rfre_type( fn->rettype );
        fn->rettype = typeNIL;
	return fn;
    }
    origsymbol_list locals = collect_function_names(
	fn->parameters,
	statement_listNIL
    );
    if( oldwhere == CTX_OBJECT && (fn->flags & ACC_STATIC) == 0 ){
	ctx->where = CTX_DYNAMICROUTINE;
	this_sym = create_variable( "this", rdup_origin( fn->name->org ) );
	locals = append_origsymbol_list( locals, rdup_origsymbol( this_sym ) );
    }
    else {
	ctx->where = CTX_STATICROUTINE;
    }
    Signature s = construct_Method_Signature( fn );
    tmsymbol mangled_name = translate_method( ctx, s );
    ctx->scopeptr = &mangled_name;
    build_local_translations( ctx, locals );
    rfre_origsymbol_list( locals );
    FormalParameter_list this_parms = new_FormalParameter_list();

    if( this_sym != origsymbolNIL ){
	this_parms = append_FormalParameter_list(
	    this_parms,
	    new_FormalParameter(
		this_sym,
		new_Pragma_list(),
		ACC_DEDUCED_FINAL,
		new_ObjectType( add_origsymbol( ctx->owner ) )
	    )
	);
.call generate_descent_call "	" this_parms FormalParameter_list FormalParameter_list
    }
.call generate_walker_call "    " fn NativeFunctionDeclaration NativeFunctionDeclaration
    Entry e = new_ExternalFunctionEntry(
	mangled_name,
	rdup_Pragma_list( fn->pragmas ),
	fn->flags,
	ctx->owner,
	ctx->packagename,
	false,			// virtually used
	0,			// direct use count
	false,			// overridden
	s,
	this_parms,
	rdup_FormalParameter_list( fn->parameters ),
	rdup_type_list( fn->throws ),
	rdup_type( fn->rettype )
    );
    ctx->symtab = add_symtab( ctx->symtab, e );
    fn->name->sym = mangled_name;
    ctx->scopeptr = oldscope;
    ctx->where = oldwhere;
    delete_scopelevels( ctx, oldlevel );
    return fn;
}

static SwitchStatement mangle_SwitchStatement_action( SwitchStatement smt, mangle_data *ctx )
{
    if( smt == SwitchStatementNIL ){
        return smt;
    }
    (void) mangle_SwitchStatement_walker;

.call generate_descent_call "    " smt->pragmas Pragma_list Pragma_list
.call generate_descent_call "    " smt->cond expression expression
    register_notnull_asserted( ctx );

    SwitchCase_list e = smt->cases;

    if( e != SwitchCase_listNIL ){
	bool did_default = false;

	push_programstate( ctx->states, false, "switch case completion admin. init" );
	for( unsigned int ix=0; ix<e->sz; ix++ ){
	    SwitchCase sc = e->arr[ix];
	    if( sc->tag == TAGSwitchCaseDefault ){
		if( did_default ){
		    origin_error( sc->org, "duplicate default: in switch statement" );
		}
		did_default = true;
	    }
	    else if( sc->tag == TAGSwitchCaseValue ){
		SwitchCaseValue sv = to_SwitchCaseValue(sc);
		// Note that the switch value is mangled twice. Normally
		// that's an error, but in this case the mangling should
		// result in a compile-time constant, which can safely be
		// mangled again.
.call generate_descent_call "		" sv->cond expression expression
		sv->cond = constant_fold_expression( sv->cond );
		if( !is_compiletime_constant( sv->cond, origsymbol_listNIL ) ){
		    origin_error( sc->org, "Switch case should evaluate to a compile-time constant" );
		    rfre_expression( sv->cond );
		    sv->cond = expressionNIL;
		}
		// TODO: make sure that the value is assignable to
		// t_switchval
	    }
	    pop_possibletrip_programstate( ctx->symtab, ctx->states, "previous switch case" );
	    push_programstate( ctx->states, false, "switch case" );
.call generate_descent_call "	    " e->arr[ix] SwitchCase SwitchCase
	}
	if( !did_default ){
	    // There was no 'default' in this switch, so act out the
	    // empty one.
	    pop_possibletrip_programstate( ctx->symtab, ctx->states, "switch default default:" );
	    push_programstate( ctx->states, false, "switch default default:" );
	}
    }
    pop_onetrip_programstate( ctx->symtab, ctx->states, "last switch case" );
    return smt;
}

static WaitCaseValue mangle_WaitCaseValue_action( WaitCaseValue c, mangle_data *ctx )
{
    expression x = rdup_expression( c->cond );
    bool old_in_typeof = ctx->in_typeof;
    ctx->in_typeof = true;
    const char *inf_name = "spar.channel.WaitableChannel";

.call generate_descent_call "		" x expression expression
    ctx->in_typeof = old_in_typeof;
    type t = derive_type_expression( ctx->symtab, x );
    rfre_expression( x );
    if(
        implements_interface( ctx->typelist, t, inf_name )
    ){
	// Rewrite the condition expression cond to cond.getHandle()
	c->cond = new_FieldInvocationExpression(
	    c->cond,
	    new_origsymbol( add_tmsymbol( "getHandle" ), rdup_origin( c->org ) ),
	    new_expression_list()
	);
    }
    else {
	tmstring tnm = typename_type( t );
        origin_error( c->org, "The wait statement can only wait for classes that implement %s, but %s does not", inf_name, tnm );
	rfre_tmstring( tnm );
    }
    rfre_type( t );
.call generate_walker_call "    " c WaitCaseValue WaitCaseValue
    return c;
}

static WaitCaseTimeout mangle_WaitCaseTimeout_action( WaitCaseTimeout c, mangle_data *ctx )
{
.call generate_walker_call "    " c WaitCaseTimeout WaitCaseTimeout
    return c;
}

static WaitStatement mangle_WaitStatement_action( WaitStatement smt, mangle_data *ctx )
{
    if( smt == WaitStatementNIL ){
        return smt;
    }
    (void) mangle_WaitStatement_walker;

.call generate_descent_call "    " smt->pragmas Pragma_list Pragma_list
    register_notnull_asserted( ctx );

    WaitCase_list e = smt->cases;

    if( e != WaitCase_listNIL ){
	// TODO: do analysis tailored for the wait statement.
	push_programstate( ctx->states, false, "wait case completion admin. init" );
	for( unsigned int ix=0; ix<e->sz; ix++ ){
	    pop_possibletrip_programstate( ctx->symtab, ctx->states, "previous wait case" );
	    push_programstate( ctx->states, false, "wait case" );
.call generate_descent_call "	    " e->arr[ix] WaitCase WaitCase
	}
    }
    pop_onetrip_programstate( ctx->symtab, ctx->states, "last wait case" );
    return smt;
}

static WhileStatement mangle_WhileStatement_action( WhileStatement smt, mangle_data *ctx )
{
    // We must replace the tree walker for the while() { } ourselves,
    // since we want to register that the condition is always evaluated
    // at least once.
    (void) mangle_WhileStatement_walker;
.call generate_descent_call "    " smt->pragmas Pragma_list Pragma_list
    tmsymbol_list changed = new_tmsymbol_list();
    bool invocations = false;
    collectassigned_Block( smt->body, &changed, &invocations );
    // TODO: see if the condition does a call.
    push_programstate( ctx->states, invocations, "while condition" );
    register_variables_loopchanged( ctx, changed );
.call generate_descent_call "    " smt->cond expression expression
    pop_multitrip_programstate( ctx->symtab, ctx->states, "while condition" );
    push_programstate( ctx->states, invocations, "while body & update" );
    register_variables_loopchanged( ctx, changed );
    // Within the while body, the condition must be true. This is useful
    // information for the analyzer.
    register_condition( ctx, smt->cond, true );
    rfre_tmsymbol_list( changed );
.call generate_descent_call "    " smt->body Block Block
    // TODO: do this more elegantly. This ensures that we don't get
    // complaints about unreachable code in the update code.
    register_jump_target( ctx->states );
.call generate_descent_call "    " smt->update statement_list statement_list
    pop_possibletrip_programstate( ctx->symtab, ctx->states, "while body & update" );
    if( is_false_constant( smt->cond ) ){
	origin_error( smt->org, "While body cannot be reached since its condition is false" );
    }
    if( is_true_constant( smt->cond ) ){
	// According to JLS2 14.20 a while can only complete normally if
	// the while condition is not constant true.
	register_cannot_complete_normally( ctx->states );
    }
    // TODO: handle continue correctly.
    if( smt->update != statement_listNIL ){
	smt->body->statements = concat_statement_list(
	    smt->body->statements,
	    smt->update
	);
	smt->update = statement_listNIL;
    }
    // After the while has been executed, the condition must be false.
    // This is useful information for the analyzer.
    register_condition( ctx, smt->cond, false );
    return smt;
}

static DoWhileStatement mangle_DoWhileStatement_action( DoWhileStatement smt, mangle_data *ctx )
{
    // We must replace the tree walker for the do { } while() ourselves,
    // since we must register that the body has executed once or more before
    // evaluating the condition expression.
    (void) mangle_DoWhileStatement_walker;
    if( smt == DoWhileStatementNIL ){
        return DoWhileStatementNIL;
    }
.call generate_descent_call "    " smt->pragmas Pragma_list Pragma_list
    tmsymbol_list changed = new_tmsymbol_list();
    bool invocations = false;
    collectassigned_Block( smt->body, &changed, &invocations );
    // TODO: see if the condition does a call.
    push_programstate( ctx->states, invocations, "do-while body & update" );
    register_variables_loopchanged( ctx, changed );
    rfre_tmsymbol_list( changed );

.call generate_descent_call "    " smt->body Block Block
    // TODO: do this more elegantly. This ensures that we don't get
    // complaints about unreachable code in the update code.
    register_jump_target( ctx->states );
.call generate_descent_call "    " smt->update statement_list statement_list

    // TODO: handle continue correctly.
    if( smt->update != statement_listNIL ){
	smt->body->statements = concat_statement_list(
	    smt->body->statements,
	    smt->update
	);
	smt->update = statement_listNIL;
    }
    // We know that a do..while is executed at least once.
    pop_multitrip_programstate( ctx->symtab, ctx->states, "do-while body & update" );
    push_programstate( ctx->states, invocations, "do-while condition" );
.call generate_descent_call "    " smt->cond expression expression
    pop_multitrip_programstate( ctx->symtab, ctx->states, "do-while condition" );
    if( is_true_constant( smt->cond ) ){
	// According to JLS2 14.20 a do can only complete normally if
	// the while condition is not constant true.
	register_cannot_complete_normally( ctx->states );
    }
    // After the do while body has completed, the condition must be false.
    // This is useful information for the analyzer.
    register_condition( ctx, smt->cond, false );
    return smt;
}

static bool is_commentout_condition( const_expression x )
{
    if( x->tag == TAGAnnotationExpression ){
        return is_commentout_condition( to_const_AnnotationExpression(x)->x );
    }
    if( x->tag == TAGBracketExpression ){
        return is_commentout_condition( to_const_BracketExpression(x)->x );
    }
    if( x->tag == TAGBooleanExpression ){
        return true;
    }
    if( x->tag == TAGVariableNameExpression ){
	// TODO: see if it refers to a compile-time constant.
        return true;
    }
    return false;
}

static statement mangle_IfStatement_action( IfStatement smt, mangle_data *ctx )
{
    statement res;

    (void) mangle_IfStatement_walker;
.call generate_descent_call "    " smt->pragmas Pragma_list Pragma_list
    bool is_commentout = is_commentout_condition( smt->cond );
.call generate_descent_call "    " smt->cond expression expression
    register_notnull_asserted( ctx );
    smt->cond = constant_fold_expression( smt->cond );
    if(
        smt->cond != expressionNIL &&
	smt->compileboth != true &&
	!is_commentout &&
	smt->cond->tag == TAGBooleanExpression
    ){
	// The condition is a constant, so we can do folding.
	vnus_boolean val = to_BooleanExpression( smt->cond )->b;
	rfre_expression( smt->cond );
	if( val ){
.call generate_descent_call "	    " smt->thenbody Block Block
	    res = new_BlockStatement(
		smt->org,
		smt->pragmas,
		smt->labels,
		smt->thenbody
	    );
	    rfre_Block( smt->elsebody );
	}
	else {
.call generate_descent_call "	    " smt->elsebody Block Block
	    res = new_BlockStatement(
		smt->org,
		smt->pragmas,
		smt->labels,
		smt->elsebody
	    );
	    rfre_Block( smt->thenbody );
	}
	fre_statement( smt );
    }
    else {
	// Condition is not a constant, we'll have to do the normal stuff.
	push_programstate( ctx->states, false, "if then branch" );
	register_condition( ctx, smt->cond, true );
.call generate_descent_call "	" smt->thenbody Block Block
	ProgramState thenst = extract_programstate( ctx->states );
	push_programstate( ctx->states, false, "if else branch" );
	register_condition( ctx, smt->cond, false );
.call generate_descent_call "	" smt->elsebody Block Block
	AFLAG then_taken = pop_thenelse_programstate( ctx->symtab, ctx->states, thenst, "if" );
	if( then_taken == AF_YES ){
	    register_condition( ctx, smt->cond, true );
	}
	if( then_taken == AF_NO ){
	    register_condition( ctx, smt->cond, false );
	}
	res = smt;
    }
    return res;
}

// Given a type 't' that is supposed to be a tuple type, extract
// the length of the tuple.
// Also check whether the elements of the tuple are sensible for
// use in a cardinality bound or stride.
static bool extract_cardinality_tuple_length(
 mangle_data *ctx,
 origsymbol nm,
 const type t,
 unsigned int *lp,
 const char *role
)
{
    bool ok = true;

    if( t->tag == TAGTupleType ){
	TupleType tt = to_TupleType(t);
	type_list vtl = tt->fields;

	for( unsigned int ix=0; ix<vtl->sz; ix++ ){
	    if( !is_numeric_type( ctx->symtab, vtl->arr[ix] ) ){
		origsymbol_error(
		    nm, 
		    "A cardinality %s requires a vector of numeric elements",
		    role
		);
		ok = false;
		break;
	    }
	}
	*lp = vtl->sz;
    }
    else if( t->tag == TAGVectorType ){
	VectorType vt = to_VectorType(t);

	if( !is_numeric_type( ctx->symtab, vt->elmtype ) ){
	    origsymbol_error(
		nm,
		"A cardinality %s requires a tuple with only numeric elements",
		role
	    );
	    ok = false;
	}
	ok = extract_vector_power( ctx->org, vt->power, lp );
    }
    else {
	internal_error( "Extracting from scalar cardinality?" );
    }
    return ok;
}

// Given a context 'ctx', a pointer to a list of cardinalities 'cards',
// an index 'ix' in 'cards', and a pointer to a list of spill declarations
// 'spill_decls', see if this cardinality ranges over a vector, and if so,
// replace it with a series of cardinalities over each of the elements
// of the vector. In that case, also add an initialized declaration to
// '*spill_decls' that reconstructs the iterator vector.
static void expand_Cardinality(
 mangle_data *ctx,
 Cardinality_list *cards,
 unsigned int ix,
 unsigned int *step,
 statement_list *spill_decls
)
{
    unsigned int power = 0;
    bool ok = true;
    Cardinality old_card = (*cards)->arr[ix];
    type t_lower;
    type t_upper;
    type t_stride;

    if( old_card->lowerbound != expressionNIL ){
	expression x = rdup_expression( old_card->lowerbound );
	bool old_in_typeof = ctx->in_typeof;
	ctx->in_typeof = true;
.call generate_descent_call "	" x expression expression
	ctx->in_typeof = old_in_typeof;
	t_lower = derive_type_expression( ctx->symtab, x );
	rfre_expression( x );
    }
    else {
	t_lower = typeNIL;
    }
    if( old_card->stride != expressionNIL ){
	expression x = rdup_expression( old_card->stride );
	bool old_in_typeof = ctx->in_typeof;
	ctx->in_typeof = true;
.call generate_descent_call "	" x expression expression
	ctx->in_typeof = old_in_typeof;
	t_stride = derive_type_expression( ctx->symtab, x );
	rfre_expression( x );
    }
    else {
	t_stride = typeNIL;
    }
    expression upperbound = rdup_expression( old_card->upperbound );
    bool old_in_typeof = ctx->in_typeof;
    ctx->in_typeof = true;
.call generate_descent_call "    " upperbound expression expression
    ctx->in_typeof = old_in_typeof;
    t_upper = derive_type_expression( ctx->symtab, upperbound );
    rfre_expression( upperbound );
    if( t_upper == typeNIL){
	return;
    }
    if( is_tuple_type( t_upper ) ){
	unsigned int p1;

	if( t_lower != typeNIL && !is_tuple_type( t_lower ) ){
	    origsymbol_error(
		old_card->name,
		"In a tuple cardinality, the lower bound must also be a tuple"
	    );
	    ok = false;
	}
	if( t_stride != typeNIL && !is_tuple_type( t_stride ) ){
	    origsymbol_error(
		old_card->name,
		"In a tuple cardinality, the stride must also be a tuple"
	    );
	    ok = false;
	}
	if( ok ){
	    ok = extract_cardinality_tuple_length(
		ctx,
		old_card->name,
		t_upper,
		&power,
		"upper bound"
	    );
	}
	if( ok && t_lower != typeNIL ){
	    ok = extract_cardinality_tuple_length(
		ctx,
		old_card->name,
		t_lower,
		&p1,
		"lower bound"
	    );
	    if( ok && p1 != power ){
		origsymbol_error(
		    old_card->name,
		    "Cardinality lower bound tuple is %u long, upper bound is %u long",
		    p1,
		    power
		);
		ok = false;
		
	    }
	}
	if( ok && t_stride != typeNIL ){
	    ok = extract_cardinality_tuple_length(
		ctx,
		old_card->name,
		t_stride,
		&p1,
		"stride"
	    );
	    if( ok && p1 != power ){
		origsymbol_error(
		    old_card->name,
		    "Cardinality stride is %u long, upper bound is %u long",
		    p1,
		    power
		);
		ok = false;
		
	    }
	}
    }
    else {
	if( t_lower != typeNIL && is_tuple_type( t_lower ) ){
	    origsymbol_error(
		old_card->name,
		"In a tuple cardinality, the upper bound must also be a tuple"
	    );
	}
	if( t_stride != typeNIL && is_tuple_type( t_stride ) ){
	    origsymbol_error(
		old_card->name,
		"In a tuple cardinality, the upper bound must also be a tuple"
	    );
	}
	rfre_type( t_lower );
	rfre_type( t_upper );
	rfre_type( t_stride );
.call generate_descent_call "	" (*cards)->arr[ix] Cardinality Cardinality
	return;
    }
    // If we manage to get to here, we have a tuple upper bound, and
    // if there is a lower bound and/or stride, it is also a tuple, and
    // has the same length.
    rfre_type( t_upper );
    if( ok ){
	// This is a vector cardinality of the right form.
	// Replace it with a series of scalar cardinalities, and
	// construct the original vector interator from these.
	Cardinality_list new_cards = new_Cardinality_list();
	expression_list vl = new_expression_list();
	for( unsigned int n=0; n<power; n++ ){
	    origsymbol nm = rdup_origsymbol( old_card->name );
	    nm->sym = gen_role_tmsymbol( nm, "veccard" );
	    expression lb = expressionNIL;
	    expression stride = expressionNIL;
	    if( t_lower != typeNIL ){
		lb = new_VectorSubscriptExpression(
		    rdup_expression( old_card->lowerbound ),
		    n
		);
	    }
	    if( t_stride != typeNIL ){
		stride = new_VectorSubscriptExpression(
		    rdup_expression( old_card->stride ),
		    n
		);
	    }

	    Cardinality new_card = new_Cardinality(
		rdup_origsymbol( nm ),
		rdup_Pragma_list( old_card->pragmas ),
		lb,
		new_VectorSubscriptExpression(
		    rdup_expression( old_card->upperbound ),
		    n
		),
		stride
	    );
.call generate_descent_call "	    " new_card Cardinality Cardinality
	    new_cards = append_Cardinality_list( new_cards, new_card );
	    vl = append_expression_list(
		vl,
		new_VariableNameExpression( nm, VAR_GENERATED|VAR_LOCAL|VAR_FINAL )
	    );
	}

	// Add a new initialized variable declaration to the
	// spilled declarations to reconstruct iteration variable.
	FieldDeclaration d = new_FieldDeclaration(
	    rdup_origin( old_card->name->org ),
	    Pragma_listNIL,
	    origsymbol_listNIL,		// Labels
	    ACC_FINAL,
	    false,			// used?
	    rdup_origsymbol( old_card->name ),
	    new_TypeOf( rdup_expression( old_card->upperbound ) ),
	    new_OptExpr( new_VectorExpression( vl ) )
	);
	(*spill_decls) = append_statement_list( (*spill_decls), d );

	// Add a mapping to the variable mappings table to translate
	// the reference to the vector iterator into a vector of
	// references to scalar iterators.
	VectorExpression vx = new_VectorExpression( rdup_expression_list( vl ) );
	VarMapping map = new_VarMapping(
	    old_card->name->sym,
	    vx,
	    ctx->scopelevel
	);
	ctx->var_mappings = append_VarMapping_list( ctx->var_mappings, map );

	// Now replace the old cardinality with the new ones.
	*step = new_cards->sz;
	(*cards) = delete_Cardinality_list( (*cards), ix );
	(*cards) = insertlist_Cardinality_list( (*cards), ix, new_cards );
    }
    rfre_type( t_lower );
    rfre_type( t_stride );
}

static void expand_Cardinality_list(
 mangle_data *ctx,
 Cardinality_list *cards,
 statement_list *spill_decls
)
{
    unsigned int ix = 0;
    unsigned int step;

    while( ix<(*cards)->sz ){
	step = 1;
	expand_Cardinality( ctx, cards, ix, &step, spill_decls );
	ix += step;
    }
}

static statement mangle_ForStatement_action( ForStatement smt, mangle_data *ctx )
{
    const int oldlevel = ctx->scopelevel;
    statement res;

    (void) mangle_ForStatement_walker;
    if( smt == ForStatementNIL ){
        return smt;
    }
.call generate_descent_call "    " smt->pragmas Pragma_list Pragma_list
    if( smt->inlined ){
	statement_list spill_decls = new_statement_list();
	expand_Cardinality_list( ctx, &smt->cards, &spill_decls );
	smt->body->statements = concat_statement_list( spill_decls, smt->body->statements );
	Block blk = unroll_for_body( ctx->symtab, smt->cards, smt->body );
	push_programstate( ctx->states, false, "inlined for" );
.call generate_descent_call "	" blk Block Block
	pop_onetrip_programstate( ctx->symtab, ctx->states, "inlined for" );
	res = new_BlockStatement(
	    rdup_origin( smt->org ),
	    rdup_Pragma_list( smt->pragmas ),
	    origsymbol_listNIL,	// Labels
	    blk
	);
	rfre_statement( smt );
    }
    else {
	statement_list spill_decls = new_statement_list();
	expand_Cardinality_list( ctx, &smt->cards, &spill_decls );
	register_notnull_asserted( ctx );
	tmsymbol_list changed = new_tmsymbol_list();
	bool invocations = false;
	collectassigned_Block( smt->body, &changed, &invocations );
	push_programstate( ctx->states, invocations, "for" );
	register_variables_loopchanged( ctx, changed );
	rfre_tmsymbol_list( changed );
	smt->body->statements = concat_statement_list( spill_decls, smt->body->statements );
.call generate_descent_call "	" smt->body Block Block
	if( pref_strictanalysis ){
	    pop_possibletrip_programstate( ctx->symtab, ctx->states, "for strict" );
	}
	else {
	    AFLAG zt = is_zerotrip_Cardinality_list( smt->cards );
	    if( zt == AF_YES ){
		pop_zerotrip_programstate( ctx->states, "zero trip for" );
	    }
	    else if( zt == AF_NO ){
		pop_multitrip_programstate( ctx->symtab, ctx->states, "for" );
	    }
	    else {
		pop_possibletrip_programstate( ctx->symtab, ctx->states, "for" );
	    }
	}
	res = smt;
    }
    delete_scopelevels( ctx, oldlevel );
    return res;
}

static ForeachStatement mangle_ForeachStatement_action( ForeachStatement smt, mangle_data *ctx )
{
    int oldlevel = ctx->scopelevel;

    (void) mangle_ForeachStatement_walker;
    if( smt == ForeachStatementNIL ){
        return smt;
    }
.call generate_descent_call "    " smt->pragmas Pragma_list Pragma_list
    statement_list spill_decls = new_statement_list();
    expand_Cardinality_list( ctx, &smt->cards, &spill_decls );
    register_notnull_asserted( ctx );
    smt->body->statements = concat_statement_list( spill_decls, smt->body->statements );
    bool invocations = false;
    tmsymbol_list changed = new_tmsymbol_list();
    collectassigned_Block( smt->body, &changed, &invocations );
    push_programstate( ctx->states, invocations, "foreach" );
    register_variables_loopchanged( ctx, changed );
    rfre_tmsymbol_list( changed );
.call generate_descent_call "    " smt->body Block Block
    delete_scopelevels( ctx, oldlevel );
    if( pref_strictanalysis ){
	pop_possibletrip_programstate( ctx->symtab, ctx->states, "foreach strict" );
    }
    else {
        AFLAG res = is_zerotrip_Cardinality_list( smt->cards );
	if( res == AF_YES ){
	    pop_zerotrip_programstate( ctx->states, "zero trip foreach" );
	}
	else if( res == AF_NO ){
	    pop_multitrip_programstate( ctx->symtab, ctx->states, "foreach" );
	}
	else {
	    pop_possibletrip_programstate( ctx->symtab, ctx->states, "foreach" );
	}
    }
    return smt;
}

// Given a statement, return true iff it is a valid target for an
// unlabeled break.
static bool is_break_target( statement smt )
{
    // See JLS2 14.14
    return (
	smt->tag == TAGSwitchStatement ||
	smt->tag == TAGWhileStatement ||
	smt->tag == TAGDoWhileStatement ||
	smt->tag == TAGForStatement ||
	smt->tag == TAGClassicForStatement ||
	smt->tag == TAGForeachStatement
    );
}

static statement mangle_BreakStatement_action( BreakStatement smt, mangle_data *ctx )
{
    statement res;
    jumpchain_element *e;

.call generate_walker_call "    " smt BreakStatement BreakStatement

    if( smt->target == origsymbolNIL ){
	e = ctx->jumpchain;
	while( e != NULL && !is_break_target( e->smt ) ){
	    e = e->next;
	}
	if( e == NULL ){
	    origin_error( smt->org, "'break' without label must be in a loop or switch statement" );
	    return smt;
	}
    }
    else {
	e = search_jumpchain( ctx->jumpchain, smt->target );
	if( e == NULL ){
	    origsymbol_error( smt->target, "Label not found" );
	    return smt;
	}
    }
    if( *(e->breaklabel) == origsymbolNIL ){
	*(e->breaklabel) = gen_origsymbol( "break" );
    }
    e->used_for_break = true;
    // We now know for sure that there is a break label
    res = new_GotoStatement(
	smt->org,
	smt->pragmas,
	smt->labels,
	rdup_origsymbol( *(e->breaklabel) )
    );
    register_jumps( ctx, e );
    rfre_origsymbol( smt->target );
    fre_statement( smt );
    return res;
}

// Given a statement, return true iff it is a valid continue target
static bool is_continue_target( statement smt )
{
    // See JLS2 14.15
    return (
	smt->tag == TAGWhileStatement ||
	smt->tag == TAGForStatement ||
	smt->tag == TAGForeachStatement ||
	smt->tag == TAGDoWhileStatement
    );
}

// Given a statement, place a label to jump to to implement a 'continue'
// of that statement.
static void label_statement_with_continue( statement csmt, origsymbol *lbl )
{
    origsymbol_list labels;

    switch( csmt->tag ){
	case TAGWhileStatement:
	{
	    WhileStatement wsmt = to_WhileStatement( csmt );

	    if( wsmt->update == statement_listNIL ){
		wsmt->update = new_statement_list();
	    }
	    if( wsmt->update->sz == 0 ){
		wsmt->update = append_statement_list(
		    wsmt->update,
		    new_EmptyStatement(
			gen_origin(),
			Pragma_listNIL,
			new_origsymbol_list()
		    )
		);
	    }
	    statement tsmt = wsmt->update->arr[0];
	    if( tsmt->labels == origsymbol_listNIL ){
		tsmt->labels = new_origsymbol_list();
	    }
	    labels = tsmt->labels;
	    break;
	}

	case TAGForStatement:
	{
	    ForStatement fsmt = to_ForStatement( csmt );
	    Block body = fsmt->body;

	    if( body->statements->sz == 0 || body->statements->arr[body->statements->sz-1]->tag != TAGEmptyStatement ){
		labels = new_origsymbol_list();
		body->statements = append_statement_list(
		    body->statements,
		    new_EmptyStatement(
			gen_origin(),
			Pragma_listNIL,
			labels
		    )
		);
	    }
	    else {
		statement esmt = body->statements->arr[body->statements->sz-1];
		if( esmt->labels == origsymbol_listNIL ){
		    esmt->labels = new_origsymbol_list();
		}
		labels = esmt->labels;
	    }
	    break;
	}

	case TAGForeachStatement:
	{
	    ForeachStatement fsmt = to_ForeachStatement( csmt );
	    Block body = fsmt->body;

	    if( body->statements->sz == 0 || body->statements->arr[body->statements->sz-1]->tag != TAGEmptyStatement ){
		labels = new_origsymbol_list();
		body->statements = append_statement_list(
		    body->statements,
		    new_EmptyStatement(
			gen_origin(),
			Pragma_listNIL,
			labels
		    )
		);
	    }
	    else {
		statement esmt = body->statements->arr[body->statements->sz-1];
		if( esmt->labels == origsymbol_listNIL ){
		    esmt->labels = new_origsymbol_list();
		}
		labels = esmt->labels;
	    }
	    break;
	}

	case TAGDoWhileStatement:
	{
	    DoWhileStatement wsmt = to_DoWhileStatement( csmt );

	    if( wsmt->update == statement_listNIL ){
		wsmt->update = new_statement_list();
	    }
	    if( wsmt->update->sz == 0 ){
		wsmt->update = append_statement_list(
		    wsmt->update,
		    new_EmptyStatement(
			gen_origin(),
			Pragma_listNIL,
			new_origsymbol_list()
		    )
		);
	    }
	    statement tsmt = wsmt->update->arr[0];
	    if( tsmt->labels == origsymbol_listNIL ){
		tsmt->labels = new_origsymbol_list();
	    }
	    labels = tsmt->labels;
	    break;
	}

	default:
	    labels = origsymbol_listNIL;
	    internal_error( "cannot label this statement for continue" );
    }
    if( labels->sz == 0 ){
	// The statement has no labels, so think up one
	labels = append_origsymbol_list(
	    labels,
	    gen_origsymbol( "continue" )
	);
    }
    *lbl = labels->arr[0];
}

static statement mangle_ContinueStatement_action( ContinueStatement smt, mangle_data *ctx )
{
    statement res;
    origsymbol the_label;

.call generate_walker_call "    " smt ContinueStatement ContinueStatement
    jumpchain_element *e = ctx->jumpchain;

    if( smt->target == origsymbolNIL ){
	while( e != NULL ){
	    if( is_continue_target( e->smt ) ){
		break;
	    }
	    e = e->next;
	}
	if( e == NULL ){
	    origin_error( smt->org, "A 'continue' must be in a loop" );
	    return smt;
	}
	label_statement_with_continue( e->smt, &the_label );
	// We now know for sure that 'csmt' has at least one label.
	res = new_GotoStatement(
	    smt->org,
	    smt->pragmas,
	    smt->labels,
	    rdup_origsymbol( the_label )
	);
    }
    else {
	e = search_jumpchain( ctx->jumpchain, smt->target );
	if( e == NULL ){
	    origsymbol_error( smt->target, "Label not found" );
	    return smt;
	}
	switch( e->smt->tag ){
	    case TAGForStatement:
	    case TAGForeachStatement:
	    case TAGWhileStatement:
	    case TAGDoWhileStatement:
		break;

	    default:
		origin_error(
		    smt->org,
		    "The label of a 'continue' statement must refer to a loop"
		);
		return smt;
	}
	label_statement_with_continue( e->smt, &the_label );
	res = new_GotoStatement(
	    smt->org,
	    smt->pragmas,
	    smt->labels,
	    rdup_origsymbol( the_label )
	);
	rfre_origsymbol( smt->target );
    }
    e->used_for_continue = true;
    register_jumps( ctx, (jumpchain_element *) NULL );
    fre_statement( smt );
    return res;
}

// Mangle a a FormalParameter.
static FormalParameter mangle_FormalParameter_action( FormalParameter arg, mangle_data *ctx )
{
    origsymbol realname = rdup_origsymbol( arg->name );

    if( *ctx->scopeptr == tmsymbolNIL ){
	*ctx->scopeptr = gen_tmsymbol( "scope" );
    }
.call generate_walker_call "    " arg FormalParameter FormalParameter
    FormalParameterEntry e = new_FormalParameterEntry(
	translate_variable( ctx, realname->sym ),
	rdup_Pragma_list( arg->pragmas ),
	arg->flags,
	ctx->owner,
	ctx->packagename,
	false,			// used?
	realname,
	rdup_tmsymbol( *ctx->scopeptr ),
	rdup_type( arg->t )
    );
    ctx->symtab = add_symtab( ctx->symtab, e );
    check_type_accessrights( ctx, arg->t );
    return arg;
}

#define IN_ROUTINE_CONTEXT(ctx) (((ctx)==CTX_STATICROUTINE)||((ctx)==CTX_DYNAMICROUTINE)||((ctx)==CTX_CONSTRUCTOR))

// Mangle a FieldDeclaration.
static FieldDeclaration mangle_FieldDeclaration_action( FieldDeclaration dcl, mangle_data *ctx )
{
    Entry e = EntryNIL;
    origsymbol realname = rdup_origsymbol( dcl->name );

    assert( ctx->where != CTX_OBJECT );
    (void) mangle_FieldDeclaration_walker;
    if( dcl == FieldDeclarationNIL ){
        return dcl;
    }
    if( IN_ROUTINE_CONTEXT( ctx->where ) ){
	build_local_translation( ctx, dcl->name );
    }
.call generate_descent_call "    " dcl->name VariableName VariableName
    ForwardFieldEntry fe = new_ForwardFieldEntry( 
	dcl->name->sym,
	rdup_Pragma_list( dcl->pragmas ),
	dcl->flags,
	ctx->owner,
	ctx->packagename,
	false,
	rdup_origsymbol( realname ),
	rdup_type( dcl->t )
    );
    ctx->symtab = add_symtab( ctx->symtab, fe );
    register_variable_declaration( ctx, dcl->name, has_final_flag( dcl->flags ) );
.call generate_descent_call "    " dcl->pragmas Pragma_list Pragma_list
.call generate_descent_call "    " dcl->t type type
    if( dcl->init->tag == TAGOptExpr ){
	expression init = to_OptExpr( dcl->init )->x;

	if( init->tag == TAGArrayInitExpression ){
	    AssignStatement smt = new_AssignStatement(
		rdup_origin( dcl->org ),
		Pragma_listNIL,
		origsymbol_listNIL,	// Labels
		ASSIGN,
		new_VariableNameExpression( rdup_origsymbol( realname ), 0 ),
		init
	    );
	    fre_optexpression( dcl->init );
	    dcl->init = new_OptExprNone();
	    ctx->post_spill_smts = append_statement_list( ctx->post_spill_smts, smt );
	}
    }
    if( IN_ROUTINE_CONTEXT( ctx->where ) ){
	// This is a local declaration. See if there are init expressions
	// with side-effects that must be shoved into an statement
	if( dcl->init->tag == TAGOptExpr ){
	    bool isconstant = false;

	    if( has_any_flag( dcl->flags, ACC_FINAL ) ){
		to_OptExpr(dcl->init)->x = derive_compiletime_constant(
		    ctx,
		    to_OptExpr(dcl->init)->x,
		    &isconstant
		);
		if( isconstant ){
		    // This declaration is a constant as per JLS2
		    dcl->flags |= ACC_COMPILECONSTANT;
		    if( trace_analysis ){
			fprintf(
			    stderr,
			    "Variable %s is a compile-time constant\n",
			    dcl->name->sym->name
			);
		    }
		}
	    }
	    expression init = to_OptExpr(dcl->init)->x;
	    // TODO: see if we can relax this test, and do breakout less often.
	    // try to add NO_SE_NEW?
	    if(
		!has_any_flag( dcl->flags, ACC_COMPILECONSTANT ) &&
		maybe_has_sideeffect( init, NO_SE_EXCEPTION )
	    ){
		fre_optexpression( dcl->init );
		dcl->init = new_OptExprNone();
		statement smt = new_AssignStatement(
		    rdup_origin( dcl->org ),
		    Pragma_listNIL,
		    origsymbol_listNIL,	// Labels
		    ASSIGN,
		    new_VariableNameExpression( rdup_origsymbol( realname ), VAR_LOCAL ),
		    init
		);
		ctx->post_spill_smts = append_statement_list(
		    ctx->post_spill_smts,
		    smt
		);
	    }
	}
    }
.call generate_descent_call "    " dcl->init optexpression optexpression
    if( has_flags( dcl->flags, ACC_FINAL ) ){
	if( dcl->init->tag == TAGOptExpr ){
	    expression init = rdup_expression( to_OptExpr(dcl->init)->x );

	    if( is_compiletime_constant( init, origsymbol_listNIL ) ){
		// This declaration is a constant as per JLS2
		dcl->flags |= ACC_COMPILECONSTANT;
		if( trace_analysis ){
		    fprintf(
			stderr,
			"Variable %s is a compile-time constant\n",
			dcl->name->sym->name
		    );
		}
	    }
	    rfre_expression( init );
	}
    }
    if( !visit_type( ctx, dcl->t ) ){
        rfre_type( dcl->t );
	dcl->t = typeNIL;
	return dcl;
    }
    check_type_accessrights( ctx, dcl->t );
    if( dcl->init->tag == TAGOptExpr ){
	OptExpr init = to_OptExpr( dcl->init );

	if( !is_vnusstring_type( dcl->t ) ){
	    type it = derive_type_expression( ctx->symtab, init->x );

	    if( is_vnusstring_type( it ) ){
		init->x = internalize_Vnus_string( ctx, init->x );
	    }
	    rfre_type( it );
	}
    }
    switch( ctx->where ){
	case CTX_GLOBAL:
	    // TODO: better test on side-effects (note that rewriting
	    // should have removed most side-effects; the only remaining
	    // side-effect is function calls.)
	    e = new_GlobalVariableEntry(
		dcl->name->sym,
		rdup_Pragma_list( dcl->pragmas ),
		dcl->flags,
		ctx->owner,
		ctx->packagename,
		false,
		realname,
		rdup_type( dcl->t ),
		rdup_optexpression( dcl->init )
	    );
	    break;

	case CTX_STATICROUTINE:
	case CTX_DYNAMICROUTINE:
	case CTX_CONSTRUCTOR:
	{
	    if( *ctx->scopeptr == tmsymbolNIL ){
		*ctx->scopeptr = gen_tmsymbol( "scope" );
	    }
	    // TODO: better test on side-effects (note that rewriting
	    // should have removed most side-effects; the only remaining
	    // side-effect is function calls.)
	    e = new_LocalVariableEntry(
		dcl->name->sym,
		rdup_Pragma_list( dcl->pragmas ),
		dcl->flags,
		ctx->owner,
		ctx->packagename,
		false,
		realname,
		rdup_tmsymbol( *ctx->scopeptr ),
		rdup_type( dcl->t ),
		rdup_optexpression( dcl->init )
	    );
	    if( dcl->init->tag == TAGOptExpr ){
		expression init = to_const_OptExpr(dcl->init)->x;

		// For the sake of data flow analysis, pretend that a variable
		// init is an assignment.
		// TODO: be smarter than this. If we know somehow that the
		// variable we're assigning from is never used again, we may
		// transfer its 'deletable' property to the new variable.
		register_escapes( ctx, init, "initialization" );
		register_variable_assignment( ctx, dcl->name, init );
	    }
	    break;
	}

	case CTX_STATICINIT:
	case CTX_DYNAMICINIT:
	case CTX_OBJECT:
	    internal_error( "object context??" );

    }
    ctx->symtab = add_symtab( ctx->symtab, e );
    return dcl;
}

/* Mangling action for a unary operator.
 * This implements JLS2 5.6.1
 */
static expression mangle_UnopExpression_action( UnopExpression x, mangle_data *ctx )
{
.call generate_walker_call "    " x UnopExpression UnopExpression

    return scalarize_UnopExpression( x, ctx );
}

// Forward declaration
static expression build_outer_this( 
    const_TypeEntry_list typelist,
    expression x,
    const_type from,
    tmsymbol to
);

// Given an expression 'x', the type of that expression 'from' and
// the type we want to reach 'to', construct a set of this field accesses
// that result in the correct expression to access fields of the 'to'
// type. It may be necessary to look at superclasses or outer classes
// of these superclasses (sigh).
//
// TODO: with sufficiently twisted superclass and inner class relations,
// it is possible to get stuck in a loop. Make sure this is indeed
// possible, and make sure we avoid this.
//
// TODO: clients of this function will have a memory leak for the
// case that expressionNIL is returned if they are not 
// careful. Moreover, they should at least produce an internal error.
static expression build_outer_this( 
    const_TypeEntry_list typelist,
    expression x,
    tmsymbol from,
    tmsymbol to
)
{
    expression res;
    if( from == to ){
	// That's the easy one.
	return x;
    }
    TypeEntry me = lookup_TypeEntry( typelist, from );
    assert( is_ObjectTypeEntry( me ) );
    ObjectTypeEntry cte = to_ObjectTypeEntry( me );
    if( cte->tag == TAGClassEntry && to_ClassEntry(cte)->super != typeNIL ){
	type super = to_ClassEntry( cte )->super;
	res = build_outer_this( typelist, x, super, to );
	// The recursion was able to reach the expression from the
	// superclass, so we're done.
	if( res != expressionNIL ){
	    return res;
	}
    }
    type_list interfaces = cte->interfaces;
    for( unsigned int ix=0; ix<interfaces->sz; ix++ ){
	res = build_outer_this( typelist, x, interfaces->arr[ix], to );
	// The recursion was able to reach the expression from the
	// superclass, so we're done.
	if( res != expressionNIL ){
	    return res;
	}
    }
    if( cte->enclosingtype == tmsymbolNIL ){
	return expressionNIL;
    }
    // Since reaching through the superclass didn't work, we try
    // reaching through an outer class.
    // The access expression follows the outer this of this object.
    FieldExpression x1 = new_FieldExpression( x, add_origsymbol( cte->outerthis ) );
    res = build_outer_this( typelist, x1, cte->enclosingtype, to );
    if( res != expressionNIL ){
	return res;
    }
    // The expression cannot be reached at all. First delete our
    // part of x1.
    x1->rec = expressionNIL;	// Not our priviledge to delete.
    rfre_expression( x1 );

    // We don't know how to reach that type.
    return expressionNIL;
}

static expression build_outer_this( 
    const_TypeEntry_list typelist,
    expression x,
    const_type from,
    tmsymbol to
)
{
    expression res = expressionNIL;

    switch( from->tag ){
	case TAGArrayType:
	case TAGExceptionVariableType:
	case TAGFunctionType:
	case TAGGCRefLinkType:
	case TAGGCTopRefLinkType:
	case TAGGenericObjectType:
	case TAGNullType:
	case TAGPrimArrayType:
	case TAGPrimitiveType:
	case TAGTupleType:
	case TAGTypeOf:
	case TAGTypeOfIf:
	case TAGTypeType:
	case TAGVectorType:
	case TAGVoidType:
	    internal_error( "unexpected type" );
	    break;


	case TAGPragmaType:
	    res = build_outer_this( typelist, x, to_const_PragmaType( from )->t, to );
	    break;

	case TAGObjectType:
	    res = build_outer_this( typelist, x, to_const_ObjectType( from )->name->sym, to );
	    break;

    }
    return res;
}

/* Mangling action for a unary operator.
 * This implements JLS2 5.6.1
 */
static expression mangle_OuterThisExpression_action( OuterThisExpression x, mangle_data *ctx )
{
.call generate_walker_call "    " x OuterThisExpression OuterThisExpression

    const_type t = x->t;
    assert( t->tag == TAGObjectType );
    tmsymbol targetname = to_const_ObjectType(t)->name->sym;
    expression res = new_VariableNameExpression(
	create_variable( "this", rdup_origin( ctx->org ) ),
	VAR_GENERATED|VAR_THIS
    );
    res = build_outer_this( ctx->typelist, res, ctx->owner, targetname );

    if( res == expressionNIL ){
       origin_error(
	   ctx->org,
	   "Type '%s' is not enclosed in type '%s'",
	   ctx->owner->name,
	   targetname->name
       );
    }
    rfre_expression( x );
.call generate_descent_call "    " res expression expression
    return res;
}

/* Mangling action for an if expression. IF one of the sides uses a vnus
 * string and the other does not, force a conversion of the Vnus string
 * through internalization.
 */
static expression mangle_IfExpression_action( IfExpression x, mangle_data *ctx )
{
    origin oldorg = ctx->org;
    ctx->org = x->org;

    (void) mangle_IfExpression_walker;
.call generate_descent_call "    " x->cond expression expression
    x->cond = constant_fold_expression( x->cond );
    if( x->cond->tag == TAGBooleanExpression ){
        // This if true ? x : y or false ? x : y
	// Treat them specially, since that is the simplest way to do
	// the special analysis required by Java, and we don't have
	// to do the complicated rewriting described below.
        vnus_boolean b = to_BooleanExpression(x->cond)->b;
	expression val;

	TypeOfIf t = new_TypeOfIf(
	    rdup_expression( x->thenval ),
	    rdup_expression( x->elseval ),
	    rdup_origin( x->org )
	);
	if( b ){
	    val = x->thenval;
	    x->thenval = expressionNIL;
	}
	else {
	    val = x->elseval;
	    x->elseval = expressionNIL;
	}
	CastExpression res = new_CastExpression( t, val );
	//dump_expression( stderr, res, "If expression rewritten to:" );
.call generate_descent_call "	" res CastExpression CastExpression
	//dump_expression( stderr, res, "mangled:" );
	ctx->org = oldorg;
	rfre_expression( x );
	return res;
    }
    if(
	!ctx->in_typeof && (
	    maybe_has_sideeffect( x->thenval, 0 ) ||
	    maybe_has_sideeffect( x->elseval, 0 )
	)
    ){
	// The evaluation of one of the branches of this ?: expression
	// has a side-effect. Since each branch is only evaluated
	// conditionally, the code has to be rewritten to an if statement.
	//
	// Concretely, an expression like this:
	//
	//     cond ? then : else
	//
	// is rewritten to the following spill code:
	//
	// <type> iftmp;
	// if( cond ){
	//     iftmp = then;
	// }
	// else {
	//     iftmp = else;
	// }
	// 
	// and the expression is replaced by
	//
	//    iftmp

	origsymbol nm = gen_origsymbol( "iftmp" );

	// Construct iftmp declaration.
	FieldDeclaration d = new_FieldDeclaration(
	    rdup_origin( x->org ),
	    Pragma_listNIL,
	    origsymbol_listNIL,	// Labels
	    0,
	    false,
	    rdup_origsymbol( nm ),
	    new_TypeOfIf(
		rdup_expression( x->thenval ),
		rdup_expression( x->elseval ),
		rdup_origin( x->org )
	    ),
	    new_OptExprNone()
	);
	context oldwhere = ctx->where;
	assert( oldwhere != CTX_GLOBAL && oldwhere != CTX_OBJECT );
	if( oldwhere == CTX_STATICINIT ){
	    ctx->where = CTX_STATICROUTINE;
	}
	else if( oldwhere == CTX_DYNAMICINIT ){
	    ctx->where = CTX_DYNAMICROUTINE;
	}
.call generate_descent_call "	" d FieldDeclaration FieldDeclaration
	ctx->breakout_declarations = append_statement_list( ctx->breakout_declarations, d );

	statement_list then_sl = new_statement_list();
	then_sl = append_statement_list(
	    then_sl,
	    new_AssignStatement(
		rdup_origin( ctx->org ),
		Pragma_listNIL,
		origsymbol_listNIL,	// Labels
		ASSIGN,
		new_VariableNameExpression(
		    rdup_origsymbol( nm ),
		    VAR_FINAL|VAR_GENERATED|VAR_LOCAL
		),
		x->thenval
	    )
	);

	statement_list else_sl = new_statement_list();
	else_sl = append_statement_list(
	    else_sl,
	    new_AssignStatement(
		rdup_origin( x->org ),
		Pragma_listNIL,
		origsymbol_listNIL,	// Labels
		ASSIGN,
		new_VariableNameExpression(
		    rdup_origsymbol( nm ),
		    VAR_FINAL|VAR_GENERATED|VAR_LOCAL
		),
		x->elseval
	    )
	);
	Block then_block = new_Block( tmsymbolNIL, Pragma_listNIL, then_sl );
	Block else_block = new_Block( tmsymbolNIL, Pragma_listNIL, else_sl );
	push_programstate( ctx->states, false, "if then branch" );
.call generate_descent_call "	" then_block Block Block
	ProgramState thenst = extract_programstate( ctx->states );
	push_programstate( ctx->states, false, "if else branch" );
.call generate_descent_call "	" else_block Block Block
	pop_thenelse_programstate( ctx->symtab, ctx->states, thenst, "if" );
	IfStatement is = new_IfStatement(
	    x->org,
	    Pragma_listNIL,
	    origsymbol_listNIL,	// Labels
	    true,		// Compile both
	    x->cond,
	    then_block,
	    else_block
	);
	ctx->where = oldwhere;
	ctx->mangled_pre_spill_smts = append_statement_list( 
	    ctx->mangled_pre_spill_smts,
	    is
	);
	//dump_statement( stderr, is, "If expression rewritten to" );
	VariableNameExpression vx = new_VariableNameExpression(
	    nm,
	    VAR_FINAL|VAR_GENERATED|VAR_LOCAL
	);
.call generate_descent_call "	" vx VariableNameExpression VariableNameExpression
	ctx->org = oldorg;
	fre_expression( x );
	return vx;
    }
    unsigned int null_level = getsize_notnull_asserted( ctx );

    // TODO: reset notnul_asserted list between mangling of if and then
    // expressions.
.call generate_descent_call "	" x->thenval expression expression
.call generate_descent_call "	" x->elseval expression expression
    type tthen = derive_type_expression( ctx->symtab, x->thenval );
    type telse = derive_type_expression( ctx->symtab, x->elseval );

    if( is_vnusstring_type( tthen ) && !is_vnusstring_type( telse ) ){
	x->thenval = internalize_Vnus_string( ctx, x->thenval );
    }
    if( !is_vnusstring_type( tthen ) && is_vnusstring_type( telse ) ){
	x->elseval = internalize_Vnus_string( ctx, x->elseval );
    }
    if( is_numeric_type( ctx->symtab, tthen ) && is_numeric_type( ctx->symtab, telse ) ){
        // This enforces part of JLS 15.25: if one branch is an int
	// constant that fits, and the other branch is a byte, short or
	// char, the entire expression is the small type.
	// To avoid confusion elsewhere, here we force the int constant
	// to the correct type.
	BASETYPE bt_then = get_BASETYPE( tthen );
	BASETYPE bt_else = get_BASETYPE( telse );
	if( x->elseval->tag == TAGIntExpression ){
	    vnus_int n = to_IntExpression(x->elseval)->v;

	    if( bt_then == BT_SHORT && n>=VNUS_SHORT_MIN && n<=VNUS_SHORT_MAX ){
		x->elseval = new_CastExpression( rdup_type( tthen ), x->elseval );
	    }
	    if( bt_then == BT_CHAR && n>=VNUS_CHAR_MIN && n<=VNUS_CHAR_MAX ){
		x->elseval = new_CastExpression( rdup_type( tthen ), x->elseval );
	    }
	    if( bt_then == BT_BYTE && n>=VNUS_BYTE_MIN && n<=VNUS_BYTE_MAX ){
		x->elseval = new_CastExpression( rdup_type( tthen ), x->elseval );
	    }
	}
	if( x->thenval->tag == TAGIntExpression ){
	    vnus_int n = to_IntExpression(x->thenval)->v;

	    if( bt_else == BT_SHORT && n>=VNUS_SHORT_MIN && n<=VNUS_SHORT_MAX ){
		x->thenval = new_CastExpression( rdup_type( telse ), x->thenval );
	    }
	    if( bt_else == BT_CHAR && n>=VNUS_CHAR_MIN && n<=VNUS_CHAR_MAX ){
		x->thenval = new_CastExpression( rdup_type( telse ), x->thenval );
	    }
	    if( bt_else == BT_BYTE && n>=VNUS_BYTE_MIN && n<=VNUS_BYTE_MAX ){
		x->thenval = new_CastExpression( rdup_type( telse ), x->thenval );
	    }
	}
	if( bt_then == BT_SHORT && bt_else == BT_BYTE ){
	    x->elseval = new_CastExpression( rdup_type( tthen ), x->elseval );
	}
	if( bt_then == BT_BYTE && bt_else == BT_SHORT ){
	    x->thenval = new_CastExpression( rdup_type( telse ), x->thenval );
	}
    }
    rfre_type( tthen );
    rfre_type( telse );
    // The variables may be null asserted in one of the branches, but
    // in both of them?
    // TODO: remember the notnull asserted that were in both branches.
    zapto_notnull_asserted( ctx, null_level );
    ctx->org = oldorg;
    return x;
}

/* Mangling action for a binary operator.
 * This implements JLS2 5.6.1 and 5.6.2, and forces a conversion
 * (internalization) if one of the operands is a Vnus string.
 */
static expression mangle_BinopExpression_action( BinopExpression x, mangle_data *ctx )
{
    bool left_is_constant = is_constant_unmangled_expression( ctx, x->left );
    bool right_is_constant = is_constant_unmangled_expression( ctx, x->right );
    if(
	(
	    maybe_has_sideeffect( x->left, NO_SE_EXCEPTION|NO_SE_NEW|NO_SE_CLASSINIT) &&
	    !right_is_constant
	) ||
	(
	    maybe_has_sideeffect( x->right, NO_SE_EXCEPTION|NO_SE_NEW|NO_SE_CLASSINIT) &&
	    !left_is_constant
	) 
    ){
	if( !left_is_constant ){
	    x->left = breakout_expression( ctx, x->left );
	}
	if( !right_is_constant ){
	    x->right = breakout_expression( ctx, x->right );
	}
    }
.call generate_walker_call "    " x BinopExpression BinopExpression
    return simplify_BinopExpression( x, ctx );
}

/* Mangling action for a shortcircuit operator.
 * This implements JLS2 5.6.1 and 5.6.2.
 */
static expression mangle_ShortopExpression_action( ShortopExpression x, mangle_data *ctx )
{
    unsigned int null_level = getsize_notnull_asserted( ctx );

.call generate_walker_call "    " x ShortopExpression ShortopExpression
    // The variables may be null asserted in a part of
    // the expression that is never evaluated.
    // TODO: use the fact that the lhs is always evaluated.
    zapto_notnull_asserted( ctx, null_level );
    return simplify_ShortopExpression( x, ctx );
}

/* Given a variable name 'var' and a field name 'field', return an expression
 * to access that field. For a reference to a static field this will be
 * an VariableNameExpression; for a reference to dynamic field this will be
 * an FieldExpression.
 */
static expression bind_variable_field(
 mangle_data *ctx,
 expression var,
 origsymbol fieldnm
)
{
    if( fieldnm == origsymbolNIL ){
	return expressionNIL;
    }
    type t = derive_type_expression( ctx->symtab, var );
    if( t == typeNIL ){
	if( !is_compilation_failure() ){
	    origsymbol_error(
		fieldnm,
		"don't know what type of element this field accesses"
	    );
	}
	return expressionNIL;
    }
    if( is_tuple_type( t ) ){
	if( strcmp( fieldnm->sym->name, "length" ) == 0 ){
	    unsigned int sz = 0;

	    if( !extract_tuple_length( ctx->org, t, &sz ) ){
		// The error message is generated in extract_tuple_length()
		// Just put in something to keep the compiler happy.
		sz = 0;
	    }
	    rfre_type( t );
	    return new_IntExpression( (vnus_int) sz );
	}
	else {
	    origin_error( fieldnm->org, "tuples do not have a field '%s'", fieldnm->sym->name );
	}
    }
    else if( t->tag == TAGArrayType ){
	if( strcmp( fieldnm->sym->name, "length" ) == 0 ){
	    rfre_type( t );
	    return new_GetLengthExpression(
		build_notnullassert( ctx, rdup_expression( var ) )
	    );
	}
	else {
	    origin_error( fieldnm->org, "arrays do not have a field '%s'", fieldnm->sym->name );
	}
    }
    else if( t->tag == TAGObjectType ){
	origsymbol cl = to_ObjectType( t )->name;

	// TODO: can this be defered?
	bool ok = visit_type( ctx->prog, cl );
	if( !ok ){
	    return expressionNIL;
	}
 	// The Java 1.1 language construct <classname>.class expresses
	// a reference to a java.lang.Class instance that describes
	// <classname>. The wording in the Java documentation suggest a
	// references to a unique, precomputed, instance, but for now
	// we simply construct a new instance on demand through the
	// new implementation-specific java.lang.Class constructor that
	// has the class id as parameter.
	if( strcmp( fieldnm->sym->name, "class" ) == 0 ){
	    expression res = new_NewClassExpression(
		expressionNIL,
		new_ObjectType( add_origsymbol( "java.lang.Class" ) ),
		append_expression_list(
		    new_expression_list(),
		    new_ClassIdExpression( rdup_origsymbol( cl ) )
		),
		statement_listNIL
	    );
	    return res;
	}
	const_VariableEntry field = bind_field(
	    ctx,
	    to_ObjectType( t )->name->sym,
	    ctx->owner,
	    fieldnm
	);
	if( field == VariableEntryNIL ){
	    origsymbol_error(
		fieldnm,
		"Unknown field in type '%s'",
		to_ObjectType( t )->name->sym->name
	    );
	    rfre_type( t );
	    return expressionNIL;
	}
	rfre_type( t );
	// Only treat this as a reference to a compile-time constant
	// if strictanalysis is off. JLS2 15.28 says that a *simple* name
	// or a <typename>.name that refers to a constant final expression
	// is a constant. So anything more complicated isn't, according
	// to the strict definition.
	if(
	    ctx->in_assign_lhs &&
	    has_any_flag( field->flags, ACC_FINAL ) &&
	    !is_initialization( get_init_expression( field ) )
	){
	    origsymbol_error( fieldnm, "A blank final field may only be assigned by a simple name" );
	}
	if(
	    !ctx->in_assign_lhs &&
	    !pref_strictanalysis &&
	    has_any_flag( field->flags, ACC_FINAL|ACC_DEDUCED_FINAL )

	){
	    const_expression init = get_init_expression( field );

	    if( init != expressionNIL && is_constant( init ) ){
		return new_CastExpression(
		    lookup_vartype( field ),
		    rdup_expression( init )
		);
	    }
	}
	if( has_any_flag( field->flags, ACC_STATIC ) ){
	    return new_VariableNameExpression(
		new_origsymbol( field->name, rdup_origin( fieldnm->org ) ),
		VAR_STATFIELD
	    );
	}
	else {
	    return new_FieldExpression(
		build_notnullassert( ctx, rdup_expression( var ) ),
		new_origsymbol( field->name, rdup_origin( fieldnm->org ) )
	    );
	}
    }

    tmstring tnm = typename_type( t );

    origin_error( fieldnm->org, "type '%s' does not have fields, so `.%s' is meaningless", tnm, fieldnm->sym->name );
    rfre_tmstring( tnm );
    rfre_type( t );
    return expressionNIL;
}

/* Given a field name 'field', return an expression to access 'super.field'.
 * For a reference to a static field this will be
 * an VariableNameExpression; for a reference to dynamic field this will be
 * an FieldExpression containing 'this'.
 *
 * 't' indicates relative to which type the super reference must be done.
 */
static expression bind_variable_superfield(
 mangle_data *ctx,
 const_origin org,
 const_origsymbol fieldnm,
 const_type t
)
{
    TypeEntry me;
    bool ok;

    if( t == typeNIL ){
	origsymbol where_type = new_origsymbol( ctx->owner, rdup_origin( fieldnm->org ) );
	me = lookup_TypeEntry( ctx->typelist, translate_type( ctx, where_type ) );
	rfre_origsymbol( where_type );
    }
    else {
	me = lookup_TypeEntry( ctx->typelist, t );
    }
    if( me == TypeEntryNIL ){
	return expressionNIL;
    }
    if( me->tag != TAGClassEntry ){
	origin_error(
	    org,
	    "'super' field reference only allowed within a class"
	);
	return expressionNIL;
    }
    ClassEntry my_class = to_ClassEntry( me );
    type super = my_class->super;
    if( super == typeNIL ){
	return expressionNIL;
    }
    if( super->tag != TAGObjectType ){
	internal_error( "Parameterized type should have been rewritten" );
    }
    origsymbol supernm = to_ObjectType(super)->name;
    ok = visit_type( ctx, super );
    if( !ok ){
	return expressionNIL;
    }
    ok = visit_type( ctx->prog, org, ctx->owner );
    if( !ok ){
	return expressionNIL;
    }
    const_VariableEntry field = bind_field(
	ctx,
	supernm->sym,
	ctx->owner,
	fieldnm
    );
    if( field == VariableEntryNIL ){
	origsymbol_error(
	    fieldnm,
	    "Unknown field in type '%s'",
	    supernm->sym->name
	);
	return expressionNIL;
    }
    if(
	!ctx->in_assign_lhs &&
	has_final_flag( field->flags )
    ){
	const_expression init = get_init_expression( field );

	if( init != expressionNIL && is_constant( init ) ){
	    return new_CastExpression(
		lookup_vartype( field ),
		rdup_expression( init )
	    );
	}
    }
    if( has_any_flag( field->flags, ACC_STATIC ) ){
	return new_VariableNameExpression(
	    new_origsymbol( field->name, rdup_origin( fieldnm->org ) ),
	   VAR_STATFIELD 
	);
    }
    expression th;
    if( t == typeNIL ){
	th = new_VariableNameExpression(
	    create_variable( "this", rdup_origin( org ) ),
	    VAR_GENERATED|VAR_THIS
	);
    }
    else {
	th = new_OuterThisExpression( rdup_type( t ) );
    }
.call generate_descent_call "    " th expression expression
    return new_FieldExpression(
	th,
	new_origsymbol( field->name, rdup_origin( fieldnm->org ) )
    );
}

/* Mangling action for a field access: qualify the field name. */
static expression mangle_FieldExpression_action( FieldExpression x, mangle_data *ctx )
{
    if( x == FieldExpressionNIL ){
	return x;
    }
    // We must break out 'rec', since its side-effects *must* be effected. If
    // we're not careful it is removed in a further pass without it being
    // evaluated.
    if( maybe_has_sideeffect( x->rec, NO_SE_ARRAY_NEW ) ){
	x->rec = breakout_expression( ctx, x->rec );
    }
.call generate_walker_call "    " x FieldExpression FieldExpression
    expression res = bind_variable_field( ctx, x->rec, x->field );
    if( res != expressionNIL ){
	rfre_expression( x );
	return res;
    }
    return x;
}

/* Mangling action for a field access: qualify the field name. */
static expression mangle_TypeFieldExpression_action( TypeFieldExpression x, mangle_data *ctx )
{
.call generate_walker_call "    " x TypeFieldExpression TypeFieldExpression
    expression res = bind_type_field( ctx, x->t, x->field );
    if( res != expressionNIL ){
	rfre_expression( x );
	return res;
    }
    return x;
}

/* Mangling action for a 'super' field access: qualify the field name. */
static expression mangle_SuperFieldExpression_action(
 SuperFieldExpression x,
 mangle_data *ctx
)
{
    origin oldorg = ctx->org;

.call generate_walker_call "    " x SuperFieldExpression SuperFieldExpression
    expression res = bind_variable_superfield( ctx, x->org, x->field, typeNIL );
    ctx->org = oldorg;
    if( res != expressionNIL ){
	rfre_expression( x );
	return res;
    }
    return x;
}

/* Mangling action for a 'super' field access: qualify the field name. */
static expression mangle_OuterSuperFieldExpression_action(
 OuterSuperFieldExpression x,
 mangle_data *ctx
)
{
.call generate_walker_call "    " x OuterSuperFieldExpression OuterSuperFieldExpression
    expression res = bind_variable_superfield( ctx, x->org, x->field, x->t );
    if( res != expressionNIL ){
	rfre_expression( x );
	return res;
    }
    return x;
}

/* Mangling action for a name expression: a qualified name may in fact
 * be a field reference.
 */
static expression mangle_VariableNameExpression_action(
 VariableNameExpression x,
 mangle_data *ctx
)
{
    unsigned int ix;

    if( search_VarMapping( ctx->var_mappings, x->name->sym, &ix ) ){
	// The variable mapping table has a mapping for this variable.
	expression to = rdup_expression( ctx->var_mappings->arr[ix]->to );
.call generate_descent_call "	" to expression expression
	if( to != expressionNIL && to->tag == TAGVariableNameExpression ){
	    to_VariableNameExpression(to)->flags |= x->flags;
	}
	rfre_expression( x );
	return to;
    }
    expression res = bind_variable( x->name, ctx );
    if( res != expressionNIL && res->tag == TAGVariableNameExpression ){
	to_VariableNameExpression(res)->flags |= x->flags;
    }
    rfre_expression( x );
    return res;
}

/* Given a type 't', representing the type of an expression, a method 'method'
 * and a pointer to a list of parameters 'parameters', return the symbol table
 * entry of the function to invoke.
 */
static MethodEntry bind_type_expression_method(
 mangle_data *ctx,
 const_ObjectType t,
 const_expression x,
 const_origsymbol method,
 expression_list *this_parameters,
 bool *use_static_call,
 expression_list *parameters
)
{
    origsymbol typenm = t->name;
    bool is_static;

    if( typenm == origsymbolNIL ){
        return MethodEntryNIL;
    }
    typenm->sym = translate_type( ctx, typenm );
    bool ok = visit_type( ctx->prog, typenm );
    if( !ok ){
	return MethodEntryNIL;
    }
    Signature s = new_Signature(
	0,
	method->sym,
	derive_type_expression_list( ctx->symtab, *parameters )
    );
    MethodEntry me = bind_Method(
	ctx->prog,
	ctx->symtab,
	ctx->typelist,
	typenm->sym,
	ctx->owner,
	s,
	&is_static,
	use_static_call,
	method->org
    );
    if( me == MethodEntryNIL ){
	return MethodEntryNIL;
    }
    if( !ctx->in_typeof ){
	visit_method( ctx->prog, &me, *use_static_call );
    }
    force_string_parameters( ctx, me, parameters, s->parameters );
    *parameters = force_type_MethodEntry( ctx, *parameters, me );
    rfre_Signature( s );
    register_method_throws( ctx->states, me->throws );
    if( !is_static ){
	expression th = rdup_expression( x );
	th = build_outer_this( ctx->typelist, th, t->name->sym, me->owner );
	if( th == expressionNIL ){
	   origin_error(
	       ctx->org,
	       "Type '%s' is not enclosed in type '%s'",
	       t->name->sym->name,
	       me->owner->name
	   );
	}
	*this_parameters = append_expression_list(
	    *this_parameters,
	    th
	);
    }
    return me;
}

// Given an expression 'x', a method 'method' and a pointer to a list of
// parameters 'parameters', return the symbol table entry of the
// function to invoke.
static MethodEntry bind_expression_method(
 mangle_data *ctx,
 const_expression x,
 const_origsymbol method,
 expression_list *this_parameters,
 bool *use_static_call,
 expression_list *parameters
)
{
    type ctype = derive_type_expression( ctx->symtab, x );

    if( ctype == typeNIL ){
	*use_static_call = true;
	return MethodEntryNIL;
    }
    if( is_vnusstring_type( ctype ) ){
	rfre_type( ctype );
	expression x1 = internalize_Vnus_string( ctx, rdup_expression( x ) );
	MethodEntry res = bind_expression_method(
	    ctx,
	    x1,
	    method,
	    this_parameters,
	    use_static_call,
	    parameters
	);
	rfre_expression( x1 );
	return res;
    }
    const_type cctype = clean_type( ctype );
    if( cctype->tag == TAGArrayType ){
	*use_static_call = true;

	rfre_type( ctype );
	if( strcmp( method->sym->name, "hashCode" ) == 0 ){
	    if( (*parameters)->sz > 0 ){
		origin_error(
		    method->org,
		    "the method hashCode() of an array does not have any parameters"
		);
		return MethodEntryNIL;
	    }
	    *this_parameters = append_expression_list(
		*this_parameters,
		rdup_expression( x )
	    );
	    return SPAR_ARRAYHASHCODE_METHODENTRY;
	}
	if( strcmp( method->sym->name, "getSize" ) == 0 ){
	    if( (*parameters)->sz > 1 ){
		origin_error(
		    method->org,
		    "the method getSize() is only supported in the forms getSize() and getSize(int)"
		);
		return MethodEntryNIL;
	    }
	    *this_parameters = append_expression_list(
		*this_parameters,
		rdup_expression( x )
	    );
	    if( (*parameters)->sz == 0 ){
		return SPAR_GETSIZEVECTOR_METHODENTRY;
	    }
	    else {
		return SPAR_GETSIZE_METHODENTRY;
	    }
	}
	else if( strcmp( method->sym->name, "clone" ) == 0 ){
	    if( (*parameters)->sz > 0 ){
		origin_error(
		    method->org,
		    "the method clone() of an array does not have any parameters"
		);
		return MethodEntryNIL;
	    }
	    *this_parameters = append_expression_list(
		*this_parameters,
		rdup_expression( x )
	    );
	    return SPAR_ARRAYCLONE_METHODENTRY;
	}
	else if( strcmp( method->sym->name, "toString" ) == 0 ){
	    if( (*parameters)->sz > 0 ){
		origin_error(
		    method->org,
		    "the method toString() of an array does not have any parameters"
		);
		return MethodEntryNIL;
	    }
	    *this_parameters = append_expression_list(
		*this_parameters,
		rdup_expression( x )
	    );
	    return SPAR_ARRAYTOSTRING_METHODENTRY;
	}
	origin_error(
	    method->org,
	    "arrays currently only support the methods getSize(int), getSize(), clone(), and toString()"
	);
	return MethodEntryNIL;
    }
    else if( cctype->tag != TAGObjectType ){
	origin_error( method->org, "only classes, interfaces and arrays have methods" );
	rfre_type( ctype );
	return MethodEntryNIL;
    }
    MethodEntry me = bind_type_expression_method(
	ctx,
	to_const_ObjectType(cctype),
	x,
	method,
	this_parameters,
	use_static_call,
	parameters
    );
    rfre_type( ctype );
    return me;
}

/* Given an origin 'org', a method 'method' and a pointer to a list of
 * parameters 'parameters', return the name of the function to invoke.
 */
static MethodEntry bind_super_method(
 mangle_data *ctx,
 const_origin org,
 const_origsymbol method,
 expression_list *this_parameters,
 expression_list *parameters,
 const_type t
)
{
    bool is_static;
    bool use_static_call;
    bool ok;

    TypeEntry te;

    if( t == typeNIL ){
	origsymbol where_type = new_origsymbol( ctx->owner, rdup_origin( org ) );
	te = lookup_TypeEntry( ctx->typelist, translate_type( ctx, where_type ) );
	rfre_origsymbol( where_type );
    }
    else {
	te = lookup_TypeEntry( ctx->typelist, t );
    }

    if( te == TypeEntryNIL ){
	return MethodEntryNIL;
    }
    if( te->tag != TAGClassEntry ){
	origin_error(
	    org,
	    "'super' method invocation only allowed within a class"
	);
	return MethodEntryNIL;
    }
    ClassEntry my_class = to_ClassEntry( te );
    type super = my_class->super;
    if( super == typeNIL ){
	return MethodEntryNIL;
    }
    if( super->tag != TAGObjectType ){
	origin_internal_error( org, "Parameterized type should have been rewritten" );
    }
    origsymbol supernm = to_ObjectType( super )->name;
    Signature s = new_Signature(
	0,
	method->sym,
	derive_type_expression_list( ctx->symtab, *parameters )
    );
    ok = visit_type( ctx->prog, org, ctx->owner );
    if( !ok ){
	return MethodEntryNIL;
    }
    ok = visit_type( ctx, super );
    if( !ok ){
	return MethodEntryNIL;
    }
    MethodEntry me = bind_Method(
	ctx->prog,
	ctx->symtab,
	ctx->typelist,
	supernm->sym,
	ctx->owner,
	s,
	&is_static,
	&use_static_call,
	org
    );
    if( me != MethodEntryNIL ){
	force_string_parameters( ctx, me, parameters, s->parameters );
	*parameters = force_type_MethodEntry( ctx, *parameters, me );
	if( !ctx->in_typeof ){
	    visit_method( ctx->prog, &me, true );
	}
	register_method_throws( ctx->states, me->throws );
    }
    rfre_Signature( s );
    if( !is_static && me != MethodEntryNIL ){
	if( ctx->where == CTX_STATICROUTINE ){
	    origsymbol_error(
		method,
		"Cannot make a static reference to an instance superclass method"
	    );
	    return MethodEntryNIL;
	}
	OuterThisExpression th = new_OuterThisExpression(
	    new_ObjectType( new_origsymbol( me->owner, rdup_origin( org ) ) )
	);
.call generate_descent_call "	    " th OuterThisExpression OuterThisExpression
	*this_parameters = append_expression_list(
	    *this_parameters,
	    th
	);
    }
    return me;
}

// Given a mangling context, a pointer to an expression 'vtab', a
// pointer to a method name 'nm' a pointer to an expression list
// 'this_parameters'
// and a pointer to an expression list 'parameters', return the symbol table
// entry of the function that binds an invocation
// with the name in '*nm', and the parameter list in '*parameters'.
// If no binding can be found, return NULL.
//
// Iff a binding can be found, assign the mangled name of the method
// to '*nm'. If a dynamic function is invoked, fill '*this_parameters' with
// the expressions that should serve as the this parameters, else leave it
// empty. If the invocation should use a virtual call mechanism, set
// '*vtab' to the class instance that has the virtual function table,
// else set this variable to NULL.
//
// The list of actual parameters in '*parameters' may be modified to
// implement parameter conversions. In particular, __string parameters
// are converted to String parameters.
static MethodEntry bind_method_invocation(
 mangle_data *ctx,
 expression *vtab,		// Who has the virtual table?
 const_origsymbol nm,
 expression_list *this_parameters,
 expression_list *parameters
)
{
    MethodEntry res = MethodEntryNIL;

    if( is_qualified_origsymbol( nm ) ){
	origsymbol first;
	origsymbol last;
	unsigned int pos;

	break_qualified_name( nm, &first, &last );
	if( search_VarTranslation( ctx->var_translations, first->sym, &pos ) ){
	    VariableNameExpression x = new_VariableNameExpression( first, 0 );
	    bool use_static_call;

.call generate_descent_call "	    " x VariableNameExpression VariableNameExpression
	    res = bind_expression_method( ctx, x, last, this_parameters, &use_static_call, parameters );
	    if( use_static_call ){
		*vtab = expressionNIL;
		*this_parameters = build_notnullassert( ctx, *this_parameters );
		rfre_expression( x );
	    }
	    else {
		*vtab = build_notnullassert( ctx, x );
	    }
	}
	else {
	    tmsymbol trt = canonify_type(
		ctx->prog,
		ctx->packagename,
		ctx->owner,
		ctx->ondemands,
		&ctx->typebindings,
		first
	    );
	    if( trt != tmsymbolNIL ){
		res = bind_type_method( ctx, first, last, parameters );
		rfre_origsymbol( first );
	    }
	    else {
		VariableNameExpression x = new_VariableNameExpression( first, 0 );
		bool use_static_call;

.call generate_descent_call "		" x VariableNameExpression VariableNameExpression
		res = bind_expression_method( ctx, x, last, this_parameters, &use_static_call, parameters );
		if( use_static_call ){
		    *vtab = expressionNIL;
		    *this_parameters = build_notnullassert( ctx, *this_parameters );
		    rfre_expression( x );
		}
		else {
		    *vtab = build_notnullassert( ctx, x );
		}
	    }
	}
	rfre_origsymbol( last );
    }
    else {
	unsigned int pos;
	tmsymbol thisnm = add_tmsymbol( "this" );

	// TODO: once we formally administrate static context, use that
	// instead of the search.
	if( search_VarTranslation( ctx->var_translations, thisnm, &pos ) ){
	    tmsymbol mangled_this = translate_variable( ctx, thisnm );
	    expression x = new_VariableNameExpression(
		new_origsymbol( mangled_this, rdup_origin( nm->org ) ),
		VAR_GENERATED|VAR_THIS
	    );
	    bool use_static_call;

	    res = bind_expression_method(
		ctx,
		x,
		nm,
		this_parameters,
		&use_static_call,
		parameters
	    );
	    if( use_static_call ){
		*vtab = expressionNIL;
		*this_parameters = build_notnullassert( ctx, *this_parameters );
		rfre_expression( x );
	    }
	    else {
		*vtab = build_notnullassert( ctx, x );
	    }
	}
	else {
	    // Can't be a reference to a 'this' method, so it must be a
	    // static method.
	    origsymbol package_type = add_origsymbol( ctx->owner );
	    res = bind_type_method(
		ctx,
		package_type,
		nm,
		parameters
	    );
	    rfre_origsymbol( package_type );
	}
    }
    return res;
}

/* Given a context, the fully qualified name of the type, and a list of
 * parameters, return the method that implements the constructor
 * of the given type with the given parameters.
 */
static MethodEntry implement_any_constructor_invocation(
 mangle_data *ctx,
 const_TypeEntry te,
 const_origin org,
 expression_list parameters,
 expression_list this_parameters,
 const_expression call_this,
 const_expression call_outerthis
)
{
    tmsymbol tnm = te->name->sym;
    tmsymbol callfrom_type = ctx->owner;
    Signature s = new_Signature(
	0,
	shortname( tnm ),
	derive_type_expression_list( ctx->symtab, parameters )
    );
    bool ok = visit_type( ctx->prog, te->name );
    if( !ok ){
	return MethodEntryNIL;
    }
    tmsymbol methodnm = bind_Constructor(
	ctx->prog,
	ctx->symtab,
	ctx->typelist,
	tnm,			/* Where to search the method. */
	callfrom_type,		/* Where are we calling from. */
	s,			/* What are we looking for */
	org
    );
    // bind_Constructor has already complained, so keep silent
    if( methodnm == tmsymbolNIL ){
	rfre_Signature( s );
	return MethodEntryNIL;
    }
    MethodEntry me = visit_constructor( ctx->prog, tnm, s, methodnm );
    if( me == MethodEntryNIL ){
	rfre_Signature( s );
	return me;
    }
    force_string_parameters( ctx, me, &parameters, s->parameters );
    parameters = force_type_MethodEntry( ctx, parameters, me );
    rfre_Signature( s );
    if( !check_invoked_throws( ctx, me->throws ) ){
	return MethodEntryNIL;
    }
    if( !is_ConcreteTypeEntry( te ) ){
	internal_error( "Forward type should have been rewritten" );
    }
    expression th;
    if( call_this == expressionNIL ){
	th = new_VariableNameExpression(
	    create_variable( "this", rdup_origin( org ) ),
	    VAR_GENERATED|VAR_THIS
	);
    }
    else {
	th = rdup_expression( call_this );
    }
    this_parameters = append_expression_list( this_parameters, th );
    if( has_any_flag( te->flags, ACC_LOCAL_OBJECT|ACC_MEMBER_OBJECT ) ){
	if( !has_any_flag( te->flags, ACC_STATIC ) ){
	    expression outerthis;
	    const_ConcreteTypeEntry cte = to_const_ConcreteTypeEntry( te );

	    if( trace_innerclasses ){
		fprintf(
		    stderr,
		    "Class constructor '%s' invocation gets outer this field\n",
		    me->name->name
		);
	    }
	    if( call_outerthis == expressionNIL ){
		// No outer this expression specified, so make up one:
		// <enclosingtype>.this
		//
		// TODO: see if this is exactly what is required.
		outerthis = new_OuterThisExpression(
		    new_ObjectType( add_origsymbol( cte->enclosingtype ) )
		);
	    }
	    else {
		outerthis = rdup_expression( call_outerthis );
		expression x = rdup_expression( call_outerthis );

		bool old_in_typeof = ctx->in_typeof;
		ctx->in_typeof = true;
.call generate_descent_call "		" x expression expression
		ctx->in_typeof = old_in_typeof;
		type t = derive_type_expression( ctx->symtab, x );
		if( t != typeNIL && t->tag != TAGObjectType ){
		    origin_error( org, "Outer this should be a reference type" );
		}
		rfre_expression( x );
		rfre_type( t );
	    }
	    this_parameters = append_expression_list( this_parameters, outerthis );
	}
	if( te->tag == TAGClassEntry ){
	    const_HiddenParameter_list hiddenparms = to_const_ClassEntry(te)->hiddenparms;
	    if( hiddenparms != NULL ){
		if( trace_innerclasses ){
		    fprintf(
			stderr,
			"Class constructor '%s' invocation gets %u hidden parameters\n",
			me->name->name,
			hiddenparms->sz
		    );
		}
		for( unsigned int ix=0; ix<hiddenparms->sz; ix++ ){
		    const_HiddenParameter parm = hiddenparms->arr[ix];
		    VariableNameExpression x = new_VariableNameExpression(
			add_origsymbol( parm->name ),
			VAR_FINAL
		    );
		    this_parameters = append_expression_list(
			this_parameters,
			x
		    );
		}
	    }
	}
    }
.call generate_descent_call "    " this_parameters expression_list expression_list
    return me;
}

/* Given a constructor invocation expression, return a new method
 * invocation expression containing the mangled name of the method
 * that implements this constructor.
 */
static statement implement_constructor_invocation(
 mangle_data *ctx,
 const_ConstructorInvocationStatement x
)
{
    type t = rdup_type( x->t );

.call generate_descent_call "    " t type type
    if( t == typeNIL ){
	return statementNIL;
    }
    if( t->tag == TAGGenericObjectType ){
	origin_internal_error( ctx->org, "Generic object type should have been rewritten" );
    }
    if( t->tag != TAGObjectType ){
	origin_internal_error( ctx->org, "Only classes have constructors to invoke" );
    }
    if( !visit_type( ctx, t ) ){
	rfre_type( t );
	return statementNIL;
    }
    const_origsymbol onm = to_const_ObjectType(t)->name;
    const_TypeEntry te = lookup_TypeEntry( ctx->typelist, onm );

    if( te == TypeEntryNIL ){
	rfre_type( t );
	return statementNIL;
    }

    expression_list parameters = rdup_expression_list( x->parameters );
.call generate_descent_call "    " parameters expression_list expression_list

    // Make sure the class we want to 'new' is not abstract.
    if( has_any_flag( te->flags, ACC_ABSTRACT ) ){
	origsymbol_error( onm, "An abstract class cannot be instantiated" );
	rfre_expression_list( parameters );
	rfre_type( t );
	return statementNIL;
    }

    expression_list this_parameters = new_expression_list();
    MethodEntry me = implement_any_constructor_invocation(
	ctx,
	te,
	onm->org,
	parameters,
	this_parameters,
	x->rec,
	x->outerthis
    );
    if( me == MethodEntryNIL ){
	rfre_expression_list( parameters );
	rfre_expression_list( this_parameters );
	rfre_type( t );
	return statementNIL;
    }
    register_actual_escapes( ctx, me, parameters, this_parameters );
    register_method_throws( ctx->states, me->throws );
    if(
	me->tag == TAGFunctionEntry &&
	ctx->expand_inlines &&
	has_flags( me->flags, ACC_INLINE )
    ){
	Block blk = expand_inlined_method(
	    ctx,
	    me,
	    ctx->org,
	    this_parameters,
	    parameters,
	    tmsymbolNIL
	);
	statement res = new_BlockStatement(
	    rdup_origin( x->org ),
	    rdup_Pragma_list( x->pragmas ),
	    origsymbol_listNIL,	// Labels
	    blk
	);
	rfre_expression_list( parameters );
	rfre_expression_list( this_parameters );
	rfre_type( t );
	return res;
    }
    statement res = new_MethodInvocationStatement(
	rdup_origin( x->org ),
	rdup_Pragma_list( x->pragmas ),
	origsymbol_listNIL,	// Labels
	new_MethodInvocation(
	    expressionNIL,
	    new_origsymbol( me->name, rdup_origin( onm->org ) ),
	    this_parameters,
	    parameters,
	    CALL_CONSTRUCTOR
	)
    );
    rfre_type( t );
    return res;
}

/* Given a 'super' constructor invocation statement, return a statement
 * containing an invocation of the mangled constructor.
 */
static statement implement_superconstructor_invocation(
    mangle_data *ctx,
    const_origin org,
    const_Pragma_list pragmas,
    const_expression_list original_parameters,
    const_expression outer
)
{
    const_TypeEntry te;

    if( outer == expressionNIL ){
	origsymbol where_type = new_origsymbol( ctx->owner, rdup_origin( org ) );
	te = lookup_TypeEntry( ctx->typelist, translate_type( ctx, where_type ) );
	rfre_origsymbol( where_type );
    }
    else {
	expression x = rdup_expression( outer );

	bool old_in_typeof = ctx->in_typeof;
	ctx->in_typeof = true;
.call generate_descent_call "	" x expression expression
	type t = derive_type_expression( ctx->symtab, x );
	ctx->in_typeof = old_in_typeof;
	rfre_expression( x );
	if( t == typeNIL ){
	    tmstring nm = name_expression( x );
	    origin_internal_error( org, "Cannot determine type of outer expression '%s'", nm );
	    rfre_tmstring( nm );
	    return statementNIL;
	}
	if( !visit_type( ctx, t ) ){
	    return statementNIL;
	}
	te = lookup_TypeEntry( ctx->typelist, t );
	rfre_type( t );
    }

    if( te == TypeEntryNIL ){
	return statementNIL;
    }
    if( te->tag != TAGClassEntry ){
	origin_error(
	    org,
	    "'super' constructor invocation only allowed within a class"
	);
	return statementNIL;
    }
    const_ClassEntry my_class = to_const_ClassEntry( te );
    if( my_class->super == typeNIL ){
	// This is class 'java.lang.Object'.
	origin_error( org, "Type java.lang.Object does not have a superclass" );
	return statementNIL;
    }
    if( !visit_type( ctx, my_class->super ) ){
	return statementNIL;
    }
    const_TypeEntry super_te = lookup_TypeEntry( ctx->typelist, my_class->super );
    expression_list parameters = rdup_expression_list( original_parameters );
.call generate_descent_call "    " parameters expression_list expression_list
    expression_list this_parameters = new_expression_list();

    MethodEntry res = implement_any_constructor_invocation(
	ctx,
	super_te,
	org,
	parameters,
	this_parameters,
	expressionNIL,
	outer		// Outer this expression
    );
    if( res == MethodEntryNIL ){
	rfre_expression_list( parameters );
	rfre_expression_list( this_parameters );
	return statementNIL;
    }
    register_actual_escapes( ctx, res, parameters, this_parameters );
    register_method_throws( ctx->states, res->throws );
    if(
	res->tag == TAGFunctionEntry &&
	ctx->expand_inlines &&
	has_flags( res->flags, ACC_INLINE )
    ){
	Block blk = expand_inlined_method(
	    ctx,
	    res,
	    ctx->org,
	    this_parameters,
	    parameters,
	    tmsymbolNIL
	);
	BlockStatement bsmt = new_BlockStatement(
	    rdup_origin( org ),
	    rdup_Pragma_list( pragmas ),
	    origsymbol_listNIL,		// Labels
	    blk
	);
	rfre_expression_list( this_parameters );
	rfre_expression_list( parameters );
	return bsmt;
    }
    else {
	return new_MethodInvocationStatement(
	    rdup_origin( org ),
	    rdup_Pragma_list( pragmas ),
	    origsymbol_listNIL,	// Labels
	    new_MethodInvocation(
		expressionNIL,
		new_origsymbol( res->name, rdup_origin( org ) ),
		this_parameters,
		parameters,
		CALL_CONSTRUCTOR
	    )
	);
    }
}

/* Given a 'this' constructor invocation statement, return a statement
 * containing an invocation of the mangled constructor.
 */
static statement implement_thisconstructor_invocation(
    mangle_data *ctx,
    const_ThisConstructorInvocationStatement x
)
{
    origsymbol where_type = new_origsymbol( ctx->owner, rdup_origin( x->org ) );
    TypeEntry te = lookup_TypeEntry( ctx->typelist, translate_type( ctx, where_type ) );
    rfre_origsymbol( where_type );

    if( te == TypeEntryNIL ){
	return statementNIL;
    }
    if( te->tag != TAGClassEntry ){
	origin_error(
	    x->org,
	    "'this' constructor reference only allowed within a class"
	);
	return statementNIL;
    }
    expression_list parameters = rdup_expression_list( x->parameters );
.call generate_descent_call "    " parameters expression_list expression_list
    expression_list this_parameters = new_expression_list();
    MethodEntry res = implement_any_constructor_invocation(
	ctx,
	te,
	x->org,
	parameters,
	this_parameters,
	expressionNIL,
	expressionNIL		// Outer this expression
    );
    if( res == MethodEntryNIL ){
	rfre_expression_list( parameters );
	rfre_expression_list( this_parameters );
	return statementNIL;
    }
    register_actual_escapes( ctx, res, parameters, this_parameters );
    register_method_throws( ctx->states, res->throws );
    if(
	res->tag == TAGFunctionEntry &&
	ctx->expand_inlines &&
	has_flags( res->flags, ACC_INLINE )
    ){
	Block blk = expand_inlined_method(
	    ctx,
	    res,
	    ctx->org,
	    this_parameters,
	    parameters,
	    tmsymbolNIL
	);
	BlockStatement bsmt = new_BlockStatement(
	    rdup_origin( x->org ),
	    rdup_Pragma_list( x->pragmas ),
	    origsymbol_listNIL,		// Labels
	    blk
	);
	rfre_expression_list( this_parameters );
	rfre_expression_list( parameters );
	return bsmt;
    }
    else {
	return new_MethodInvocationStatement(
	    rdup_origin( x->org ),
	    rdup_Pragma_list( x->pragmas ),
	    origsymbol_listNIL,		// Labels
	    new_MethodInvocation(
		expressionNIL,
		new_origsymbol( res->name, rdup_origin( x->org ) ),
		this_parameters,
		parameters,
		CALL_CONSTRUCTOR
	    )
	);
    }
}

static statement mangle_MethodInvocationStatement_action( MethodInvocationStatement smt, mangle_data *ctx )
{
.call generate_walker_call "    " smt MethodInvocationStatement MethodInvocationStatement
    MethodInvocation invocation = smt->invocation;
    MethodEntry me = bind_method_invocation(
	ctx,
	&invocation->vtab,
	invocation->name,
	&invocation->thisparameters,
	&invocation->parameters
    );
    if( me == MethodEntryNIL ){
	return smt;
    }
    if( is_special_method( me ) ){
	statement res = construct_special_method_statement(
	    ctx,
	    smt->pragmas,
	    me
	);
	rfre_statement( smt );
	return res;
    }
    if( !check_invoked_throws( ctx, me->throws ) ){
	return smt;
    }
    invocation->thisparameters = build_notnullassert( ctx, invocation->thisparameters );
    register_actual_escapes(
	ctx,
	me,
	invocation->parameters,
	invocation->thisparameters
    );
    register_method_throws( ctx->states, me->throws );
    if(
        me->tag == TAGFunctionEntry &&
	invocation->vtab == NULL &&
	ctx->expand_inlines &&
	has_flags( me->flags, ACC_INLINE )
    ){
	Block blk = expand_inlined_method(
	    ctx,
	    me,
	    smt->org,
	    invocation->thisparameters,
	    invocation->parameters,
	    tmsymbolNIL
	);
	BlockStatement res = new_BlockStatement(
	    rdup_origin( smt->org ),
	    rdup_Pragma_list( smt->pragmas ),
	    origsymbol_listNIL,		// Labels
	    blk
	);
	rfre_statement( smt );
	return res;
    }
    else {
	invocation->name->sym = me->name;
	if( !is_void_type( me->t ) ){
	    if( warn_ignoredvalue ){
		origin_warning( smt->org, "returned value is ignored" );
	    }
	    // TODO: do something smart for inlining
	    expression x = new_MethodInvocationExpression( invocation );
	    ExpressionStatement res = new_ExpressionStatement(
		smt->org,
		smt->pragmas,
		smt->labels,
		x
	    );
	    fre_statement( smt );
	    return res;
	}
    }
    return smt;
}

static expression mangle_MethodInvocationExpression_action(
 MethodInvocationExpression x,
 mangle_data *ctx
)
{
.call generate_walker_call "    " x MethodInvocationExpression MethodInvocationExpression
    MethodEntry me = bind_method_invocation(
	ctx,
	&x->invocation->vtab,
	x->invocation->name,
	&x->invocation->thisparameters,
	&x->invocation->parameters
    );
    if( me == MethodEntryNIL ){
	return x;
    }
    if( is_special_method( me ) ){
	expression res = construct_special_method_expression(
	    ctx,
	    me,
	    x->invocation->thisparameters,
	    x->invocation->parameters
	);
	rfre_expression( x );
	return res;
    }
    if( !check_invoked_throws( ctx, me->throws ) ){
	return x;
    }
    bool direct_call = x->invocation->vtab == NULL;
    register_actual_escapes(
	ctx,
	me,
	x->invocation->parameters,
	x->invocation->thisparameters
    );
    register_method_throws( ctx->states, me->throws );
    if(
	ctx->expand_inlines &&
	direct_call &&
	!ctx->in_typeof &&
	me->tag == TAGFunctionEntry &&
	has_flags( me->flags, ACC_INLINE )
    ){
	x->invocation->thisparameters = build_notnullassert(
	    ctx,
	    x->invocation->thisparameters
	);
	expression mx = expand_inlined_expression(
	    ctx,
	    me,
	    ctx->org,
	    x->invocation->thisparameters,
	    x->invocation->parameters,
	    false
	);
	rfre_expression( x );
	return mx;
    }
    x->invocation->name->sym = me->name;
    return x;
}

static statement mangle_SuperConstructorInvocationStatement_action( SuperConstructorInvocationStatement x, mangle_data *ctx )
{
    (void) mangle_SuperConstructorInvocationStatement_walker;
    statement res = implement_superconstructor_invocation( ctx, x->org, x->pragmas, x->parameters, expressionNIL );
    rfre_statement( x );
    return res;
}

static statement mangle_OuterSuperConstructorInvocationStatement_action( OuterSuperConstructorInvocationStatement x, mangle_data *ctx )
{
    (void) mangle_OuterSuperConstructorInvocationStatement_walker;
    statement res = implement_superconstructor_invocation( ctx, x->org, x->pragmas, x->parameters, x->outer );
    rfre_statement( x );
    return res;
}

static statement mangle_ThisConstructorInvocationStatement_action( ThisConstructorInvocationStatement x, mangle_data *ctx )
{
    (void) mangle_ThisConstructorInvocationStatement_walker;
    statement res = implement_thisconstructor_invocation( ctx, x );
    rfre_statement( x );
    return res;
}

static statement mangle_ConstructorInvocationStatement_action(
 ConstructorInvocationStatement x,
 mangle_data *ctx
)
{
    (void) mangle_ConstructorInvocationStatement_walker;
    statement res = implement_constructor_invocation( ctx, x );
    rfre_statement( x );
    return res;
}

static expression mangle_GetLengthExpression_action(
 GetLengthExpression x,
 mangle_data *ctx
)
{
.call generate_walker_call "    " x GetLengthExpression GetLengthExpression
    type t = derive_type_expression( ctx->symtab, x->array );
    if( is_tuple_type( t ) ){
	unsigned int sz = 0;

	if( !extract_tuple_length( ctx->org, t, &sz ) ){
	    // The error message is generated in extract_tuple_length()
	    // Just put in something to keep the compiler happy.
	    sz = 0;
	}
	rfre_type( t );
	rfre_expression( x );
	return new_IntExpression( (vnus_int) sz );
    }
    rfre_type( t );
    return x;
}

static expression mangle_SuperInvocationExpression_action( SuperInvocationExpression x, mangle_data *ctx )
{
    expression_list this_parameters = new_expression_list();
    origin oldorg = ctx->org;

.call generate_walker_call "    " x SuperInvocationExpression SuperInvocationExpression
    ctx->org = oldorg;
    expression_list parameters = rdup_expression_list( x->parameters );
    MethodEntry me = bind_super_method( ctx, x->org, x->field, &this_parameters, &parameters, typeNIL );
    if( me == MethodEntryNIL ){
	rfre_expression( x );
	return expressionNIL;
    }
    expression res;
    register_actual_escapes( ctx, me, parameters, this_parameters );
    register_method_throws( ctx->states, me->throws );
    if( ctx->expand_inlines && has_flags( me->flags, ACC_INLINE ) ){
	// TODO: Super invocations use the 'this' of a method, so it cannot
	// possibly be null.
	res = expand_inlined_expression(
	    ctx,
	    me,
	    x->org,
	    this_parameters,
	    parameters,
	    false
	);
	rfre_expression_list( this_parameters );
	rfre_expression_list( parameters );
    }
    else {
	res = new_MethodInvocationExpression(
	    new_MethodInvocation(
		expressionNIL,
		new_origsymbol( me->name, rdup_origin( x->field->org ) ),
		this_parameters,
		parameters,
		0
	    )
	);
    }
    rfre_expression( x );
    return res;
}

static expression mangle_OuterSuperInvocationExpression_action( OuterSuperInvocationExpression x, mangle_data *ctx )
{
    expression_list this_parameters = new_expression_list();

.call generate_walker_call "    " x OuterSuperInvocationExpression OuterSuperInvocationExpression
    expression_list parameters = rdup_expression_list( x->parameters );
    MethodEntry me = bind_super_method( ctx, x->org, x->field, &this_parameters, &parameters, x->t );
    if( me == MethodEntryNIL ){
	rfre_expression( x );
	return expressionNIL;
    }
    expression res;
    register_actual_escapes( ctx, me, parameters, this_parameters );
    register_method_throws( ctx->states, me->throws );
    if( ctx->expand_inlines && has_flags( me->flags, ACC_INLINE ) ){
	// TODO: OuterSuper invocations use the 'this' of a method, so it
	// cannot possibly be null.
	res = expand_inlined_expression(
	    ctx,
	    me,
	    ctx->org,
	    this_parameters,
	    parameters,
	    false
	);
	rfre_expression_list( this_parameters );
	rfre_expression_list( parameters );
    }
    else {
	res = new_MethodInvocationExpression(
	    new_MethodInvocation(
		expressionNIL,
		new_origsymbol( me->name, rdup_origin( x->field->org ) ),
		this_parameters,
		parameters,
		0
	    )
	);
    }
    rfre_expression( x );
    return res;
}

static expression mangle_TypeInvocationExpression_action( TypeInvocationExpression x, mangle_data *ctx )
{

.call generate_walker_call "    " x TypeInvocationExpression TypeInvocationExpression
    expression_list parameters = rdup_expression_list( x->parameters );
    MethodEntry me = bind_type_method( ctx, x->t, x->field, &x->parameters );
    if( me == MethodEntryNIL ){
	return x;
    }
    expression res;
    register_actual_escapes( ctx, me, parameters, expression_listNIL );
    register_method_throws( ctx->states, me->throws );
    expression_list this_parameters = new_expression_list();
    if( ctx->expand_inlines && has_flags( me->flags, ACC_INLINE ) ){
	res = expand_inlined_expression(
	    ctx,
	    me,
	    ctx->org,
	    this_parameters,
	    parameters,
	    false
	);
	rfre_expression_list( this_parameters );
	rfre_expression_list( parameters );
    }
    else {
	res = new_MethodInvocationExpression(
	    new_MethodInvocation(
		expressionNIL,
		new_origsymbol( me->name, rdup_origin( x->field->org ) ),
		this_parameters,
		parameters,
		0
	    )
	);
    }
    rfre_expression( x );
    return res;
}

static statement mangle_TypeInvocationStatement_action( TypeInvocationStatement x, mangle_data *ctx )
{
.call generate_walker_call "    " x TypeInvocationStatement TypeInvocationStatement
    expression_list parameters = rdup_expression_list( x->parameters );
    MethodEntry me = bind_type_method( ctx, x->t, x->field, &x->parameters );
    if( me == MethodEntryNIL ){
	return x;
    }
    statement res;
    register_actual_escapes( ctx, me, parameters, expression_listNIL );
    register_method_throws( ctx->states, me->throws );
    if( me->t->tag != TAGVoidType ){
	if( warn_ignoredvalue ){
	    origin_warning( x->org, "returned value is ignored" );
	}
	expression ix = new_MethodInvocationExpression(
	    new_MethodInvocation(
		expressionNIL,
		new_origsymbol( me->name, rdup_origin( x->org ) ),
		new_expression_list(),
		parameters,
		0
	    )
	);
	res = new_ExpressionStatement(
	    rdup_origin( x->org ),
	    rdup_Pragma_list( x->pragmas ),
	    origsymbol_listNIL,	// Labels
	    ix
	);
    }
    else {
	if( ctx->expand_inlines && has_flags( me->flags, ACC_INLINE ) ){
	    Block blk = expand_inlined_method(
		ctx,
		me,
		x->org,
		expression_listNIL,
		parameters,
		tmsymbolNIL
	    );
	    res = new_BlockStatement(
		rdup_origin( x->org ),
		rdup_Pragma_list( x->pragmas ),
		origsymbol_listNIL,	// Labels
		blk
	    );
	    rfre_expression_list( parameters );
	}
	else {
	    res = new_MethodInvocationStatement(
		rdup_origin( x->org ),
		rdup_Pragma_list( x->pragmas ),
		origsymbol_listNIL,	// Labels
		new_MethodInvocation(
		    expressionNIL,
		    new_origsymbol( me->name, rdup_origin( x->org ) ),
		    new_expression_list(),
		    parameters,
		    0
		)
	    );
	}
    }
    rfre_statement( x );
    return res;
}

static statement mangle_SuperInvocationStatement_action( SuperInvocationStatement x, mangle_data *ctx )
{
.call generate_walker_call "    " x SuperInvocationStatement SuperInvocationStatement
    expression_list parameters = rdup_expression_list( x->parameters );
    expression_list this_parameters = new_expression_list();
    MethodEntry me = bind_super_method( ctx, x->org, x->field, &this_parameters, &parameters, typeNIL );
    if( me == MethodEntryNIL ){
	rfre_statement( x );
	return statementNIL;
    }
    statement res;
    register_actual_escapes( ctx, me, parameters, this_parameters );
    register_method_throws( ctx->states, me->throws );
    if( me->t->tag != TAGVoidType ){
	if( warn_ignoredvalue ){
	    origin_warning( x->org, "returned value is ignored" );
	}
	expression ix = new_MethodInvocationExpression(
	    new_MethodInvocation(
		expressionNIL,
		new_origsymbol( me->name, rdup_origin( x->org ) ),
		this_parameters,
		parameters,
		0
	    )
	);
	res = new_ExpressionStatement(
	    rdup_origin( x->org ),
	    rdup_Pragma_list( x->pragmas ),
	    origsymbol_listNIL,	// Labels
	    ix
	);
    }
    else {
	if( ctx->expand_inlines && has_flags( me->flags, ACC_INLINE ) ){
	    // this parameters don't need null checking, since they are
	    // the 'this' of the current method.
	    Block blk = expand_inlined_method(
		ctx,
		me,
		x->org,
		this_parameters,
		parameters,
		tmsymbolNIL
	    );
	    res = new_BlockStatement(
		rdup_origin( x->org ),
		rdup_Pragma_list( x->pragmas ),
		origsymbol_listNIL,	// Labels
		blk
	    );
	    rfre_expression_list( this_parameters );
	    rfre_expression_list( parameters );
	}
	else {
	    res = new_MethodInvocationStatement(
		rdup_origin( x->org ),
		rdup_Pragma_list( x->pragmas ),
		origsymbol_listNIL,	// Labels
		new_MethodInvocation(
		    expressionNIL,
		    new_origsymbol( me->name, rdup_origin( x->org ) ),
		    this_parameters,
		    parameters,
		    0
		)
	    );
	}
    }
    rfre_statement( x );
    return res;
}

static statement mangle_OuterSuperInvocationStatement_action( OuterSuperInvocationStatement x, mangle_data *ctx )
{
.call generate_walker_call "    " x OuterSuperInvocationStatement OuterSuperInvocationStatement
    expression_list parameters = rdup_expression_list( x->parameters );
    expression_list this_parameters = new_expression_list();
    MethodEntry me = bind_super_method( ctx, x->org, x->field, &this_parameters, &parameters, x->t );
    if( me == MethodEntryNIL ){
	rfre_statement( x );
	return statementNIL;
    }
    statement res;
    register_actual_escapes( ctx, me, parameters, this_parameters );
    register_method_throws( ctx->states, me->throws );
    if( me->t->tag != TAGVoidType ){
	if( warn_ignoredvalue ){
	    origin_warning( x->org, "returned value is ignored" );
	}
	expression ix = new_MethodInvocationExpression(
	    new_MethodInvocation(
		expressionNIL,
		new_origsymbol( me->name, rdup_origin( x->org ) ),
		this_parameters,
		parameters,
		0
	    )
	);
	res = new_ExpressionStatement(
	    rdup_origin( x->org ),
	    rdup_Pragma_list( x->pragmas ),
	    origsymbol_listNIL,	// Labels
	    ix
	);
    }
    else {
	if( ctx->expand_inlines && has_flags( me->flags, ACC_INLINE ) ){
	    // this parameters don't need null checking, since they are
	    // the 'this' of the current method.
	    Block blk = expand_inlined_method(
		ctx,
		me,
		x->org,
		this_parameters,
		parameters,
		tmsymbolNIL
	    );
	    res = new_BlockStatement(
		rdup_origin( x->org ),
		rdup_Pragma_list( x->pragmas ),
		origsymbol_listNIL,	// Labels
		blk
	    );
	    rfre_expression_list( this_parameters );
	    rfre_expression_list( parameters );
	}
	else {
	    res = new_MethodInvocationStatement(
		rdup_origin( x->org ),
		rdup_Pragma_list( x->pragmas ),
		origsymbol_listNIL,	// Labels
		new_MethodInvocation(
		    expressionNIL,
		    new_origsymbol( me->name, rdup_origin( x->org ) ),
		    this_parameters,
		    parameters,
		    0
		)
	    );
	}
    }
    rfre_statement( x );
    return res;
}

// Given a list of interfaces, make sure that there are no duplicates.
static bool check_duplicate_interfaces( const_origin org, const_type_list interfaces )
{
    bool ok = true;

    for( unsigned int ix=0; ix<interfaces->sz; ix++ ){
        const_type ta = interfaces->arr[ix];

	for( unsigned int iy=ix+1; iy<interfaces->sz; iy++ ){
	    const_type tb = interfaces->arr[iy];

	    if( isequal_type( ta, tb ) ){
		tmstring tnm = typename_type( ta );

	        origin_error( org, "duplicate interface '%s'", tnm );
		rfre_tmstring( tnm );
	    }

	}
    }
    return ok;
}

/* -------- End of action functions ---------- */

.call generate_walker "$(visit_types)"
#line $[1+${tpllineno}] "${tplfilename}"

// Clear all fields of the mangle_data structure.
static void initialize_context( mangle_data *ctx,  SparProgram *prog, SparProgramUnit unit, modflags classflags )
{
    memset( ctx, 0, sizeof( mangle_data ) );
    ctx->expand_inlines = true;
    ctx->var_translations = new_VarTranslation_list();
    ctx->var_mappings = new_VarMapping_list();
    ctx->notnull_asserted = new_expression_list();
    ctx->allowed_throws = new_tmsymbol_list();
    ctx->post_spill_smts = new_statement_list();
    ctx->mangled_pre_spill_smts = new_statement_list();
    ctx->states = new_ProgramState_list();
    ctx->in_assign_lhs = false;
    ctx->in_constructor = false;
    ctx->in_typeof = false;
    ctx->in_pure_expression = false;
    ctx->static_context = false;
    ctx->prog = prog;
    ctx->unit = unit;
    ctx->classflags = classflags;
    ctx->symtab = (*prog)->symtab;
    ctx->typelist = (*prog)->typelist;
    ctx->ondemands = unit->demandimports;
    ctx->typebindings = unit->typebindings;
    push_programstate( ctx->states, false, "initial context" );
    ctx->retval = AbstractValueNIL;
}

// Clean up the fields of a mangle_data structure.
static void delete_context( mangle_data *ctx )
{
    rfre_VarTranslation_list( ctx->var_translations );
    rfre_VarMapping_list( ctx->var_mappings );
    rfre_expression_list( ctx->notnull_asserted );
    rfre_tmsymbol_list( ctx->allowed_throws );
    rfre_statement_list( ctx->post_spill_smts );
    rfre_statement_list( ctx->mangled_pre_spill_smts );
    if( ctx->states->sz != 1 ){
	internal_error(
	    "Analysis stack has %lu states left (expected 1)",
	    ctx->states->sz
	);
    }
    rfre_AbstractValue( ctx->retval );
    rfre_ProgramState_list( ctx->states );
    SparProgram *prog = ctx->prog;
    (*prog)->symtab = ctx->symtab;
    (*prog)->typelist = ctx->typelist;
}

// Given a list of type declarations 'decls' and a type name 't', return
// false if the type is not in the list of declarations. Return true
// iff the type occurs in the list of declarations, and iff found, assign the
// declaration to '*dclp'.
//
// The list should only contain type declarations; assert that assumption.
static bool search_TypeDeclaration( SparProgramUnit unit, tmsymbol t, TypeDeclaration *dclp )
{
    tmsymbol first;
    tmsymbol last;
    statement_list decls;
    bool is_inner_class = false;

    break_qualified_tmsymbol( t, &first, &last );

    if( first != unit->packagename->sym ){
	if( is_qualified_prefix( unit->packagename->sym, first ) ){
	    // Aparently we are searching for an inner type. First
	    // search for the outer type, and then search the definitions
	    // of the outer type.
	    TypeDeclaration outer;

	    if( !search_TypeDeclaration( unit, first, &outer ) ){
		return false;
	    }
	    decls = outer->body;
	    is_inner_class = true;
	}
	else {
	    decls = statement_listNIL;
	    internal_error(
		"Type `%s' should live in package `%s', not `%s'",
		t->name,
		unit->packagename->sym->name,
		first->name
	    );
	}
    }
    else {
	decls = unit->decls;
    }
    for( unsigned int ix=0; ix<decls->sz; ix++ ){
	statement smt = decls->arr[ix];
	if( is_TypeDeclaration( smt ) ){
	    TypeDeclaration dcl = to_TypeDeclaration( smt );
	    if( dcl->name->sym == last ){
		*dclp = dcl;
		return true;
	    }
	}
	else {
	    if( !is_inner_class ){
		internal_error( "A package should only contain type declarations" );
	    }
	}
    }
    return false;
}

// Given a signature 's', a method name 'name' and a list of formal
// parameters 'parms', return true iff the signature matches the declaration.
static bool signature_matches_method(
    const_Signature s,
    const_origsymbol name,
    const_FormalParameter_list parms
)
{
    if( s->name != name->sym ){
	return false;
    }
    type_list tl = s->parameters;
    if( tl->sz != parms->sz ){
	return false;
    }
    for( unsigned int ix=0; ix<tl->sz; ix++ ){
	FormalParameter parm = parms->arr[ix];

	if( !isequal_type( parm->t, tl->arr[ix] ) ){
	    return false;
	}
    }
    return true;
}

// Given a list of declarations 'decls' and a method signature 's', return
// false if the method is not in the list of declarations. Return true
// if the method occurs in the list of declarations, and assign the index
// of that declaration to '*pos'.
static bool search_method_Declaration_list(
 const_statement_list decls,
 const_Signature s,
 unsigned int *pos
)
{
    for( unsigned int ix=0; ix<decls->sz; ix++ ){
	const_statement smt = decls->arr[ix];

	if( is_MethodDeclaration( smt ) ){
	    const_MethodDeclaration dcl = to_const_MethodDeclaration( smt );
	    if( signature_matches_method( s, dcl->name, dcl->parameters ) ){
		*pos = ix;
		return true;
	    }
	}
    }
    return false;
}

// Given a list of declarations 'decls' and a field name 'nm', return
// false if the field is not in the list of declarations. Return true
// if the field occurs in the list of declarations, and assign the index
// of that declaration to '*pos'.
static bool search_field_Declaration_list(
 const_statement_list decls,
 tmsymbol nm,
 unsigned int *pos
)
{
    for( unsigned int ix=0; ix<decls->sz; ix++ ){
	const_statement smt = decls->arr[ix];

	if( smt->tag == TAGFieldDeclaration ){
	    const_FieldDeclaration dcl = to_const_FieldDeclaration( smt );
	    if( nm == dcl->name->sym ){
		*pos = ix;
		return true;
	    }
	}
    }
    return false;
}

// Given a type declaration 'dcl', see if you can deduce that the 
// static initializer of that class is trivial.
static bool trivialize_static_initializer(
 mangle_data *ctx,
 TypeDeclaration dcl 
)
{
    bool ok = true;
    TypeEntry super_entry = TypeEntryNIL;

    if( dcl->tag == TAGClassDeclaration ){
	const_ClassDeclaration cl = to_const_ClassDeclaration( dcl );

	if( cl->super != typeNIL ){
	    if( cl->super->tag != TAGObjectType ){
		origin_error( cl->org, "Parameterized type should have been rewritten" );
		ok = false;
	    }
	    else {
		origsymbol supernm = to_ObjectType(cl->super)->name;
		ok = visit_type( ctx->prog, supernm );
		if( !ok ){
		    return ok;
		}
		super_entry = lookup_TypeEntry( ctx->typelist, supernm );

		if( super_entry != TypeEntryNIL ){
		    if( super_entry->tag == TAGInterfaceEntry ){
			origsymbol_error( supernm, "Cannot subclass an interface" );
			ok = false;
		    }
		    else if( super_entry->tag != TAGClassEntry ){
			origsymbol_error( supernm, "Cannot subclass this" );
			ok = false;
		    }
		    else {
			if( has_any_flag( to_ClassEntry( super_entry )->flags, ACC_FINAL ) ){
			    origsymbol_error( supernm, "Cannot subclass a final class" );
			    ok = false;
			}
		    }
		}
	    }
	}
    }

    if(
	(
	    super_entry == TypeEntryNIL ||
	    !is_ObjectTypeEntry( super_entry ) ||
	    to_ObjectTypeEntry(super_entry)->staticInit == tmsymbolNIL
	) &&
	dcl->staticInitTrivial
    )
    {
	// There is no initializer for the superclass (or there is no
	// superclass), and the local initializer is trivial, so zap
	// the local initializer.
	dcl->staticInit = tmsymbolNIL;
	dcl->staticInitNeed = tmsymbolNIL;
	if( trace_analysis ){
	    fprintf(
		stderr,
		"Class %s does not need static initialization\n",
		dcl->name->sym->name
	    );
	}

	// Try to update the entry in the symbol table too, but don't get
	// upset if there is no such entry.
	TypeEntry me = search_TypeEntry( ctx->typelist, qualify_tmsymbol( ctx->owner, dcl->name->sym ) );
	if( me != TypeEntryNIL && is_ObjectTypeEntry( me ) ){
	    ObjectTypeEntry cte = to_ObjectTypeEntry( me );

	    cte->staticInit = tmsymbolNIL;
	    cte->staticInitNeed = tmsymbolNIL;
	}
    }
    return ok;
}

// Given a TypeDeclaration 'dcl', and the entry of a method 'method', make
// sure that the method is mangled. Return the updated type declaration.
static TypeDeclaration mangle_TypeDeclaration_Method(
 TypeDeclaration dcl,
 mangle_data *ctx,
 MethodEntry method
)
{
    unsigned int pos;
    tmsymbol old_dynamic_init = ctx->dynamic_init;
    bool ok;

    ctx->dynamic_init = dcl->dynInit;
    if( !search_method_Declaration_list( dcl->body, method->realname, &pos ) ){
	tmstring snm = typename_Signature( method->realname );

	internal_error( "type `%s' does not define method `%s'", method->owner->name, snm );
    }
    assert( is_MethodDeclaration( dcl->body->arr[pos] ) );
    MethodDeclaration md = to_MethodDeclaration( dcl->body->arr[pos] );
    ok = visit_type( ctx, md->parameters );
    ok &= visit_type( ctx, md->throws );
    if( !ok ){
	return TypeDeclarationNIL;
    }
    if( (dcl->flags & ACC_ABSTRACT) == 0 && (md->flags & ACC_ABSTRACT) != 0 ){
	origsymbol_error(
	    md->name,
	    "Class %s must be declared abstract since it contains an abstract method",
	    dcl->name->sym->name
	);
	return TypeDeclarationNIL;
    }
    md->used = true;
    tmsymbol old_owner = ctx->owner;
    ctx->owner = method->owner;
    context oldwhere = ctx->where;
    ctx->where = CTX_OBJECT;
    int oldlevel = ctx->scopelevel;
    TypeEntry me = lookup_TypeEntry( ctx->typelist, method->owner );
    if( me == TypeEntryNIL ){
	return TypeDeclarationNIL;
    }
    assert( is_ObjectTypeEntry( me ) );
    ObjectTypeEntry ct_me = to_ObjectTypeEntry( me );
    if( dcl->tag == TAGClassDeclaration ){
	assert( me->tag == TAGClassEntry );
	ctx->constructor_mappings = to_ClassEntry( me )->constructors;
    }
    ctx->method_mappings = ct_me->methods;
    build_field_translations( ctx, ct_me->fields );
    TypeBinding_list old_typebindings = ctx->typebindings;
    ctx->typebindings = ct_me->types;
    if( me->tag == TAGClassEntry ){
	const_type super = to_ClassEntry( me )->super;
	visit_overridden_methods( ctx, super, ct_me->interfaces );
    }
    else {
	visit_overridden_methods( ctx, typeNIL, ct_me->interfaces );
    }

    if( !trivialize_static_initializer( ctx, dcl ) ){
	ctx->where = oldwhere;
	ctx->dynamic_init = old_dynamic_init;
	delete_scopelevels( ctx, oldlevel );
	ctx->owner = old_owner;
	ctx->typebindings = old_typebindings;
	return TypeDeclarationNIL;
    }
.call generate_descent_call "    " md MethodDeclaration MethodDeclaration

    ctx->where = oldwhere;
    ctx->dynamic_init = old_dynamic_init;
    delete_scopelevels( ctx, oldlevel );
    ctx->owner = old_owner;
    ctx->typebindings = old_typebindings;
    dcl->body->arr[pos] = md;
    return dcl;
}

// Given a SparProgramUnit 'unit', The entire program 'prog', and the
// symbol table entry of the method 'me', make sure that the method is mangled.
static SparProgramUnit mangle_SparProgramUnit_method(
 SparProgramUnit unit,
 SparProgram prog,
 MethodEntry me
)
{
    mangle_data the_ctx;
    TypeDeclaration dcl;

    if( !search_TypeDeclaration( unit, me->owner, &dcl ) ){
	internal_error( "The unit does not define type '%s'", me->owner->name );
    }
    dcl->used = true;

    initialize_context( &the_ctx, &prog, unit, dcl->flags );
    the_ctx.where = CTX_GLOBAL;
    assert( unit->packagename != origsymbolNIL );
    the_ctx.owner = unit->packagename->sym;
    the_ctx.packagename = unit->packagename->sym;
    the_ctx.static_context = has_any_flag( me->flags, ACC_STATIC );

    register_allowed_throws( &the_ctx, me->throws );
    (void) mangle_TypeDeclaration_Method( dcl, &the_ctx, me );
    delete_context( &the_ctx );
    return unit;
}

// Given a SparProgram 'prog', and a method entry 'me',
// make sure that the method 's' is mangled.
static SparProgram mangle_SparProgram_method( SparProgram prog, MethodEntry me )
{
    unsigned int unit_pos;

    if( !search_type_SparProgramUnit_list( prog->units, me->owner, &unit_pos ) ){
	internal_error( "Cannot find the unit that defines '%s'", me->owner->name );
    }
    prog->units->arr[unit_pos] = mangle_SparProgramUnit_method(
	prog->units->arr[unit_pos],
	prog,
	me
    );
    return prog;
}

// Given a TypeDeclaration 'dcl', and a field name, return the value
// of the field if it is a compile-time constant, or return expressionNIL.
static expression get_compiletime_constant_TypeDeclaration_field(
 TypeDeclaration dcl,
 mangle_data *ctx,
 const_origsymbol fnm
)
{
    unsigned int pos;
    expression res = expressionNIL;

    if( !search_field_Declaration_list( dcl->body, fnm->sym, &pos ) ){
	origsymbol_internal_error( fnm, "type '%s' does not define a field", dcl->name->sym->name );
    }
    assert( dcl->body->arr[pos]->tag == TAGFieldDeclaration );
    FieldDeclaration fd = to_FieldDeclaration( dcl->body->arr[pos] );
    if( has_flags( fd->flags, ACC_FINAL ) ){
	if( fd->init->tag == TAGOptExpr ){
	    bool isconstant = false;
	    OptExpr initval = to_OptExpr( fd->init );

	    initval->x = derive_compiletime_constant(
		ctx,
		initval->x,
		&isconstant
	    );
	    if( isconstant ){
		// This declaration is a constant as per JLS2
		fd->flags |= ACC_COMPILECONSTANT;
		res = rdup_expression( initval->x );
		if( trace_analysis ){
		    fprintf(
			stderr,
			"Field %s.%s is a compile-time constant\n",
			ctx->owner->name,
			fd->name->sym->name
		    );
		}
	    }
	}
    }
    return res;
}

// Given a SparProgramUnit 'unit', The entire program 'prog', a field name
// 'fnm' and the type of that field 'tnm', return its value if the field
// is a compile-time constant, or else return expressionNIL.
static expression get_compiletime_constant_SparProgramUnit_field(
 SparProgramUnit unit,
 SparProgram *prog,
 const_origsymbol fnm,
 tmsymbol tnm
)
{
    mangle_data the_ctx;
    TypeDeclaration dcl;

    if( !search_TypeDeclaration( unit, tnm, &dcl ) ){
	internal_error( "The unit does not define type '%s'", tnm->name );
    }
    initialize_context( &the_ctx, prog, unit, dcl->flags );
    the_ctx.where = CTX_GLOBAL;
    assert( unit->packagename != origsymbolNIL );
    the_ctx.owner = tnm;
    the_ctx.packagename = unit->packagename->sym;

    expression res = get_compiletime_constant_TypeDeclaration_field( dcl, &the_ctx, fnm );
    delete_context( &the_ctx );
    return res;
}

// Given a pointer to a SparProgram 'prog', a field name 'fnm' and a
// class/interface it belongs to 'tnm', return its value if the field is
// a compile-time constant, or else return expressionNIL.
static expression get_compiletime_constant_SparProgram_field( SparProgram *prog, const_origsymbol fnm, tmsymbol tnm )
{
    unsigned int unit_pos;

    if( !search_type_SparProgramUnit_list( (*prog)->units, tnm, &unit_pos ) ){
	internal_error( "Cannot find the unit that defines '%s'", tnm->name );
    }
    return get_compiletime_constant_SparProgramUnit_field(
	(*prog)->units->arr[unit_pos],
	prog,
	fnm,
	tnm
    );
}

// Given a method from an interface 'inf_method' and a method from
// a class 'cl_method' that is supposed to implement this interface
// method, make sure that the return types of the two are ok.
//
// TODO: also have a look at the 'throws' clauses.
static bool check_implemented_method( 
 const_MethodEntry cl_method,
 const_MethodEntry inf_method,
 tmsymbol inf,
 const_origin org
)
{
    if( isequal_type( cl_method->t, inf_method->t ) ){
	// No problems.
	return true;
    }
    tmstring tnm = typename_Signature( inf_method->realname );
    tmstring cl_tnm = typename_type( cl_method->t );
    tmstring inf_tnm = typename_type( inf_method->t );
    origin_error(
	org,
	"method '%s' returns '%s', according to interface '%s' it should return '%s'",
	tnm,
	cl_tnm,
	inf->name,
	inf_tnm
    );
    // Not ok.
    rfre_tmstring( tnm );
    rfre_tmstring( cl_tnm );
    rfre_tmstring( inf_tnm );
    return false;
}

// Given a type declaration and the name of an interface, make sure that the
// type implements the interface as promised.
static bool enforce_interface_implementation(
 mangle_data *ctx,
 const_TypeDeclaration dcl,
 const_ObjectTypeEntry te,
 tmsymbol inf
)
{
    bool ok = true;
    const_TypeEntry e = lookup_TypeEntry( ctx->typelist, inf );
    if( e->tag != TAGInterfaceEntry ){
	origsymbol_error(
	    dcl->name,
	    "Type '%s' is not an interface, and cannot be implemented", e->name->sym->name
	);
	return false;
    }
    const_InterfaceEntry ie = to_const_InterfaceEntry( e );
    MethodMapping_list methods = ie->methods;
    // We now have a list of all the methods in the interface. See if we
    // can find a problem.
    for( unsigned int ix=0; ix<methods->sz; ix++ ){
	const_MethodMapping me = methods->arr[ix];
	const_MethodEntry inf_method = lookup_MethodEntry( ctx->symtab, me->mangledname );

	if(
	    inf_method == MethodEntryNIL ||
	    has_any_flag( inf_method->flags, ACC_INIT )
	){
	    continue;
	}
	bool is_static;
	bool use_static_call;
	bool rejected = false;

	MethodEntry cl_method = search_Method(
	    ctx->prog,
	    ctx->symtab,
	    ctx->typelist,
	    te->name->sym,		// Where to search the method.
	    te->name->sym,		// Where are we calling from.
	    me->realname,		// What are we looking for.
	    &is_static,
	    &use_static_call,
	    &rejected,
	    originNIL
	);
	if( cl_method == MethodEntryNIL ){
	    // The method is not implemented by this class
	    if( rejected ){
		tmstring tnm = typename_Signature( inf_method->realname );
		origin_error(
		    dcl->name->org,
		    "method '%s' of interface '%s' is implemented by an inaccessible method",
		    tnm,
		    inf->name
		);
		rfre_tmstring( tnm );
		ok = false;
	    }
	    else if( !has_any_flag( dcl->flags, ACC_ABSTRACT ) ){
		// This is a concrete class, so get nasty.
		tmstring tnm = typename_Signature( inf_method->realname );

		origin_error(
		    dcl->name->org,
		    "method '%s' of interface '%s' is not implemented",
		    tnm,
		    inf->name
		);
		rfre_tmstring( tnm );
		ok = false;
	    }
	    continue;
	}
	if( is_static ){
	    tmstring tnm = typename_Signature( inf_method->realname );
	    origsymbol_error(
		dcl->name,
		"method '%s' of interface '%s' cannot be implemented by a static method",
		tnm,
		inf->name
	    );
	    rfre_tmstring( tnm );
	    ok = false;
	}
	ok &= check_implemented_method( cl_method, inf_method, inf, dcl->name->org );
    }
    return ok;
}

// Given a program declaration, make sure it implements all the
// methods promised by its 'implements' clauses.
static bool enforce_interface_implementations(
 mangle_data *ctx,
 const_TypeDeclaration dcl,
 ObjectTypeEntry te
)
{
    bool ok = true;
    if( is_compilation_failure() ){
	// Since we already have errors, don't try to do advanced checking.
        return ok;
    }
    tmsymbol_list infs = collect_interfaces( ctx->typelist, origsymbol_listNIL, new_tmsymbol_list(), te );

    for( unsigned int ix=0; ix<infs->sz; ix++ ){
	if( !enforce_interface_implementation( ctx, dcl, te, infs->arr[ix] ) ){
	    break;
	}
    }
    rfre_tmsymbol_list( infs );
    return ok;
}

static bool implements_serializable(
 mangle_data *ctx,
 ObjectTypeEntry te
)
{
    if( is_compilation_failure() ){
	// Since we already have errors, don't try to do advanced checking.
        return false;
    }
    tmsymbol_list infs = collect_interfaces( ctx->typelist, origsymbol_listNIL, new_tmsymbol_list(), te );
    bool res = member_tmsymbol_list( infs, add_tmsymbol( "java.io.Serializable" ) );

    rfre_tmsymbol_list( infs );
    return res;
}

// Given a SparProgramUnit 'unit', The entire program 'prog', and the
// symbol table entry of the type 'te', make sure that the type is mangled.
static SparProgramUnit mangle_SparProgramUnit_type(
 SparProgramUnit unit,
 SparProgram prog,
 TypeEntry te
)
{
    mangle_data the_ctx;
    TypeDeclaration dcl;
    bool is_forkable = false;

    if( !search_TypeDeclaration( unit, te->name->sym, &dcl ) ){
	internal_error(
	    "The unit in file '%s' does not define type '%s'",
	    unit->path,
	    te->name->sym->name
	);
    }
    dcl->used = true;

    initialize_context( &the_ctx, &prog, unit, dcl->flags );
    the_ctx.owner = te->name->sym;
    the_ctx.packagename = te->package;
    the_ctx.where = CTX_OBJECT;
    the_ctx.org = dcl->org;
    mangle_data *ctx = &the_ctx;

    const_statement_list decls = dcl->body;
    assert( is_ObjectTypeEntry( te ) );
    ObjectTypeEntry cte = to_ObjectTypeEntry( te );
    TypeBinding_list old_typebindings = ctx->typebindings;
    ctx->typebindings = cte->types;

    // First, make sure that parameterized types are rewritten.
.call generate_descent_call "    " dcl->interfaces type_list type_list
    bool ok = check_duplicate_interfaces( ctx->org, dcl->interfaces );

    // Then, make sure that all these types have been visited.
    ok &= visit_interfaces( ctx, dcl->interfaces );
    if( ok && te->tag == TAGInterfaceEntry ){
        // We'd better make sure there is no recursion.
	if( implements_interface( prog->typelist, dcl->interfaces, te->name ) ){
	    origin_error( dcl->name->org, "Interface '%s' implements itself", dcl->name->sym->name );
	    ok = false;
	}
    }
    if( ok && dcl->tag == TAGClassDeclaration ){
	// We'd better make sure there is no recursion over the
	// superclasses.
	ClassDeclaration cdcl = to_ClassDeclaration( dcl );
.call generate_descent_call "	" cdcl->super type type
	ok = visit_type( ctx, cdcl->super );
	if(
	    ok &&
	    cdcl->super != typeNIL &&
	    is_subclass( prog->typelist, cdcl->super, te->name->sym )
	){
	    origin_error( dcl->name->org, "Class '%s' has itself as superclass", dcl->name->sym->name );
	    ok = false;
	}
    }
    if( !ok ){
	ctx->typebindings = old_typebindings;
	return SparProgramUnitNIL;
    }
    if( implements_interface( prog->typelist, te->name, "spar.lang.Forkable" ) ){
        te->flags |= ACC_FORKABLE;
	is_forkable = true;
	if( trace_analysis ){
	    fprintf( stderr, "Type '%s' is forkable\n", te->name->sym->name );
	}
    }
    const_TypeEntry super_entry = TypeEntryNIL;
    build_field_translations( ctx, cte->fields );
    ForwardFieldEntry fe = new_ForwardFieldEntry( 
	mangle_variable_symbol( ctx, dcl->staticInitNeed, originNIL ),
	Pragma_listNIL,
	ACC_INIT|ACC_STATIC|ACC_PUBLIC,
	ctx->owner,
	ctx->packagename,
	false,
	add_origsymbol( dcl->staticInitNeed ),
	new_PrimitiveType( BT_BOOLEAN )
    );
    ctx->symtab = add_symtab( ctx->symtab, fe );
.call generate_descent_call "    " cte->methods MethodMapping_list MethodMapping_list
    if( cte->tag == TAGClassEntry ){
.call generate_descent_call "	" to_ClassEntry(cte)->constructors MethodMapping_list MethodMapping_list
    }

    statement_list old_dynamic_inits = ctx->dynamic_inits;
    statement_list old_static_inits = ctx->static_inits;

    ctx->dynamic_inits = new_statement_list();
    ctx->static_inits = new_statement_list();
    tmsymbol static_scope = tmsymbolNIL;
    tmsymbol dynamic_scope = tmsymbolNIL;
    statement_list old_breakout_declarations = ctx->breakout_declarations;
    statement_list dynamic_breakout_declarations = new_statement_list();
    statement_list static_breakout_declarations = new_statement_list();

    for( unsigned int ix=0; ix<decls->sz; ix++ ){
	statement d = decls->arr[ix];

	if( d->tag == TAGFieldDeclaration ){
	    tmsymbol *old_scopeptr = ctx->scopeptr;
	    context oldwhere = ctx->where;
	    FieldDeclaration fd = to_FieldDeclaration(d);

	    if(
	        dcl->tag == TAGInterfaceDeclaration &&
		!is_initialization( fd->init )
	    ){
	        origin_error( fd->name->org, "Interface field `%s' must have an initialization expression", fd->name->sym->name );
		ok = false;
	    }
	    if( has_any_flag( fd->flags, ACC_STATIC ) ){
		ctx->scopeptr = &static_scope;
		ctx->where = CTX_STATICINIT;
		ctx->breakout_declarations = static_breakout_declarations;
	    }
	    else {
		ctx->scopeptr = &dynamic_scope;
		ctx->where = CTX_DYNAMICINIT;
		ctx->breakout_declarations = dynamic_breakout_declarations;
	    }
	    decls->arr[ix] = mangle_classfield( to_FieldDeclaration( decls->arr[ix] ), ctx );
	    ctx->scopeptr = old_scopeptr;
	    ctx->where = oldwhere;
	    if( is_forkable ){
	        // Enforce the restrictions of a forkable class.
		if(
		    has_any_flag( fd->flags, ACC_STATIC ) &&
		    !has_any_flag( fd->flags, ACC_COMPILECONSTANT )
		){
		    const_VariableEntry ve = lookup_VariableEntry( ctx->symtab, fd->name->sym );
		    if( ve == VariableEntryNIL ){
			origsymbol_error( fd->name, "Static field not allowed in a forkable class" );
		    }
		    else {
			origsymbol_error( ve->realname, "Static field not allowed in a forkable class" );
		    }
		}
		if(
		    !has_any_flag( fd->flags, ACC_PROTECTED|ACC_PRIVATE|ACC_COMPILECONSTANT )
		){
		    const_VariableEntry ve = lookup_VariableEntry( ctx->symtab, fd->name->sym );
		    if( ve == VariableEntryNIL ){
			origsymbol_error( fd->name, "A field of a forkable class must be declared protected or private" );
		    }
		    else {
			origsymbol_error( ve->realname, "A field of a forkable class must be declared protected or private" );
		    }
		}
	    }
	}
	if( d->tag == TAGInstanceInitializer ){
.call generate_descent_call "	    " decls->arr[ix] InstanceInitializer statement
	}
	if( d->tag == TAGStaticInitializer ){
.call generate_descent_call "	    " decls->arr[ix] StaticInitializer statement
	}
	if( is_TypeDeclaration( d ) ){
	    const_TypeDeclaration td = to_const_TypeDeclaration( d );
	    tmsymbol name = td->name->sym;
	    tmsymbol longname = qualify_tmsymbol( ctx->owner, name );

	    // An inner class.  Add a type binding for this type.
	    ctx->typebindings = register_TypeBinding(
		ctx->typebindings,
		ctx->unit->packagename->sym,
		new_TypeBinding( name, longname )
	    );
	}
    }
    ctx->breakout_declarations = old_breakout_declarations;
    ctx->dynamic_inits = concat_statement_list(
        dynamic_breakout_declarations,
	ctx->dynamic_inits
    );
    ctx->static_inits = concat_statement_list(
        static_breakout_declarations,
	ctx->static_inits
    );

    // ------------------------

    if( ctx->dynamic_inits->sz != 0 ){
	// TODO: An interface should not have dynamic initializers.
	tmsymbol nm = dcl->dynInit;
	modflags flags = ACC_INIT|ACC_FINAL|ACC_PRIVATE;

	if( is_inlinable_initializer( ctx->dynamic_inits ) ){
	    flags |= ACC_INLINE;
	    if( trace_inlining ){
		fprintf( stderr, "Dynamic init of '%s' is trivial enough to be inlined\n", dcl->name->sym->name );
	    }
	}
	FunctionDeclaration init_fn = new_FunctionDeclaration(
	    gen_origin(),
	    Pragma_listNIL,
	    origsymbol_listNIL,	// Labels
	    flags,
	    false,
	    new_origsymbol( nm, gen_origin() ),		// name
	    new_FormalParameter_list(),
	    new_type_list(),				// throws
	    new_VoidType(),
	    new_Block( dynamic_scope, Pragma_listNIL, ctx->dynamic_inits )
	);
	dcl->body = append_statement_list( dcl->body, init_fn );
    }
    else {
	dcl->dynInit = tmsymbolNIL;
	rfre_statement_list( ctx->dynamic_inits );
    }
    // Construct the static initializer function, but only if it
    // does something useful.
    if( ctx->static_inits->sz == 0 ){
	if( trace_analysis ){
	    fprintf( stderr, "Static init of '%s' is trivial\n", dcl->name->sym->name );
	}
	dcl->staticInitTrivial = true;
	dcl->staticInit = tmsymbolNIL;
	dcl->staticInitNeed = tmsymbolNIL;
	cte->staticInitTrivial = true;
	cte->staticInit = tmsymbolNIL;
	cte->staticInitNeed = tmsymbolNIL;
	rfre_statement_list( ctx->static_inits );
    }
    else {
	modflags flags = ACC_INIT|ACC_STATIC|ACC_FINAL|ACC_PUBLIC;

	if( is_inlinable_initializer( ctx->static_inits ) ){
	    flags |= ACC_INLINE;
	    if( trace_inlining ){
		fprintf( stderr, "Static init of '%s' is trivial enough to be inlined\n", dcl->name->sym->name );
	    }
	}
	// Construct a boolean variable to record the initialization
	tmsymbol neednm = dcl->staticInitNeed;
	FieldDeclaration need_decl = new_FieldDeclaration(
	    gen_origin(),
	    Pragma_listNIL,
	    origsymbol_listNIL,	// Labels
	    ACC_INIT|ACC_STATIC|ACC_PUBLIC,
	    false,
	    new_origsymbol( neednm, gen_origin() ),
	    new_PrimitiveType( BT_BOOLEAN ),
	    new_OptExpr( new_BooleanExpression( true ) )
	);
	context oldwhere = ctx->where;
	ctx->where = CTX_STATICINIT;
	need_decl = mangle_classfield( need_decl, ctx );
	ctx->where = oldwhere;
	dcl->body = append_statement_list( dcl->body, need_decl );
	tmsymbol nm = dcl->staticInit;
	// First thing to do in the static init: tell 'em it is done.
	ctx->static_inits = insert_statement_list(
	    ctx->static_inits,
	    0,
	    new_AssignStatement(
		gen_origin(),
		Pragma_listNIL,
		origsymbol_listNIL,	// Labels
		ASSIGN,
		new_VariableNameExpression( add_origsymbol( neednm ), VAR_GENERATED|VAR_LOCAL ),
		new_BooleanExpression( false )
	    )
	);
	// Construct a method to contain the initialization
	FunctionDeclaration init_proc = new_FunctionDeclaration(
	    gen_origin(),
	    Pragma_listNIL,
	    origsymbol_listNIL,	// Labels
	    flags,
	    false,
	    new_origsymbol( nm, gen_origin() ),	// name
	    new_FormalParameter_list(),		// parameters
	    new_type_list(),			// throws
	    new_VoidType(),
	    new_Block( static_scope, Pragma_listNIL, ctx->static_inits )
	);
	dcl->body = append_statement_list( dcl->body, init_proc );
    }
    ctx->dynamic_inits = old_dynamic_inits;
    ctx->static_inits = old_static_inits;

    // ------------------------

    if( dcl->tag == TAGClassDeclaration && to_ClassDeclaration(dcl)->super != typeNIL ){
	type super = to_ClassDeclaration(dcl)->super;
	assert( super->tag == TAGObjectType );
	if( !visit_type( ctx, super ) ){
	    ctx->typebindings = old_typebindings;
	    return SparProgramUnitNIL;
	}
	origsymbol supernm = to_ObjectType(super)->name;
	if( supernm == origsymbolNIL ){
	    ctx->typebindings = old_typebindings;
	    return SparProgramUnitNIL;
	}
	supernm->sym = mangle_type_symbol( ctx, supernm );
	if( supernm->sym == tmsymbolNIL ){
	    ctx->typebindings = old_typebindings;
	    return SparProgramUnitNIL;
	}
	super_entry = lookup_TypeEntry( ctx->typelist, supernm );
	ctx->typelist = register_subclass(
	    ctx->typelist,
	    supernm,
	    ctx->owner
	);
    }
    if( dcl->tag == TAGClassDeclaration ){
	ok = enforce_interface_implementations( &the_ctx, dcl, cte );
	if( !ok ){
	    ctx->typebindings = old_typebindings;
	    return SparProgramUnitNIL;
	}
    }
    if(
	(
	    super_entry == TypeEntryNIL ||
	    !is_ObjectTypeEntry( super_entry ) ||
	    to_const_ObjectTypeEntry(super_entry)->staticInit == tmsymbolNIL
	) &&
	dcl->staticInitTrivial
    )
    {
	// There is no initializer for the superclass (or there is no
	// superclass), and the local initializer is trivial, so zap
	// the local initializer.
	dcl->staticInit = tmsymbolNIL;
	dcl->staticInitNeed = tmsymbolNIL;
	if( trace_analysis ){
	    fprintf(
		stderr,
		"Class %s does not need static initialization\n",
		dcl->name->sym->name
	    );
	}
    }

    // If this is a class, see if it implements java.io.Serializable.
    // If so, think up names for the writer and reader.
    // This also signals that the class is serializable.
    if( cte->tag == TAGClassEntry ){
        if( implements_serializable( ctx, cte ) ){
	    to_ClassEntry(cte)->packMethod = gen_tmsymbol( "ser_write" );
	    to_ClassEntry(cte)->unpackMethod = gen_tmsymbol( "ser_read" );
	}

	// Now, do some verification on the methods of this class.
	// TODO: when complaining about unimplemented abstract methods we
	// inherit, tell from which class we inherit them. This info is
	// not in VtableEntry.
	// TODO: verify the throws class of methods that this class
	// overrides.
	MethodInfo_list ml = construct_MethodInfo_list( to_const_ClassEntry(cte), ctx->typelist, ctx->symtab );
	for( unsigned int iy=0; iy<ml->sz; iy++ ){
	    const_MethodInfo vte = ml->arr[iy];
	    const_Signature s = vte->s;
	    if(
		!has_any_flag( cte->flags, ACC_ABSTRACT ) &&
		has_any_flag( s->flags, ACC_ABSTRACT ) &&
		cte->name->sym != vte->owner
	    ){
		tmstring snm = typename_Signature( s );
		origin_error(
		    cte->name->org,
		    "Class '%s' does not implement abstract method '%s' inherited from '%s'",
		    cte->name->sym->name,
		    snm,
		    vte->owner->name
		);
		rfre_tmstring( snm );
	    }
	}
	rfre_MethodInfo_list( ml );
    }
    delete_context( &the_ctx );
    ctx->typebindings = old_typebindings;
    return unit;
}

// Given a SparProgram 'prog', and a TypeEntry 'me',
// make sure that the type is mangled.
static SparProgram mangle_SparProgram_type( SparProgram prog, TypeEntry me )
{
    unsigned int unit_pos;

    if( !search_type_SparProgramUnit_list( prog->units, me->name->sym, &unit_pos ) ){
	internal_error( "Cannot find the unit that defines '%s'", me->name->sym->name );
    }
    prog->units->arr[unit_pos] = mangle_SparProgramUnit_type(
	prog->units->arr[unit_pos],
	prog,
	me
    );
    if( prog->units->arr[unit_pos] == SparProgramUnitNIL ){
        return SparProgramNIL;
    }
    return prog;
}

// Given a pointer to a SparProgram 'prog' and the name of a type 't',
// make sure that the fields of that type are mangled.
static bool mangle_type( SparProgram *prog, tmsymbol t )
{
    if( t == tmsymbolNIL ){
	return false;
    }
    TypeEntry e = search_TypeEntry( (*prog)->typelist, t );
    if( e == TypeEntryNIL ){
	if( !is_compilation_failure() ){
	    internal_error( "cannot force compilation of type '%s'", t->name );
	}
	return false;
    }
    if( e->usecount++ == 0 && e->tag != TAGPackageEntry ){
	SparProgram pr = mangle_SparProgram_type( *prog, e );
	if( pr == SparProgramNIL ){
	    return false;
	}
	*prog = pr;
    }
    return true;
}

// Given an origin, a list of expressions, a list of formals and the name of
// the generic and specialized type, construct a list of type substitutions.
static TypeAbstraction_list build_TypeAbstraction_list(
  const_origin org,
  const_expression_list xl,
  const_FormalParameter_list formals,
  tmsymbol abstract_name,
  tmsymbol special_name
)
{
    TypeAbstraction_list res = new_TypeAbstraction_list();

    res = append_TypeAbstraction_list(
	res,
	new_TypeAbstraction(
	    abstract_name,
	    new_ObjectType( add_origsymbol( special_name ) )
	)
    );
    assert( xl->sz == formals->sz );
    for( unsigned int ix=0; ix<xl->sz; ix++ ){
	FormalParameter formal = formals->arr[ix];

	if( formal->t->tag == TAGTypeType ){
	    const_expression x = xl->arr[ix];

	    if( x == expressionNIL ){
		continue;
	    }
	    if( x->tag == TAGTypeExpression ){
		res = append_TypeAbstraction_list(
		    res,
		    new_TypeAbstraction(
			formal->name->sym,
			rdup_type( to_const_TypeExpression(x)->t )
		    )
		);
	    }
	    else {
		origsymbol_error(
		    formal->name,
		    "Formal parameter must be passed a type parameter"
		);
		origin_error( org, "    at this place in the program" );
	    }
	}
    }
    return res;
}

// Given a list of expressions and a list of formals,
// construct a list of type substitutions.
static ValueAbstraction_list build_ValueAbstraction_list(
  const_expression_list xl,
  const_FormalParameter_list formals
)
{
    ValueAbstraction_list res = new_ValueAbstraction_list();

    assert( xl->sz == formals->sz );
    for( unsigned int ix=0; ix<xl->sz; ix++ ){
	FormalParameter formal = formals->arr[ix];

	if( formal->t->tag != TAGTypeType ){
	    res = append_ValueAbstraction_list(
		res,
		new_ValueAbstraction(
		    formal->name->sym,
		    rdup_expression( xl->arr[ix] )
		)
	    );
	}
    }
    return res;
}

// Given a SparProgramUnit 'unit', the entire program 'prog', the
// symbol table entry of the type 'te', and a list of constant expressions
// 'xl', create a new instance of the type 'te' that is specialized for 'xl'.
static SparProgramUnit specialize_SparProgramUnit_type(
 const_origin org,
 SparProgramUnit unit,
 SparProgram prog,
 const_ConcreteTypeEntry te,
 const_expression_list xl
)
{
    unsigned int pos;
    TypeDeclaration dcl;

    if( !search_TypeDeclaration( unit, te->name->sym, &dcl ) ){
	internal_error( "The unit in file '%s' does not define type '%s'", unit->path, te->name->sym->name );
    }

    (void) check_duplicate_FormalParameters( dcl->formals );
    // Continue, even if the above check failed.

    // Make a clone of the declaration.
    TypeDeclaration clone = rdup_TypeDeclaration( dcl );

    // Think of a new name for the clone.
    // (note that this should not be a qualified name.)
    clone->name->sym = gen_tmsymbol( clone->name->sym->name );

    tmsymbol generic_entryname = te->name->sym;

    tmsymbol clone_entryname = clone->name->sym;
    clone_entryname = qualify_tmsymbol( te->package, clone_entryname );
    if( trace_generics ){
	tmstring nmxl = name_expression_list( xl );
	fprintf(
	    stderr,
	    "Constructing generic type instance %s, (=%s%s)\n",
	    clone_entryname->name,
	    te->name->sym->name,
	    nmxl
	);
	rfre_tmstring( nmxl );
    }

    // Since this will be a specialized clone, it has no formals
    rfre_FormalParameter_list( clone->formals );
    clone->formals = new_FormalParameter_list();

    // Construct the mapping lists for the parameter substitution.
    // Make sure that you rename constructors too.
    TypeAbstraction_list tl = build_TypeAbstraction_list(
	org,
	xl,
	dcl->formals,
	dcl->name->sym,
	clone->name->sym
    );
    ValueAbstraction_list vl = build_ValueAbstraction_list( xl, dcl->formals );

    // Do substitution.
    clone = substitute_TypeDeclaration( org, clone, tl, vl );
    if( trace_generics ){
	dump_statement( stderr, clone, "Instantiation resulted in" );
    }
    rfre_TypeAbstraction_list( tl );
    rfre_ValueAbstraction_list( vl );

    // Register the clone in the list of generics mappings.
    unit->decls = append_statement_list( unit->decls, clone );
    regtype_TypeDeclaration( &prog, clone, unit, &unit->typebindings, te->enclosingtype );
    if( !search_GenericMapping_list( prog->generics, generic_entryname, &pos ) ){
	prog->generics = append_GenericMapping_list(
	    prog->generics,
	    new_GenericMapping(
		dcl->name->sym,
		rdup_FormalParameter_list( dcl->formals ),
		new_GenericBinding_list()
	    )
	);
	pos = prog->generics->sz-1;
    }
    GenericMapping gm = prog->generics->arr[pos];
    gm->bindings = append_GenericBinding_list(
	gm->bindings,
	new_GenericBinding(
	    rdup_expression_list( xl ),
	    clone_entryname
	)
    );

    TypeEntry clone_te = lookup_TypeEntry( prog->typelist, clone_entryname );
    clone_te->usecount++;
    unit = mangle_SparProgramUnit_type( unit, prog, clone_te );

    return unit;
}

// Given a SparProgram 'prog', a TypeEntry 'me', and an expression list 'xl',
// construct a new instance of the type that is instantiated with the given
// values. The instantiated type is added to the same program unit as the
// parameterized version.
static bool specialize_SparProgram_type(
 const_origin org,
 SparProgram prog,
 const_ConcreteTypeEntry me,
 const_expression_list xl
)
{
    unsigned int unit_pos;

    // TODO: be more precise; this fails if 'name' is an inner class.
    if( !search_type_SparProgramUnit_list( prog->units, me->name->sym, &unit_pos ) ){
	internal_error( "Cannot find the unit that defines '%s'", me->name->sym->name );
    }
    prog->units->arr[unit_pos] = specialize_SparProgramUnit_type(
	org,
	prog->units->arr[unit_pos],
	prog,
	me,
	xl
    );
    return true;
}

// Given a pointer to a SparProgram 'prog', the name of a type 't',
// and the list 'xl' of instantiation values, construct a new instance of
// 't' that is instantiated with the given values. Return 'false' iff
// this instantiation fails for some reason.
static bool specialize_type( const_origin org, SparProgram *prog, const_origsymbol t, const_expression_list xl )
{
    if( t == origsymbolNIL ){
	return false;
    }
    TypeEntry e = lookup_TypeEntry( (*prog)->typelist, t );
    if( e == TypeEntryNIL ){
	return false;
    }
    assert( is_ConcreteTypeEntry( e ) );
    return specialize_SparProgram_type( org, *prog, to_ConcreteTypeEntry( e ), xl );
}

static MainMethod mangle_MainMethod( SparProgram *prog, const MainMethod nm )
{
    tmsymbol first;
    tmsymbol last;

    break_qualified_tmsymbol( nm, &first, &last );
    Signature s = new_Signature( 0, last, new_type_list() );
    MethodEntry me = mangle_prolog_method( prog, first, s );
    if( me == MethodEntryNIL ){
        return tmsymbolNIL;
    }
    rfre_Signature( s );
    return me->name;
}

static void mangle_type_members( SparProgram *prog, const_TypeDeclaration decl, tmsymbol owner )
{
    origsymbol fullname = rdup_origsymbol( decl->name );

    fullname->sym = qualify_tmsymbol( owner, fullname->sym );
    if( !visit_type( prog, fullname ) ){
	rfre_origsymbol( fullname );
        return;
    }
    const_TypeEntry e = lookup_TypeEntry( (*prog)->typelist, fullname );
    // TODO: also touch fields of the type.
    if( is_ObjectTypeEntry( e ) ){
	const_ObjectTypeEntry ote = to_const_ObjectTypeEntry(e);
	const_MethodMapping_list methods = ote->methods;

	if( e->tag == TAGClassEntry ){
	    const_MethodMapping_list constructors = to_const_ClassEntry(e)->constructors;
	    for( unsigned int ix=0; ix<constructors->sz; ix++ ){
		const_MethodMapping fn = constructors->arr[ix];

		mangle_prolog_constructor( prog, fullname->sym, fn->realname );
	    }
	}
	for( unsigned int iy=0; iy<methods->sz; iy++ ){
	    const_MethodMapping fn = methods->arr[iy];

	    if( has_any_flag( fn->realname->flags, ACC_INIT ) ){
#if 1
	        if( has_any_flag( fn->realname->flags, ACC_STATIC ) ){
		    if(
		        !ote->staticInitTrivial &&
			ote->staticInit != tmsymbolNIL
		    ){
			(void) mangle_prolog_method( prog, fullname->sym, fn->realname );
		    }
		}
		else {
		    // Dynamic initializer needn't be visited separately,
		    // Since we visit all constructors.
		}
#endif
	    }
	    else {
		(void) mangle_prolog_method( prog, fullname->sym, fn->realname );
	    }
	}
    }
    const_statement_list body = decl->body;
    for( unsigned int i=0; i<body->sz; i++ ){
        const_statement smt = body->arr[i];

	if( is_TypeDeclaration( smt ) ){
	    const_TypeDeclaration td = to_const_TypeDeclaration( smt );

	    mangle_type_members( prog, td, fullname->sym );
	}
    }
    rfre_origsymbol( fullname );
}

// Given a program unit, force compilation of all members of all types
// declared in this unit.
static void mangle_unit_members( SparProgram *prog, const_SparProgramUnit topunit )
{
    statement_list decls = topunit->decls;
    tmsymbol owner = tmsymbolNIL;

    if( topunit->packagename != origsymbolNIL ){
        owner = topunit->packagename->sym;
    }
    for( unsigned int ix=0; ix<decls->sz; ix++ ){
        const_statement decl = decls->arr[ix];

	if( is_TypeDeclaration( decl ) ){
	    mangle_type_members( prog, to_const_ClassDeclaration( decl ), owner );
	}
    }
}

static MainMethod mangle_exceptor_method( SparProgram *prog, const MainMethod nm )
{
    tmsymbol first;
    tmsymbol last;

    break_qualified_tmsymbol( nm, &first, &last );
    Signature s = new_Signature(
	0,
	last,
	append_type_list(
	    new_type_list(),
	    new_ObjectType( add_origsymbol( "java.lang.Exception" ) )
	)
    );
    MethodEntry me = mangle_prolog_method( prog, first, s );
    rfre_Signature( s );
    if( me == MethodEntryNIL ){
	internal_error( "Cannot find internal method '%s'", nm->name );
    }
    return me->name;
}

// Make sure that the method spar.compiler.Builder.bound is
// visited, and return the mangled name of that method.
static MainMethod mangle_boundsviolator_method( SparProgram *prog )
{
    tmsymbol tnm = add_tmsymbol( "spar.compiler.Builder" );
    const char *methodnm;
    
    if( boundviolation_is_caught ){
        methodnm =  "bound";
    }
    else {
        methodnm =  "boundExit";
    }
    Signature s = new_Signature( 0, add_tmsymbol( methodnm ), new_type_list() );
    MethodEntry me = mangle_prolog_method( prog, tnm, s );
    if( me == MethodEntryNIL ){
	tmstring sig = typename_Signature( s );
	internal_error( "Cannot find internal method '%s.%s'", tnm->name, sig );
    }
    rfre_Signature( s );
    return me->name;
}

// Make sure that the method spar.compiler.Builder.outOfMemory is
// visited, and return the mangled name of that method.
static MainMethod mangle_outofmemory_method( SparProgram *prog )
{
    tmsymbol tnm = add_tmsymbol( "spar.compiler.Builder" );
    Signature s = new_Signature( 0, add_tmsymbol( "outOfMemory" ), new_type_list() );
    MethodEntry me = mangle_prolog_method( prog, tnm, s );
    if( me == MethodEntryNIL ){
	tmstring sig = typename_Signature( s );
	internal_error( "Cannot find internal method '%s.%s'", tnm->name, sig );
    }
    rfre_Signature( s );
    return me->name;
}

// Make sure that the method spar.compiler.Builder.nul is
// visited, and return the mangled name of that method.
static MainMethod mangle_nullpointer_method( SparProgram *prog )
{
    const char *methodnm;

    if( nullptr_is_caught ){
	methodnm = "nul";
    }
    else {
	methodnm = "nulExit";
    }
    tmsymbol tnm = add_tmsymbol( "spar.compiler.Builder" );
    Signature s = new_Signature( 0, add_tmsymbol( methodnm ), new_type_list() );
    MethodEntry me = mangle_prolog_method( prog, tnm, s );
    if( me == MethodEntryNIL ){
	tmstring sig = typename_Signature( s );
	internal_error( "Cannot find internal method '%s.%s'", tnm->name, sig );
    }
    rfre_Signature( s );
    return me->name;
}

// Make sure that the method spar.compiler.GC.collect is
// visited, and return the mangled name of that method.
static MainMethod mangle_garbagecollector_method( SparProgram *prog )
{
    tmsymbol tnm = add_tmsymbol( "spar.compiler.GC" );
    Signature s = new_Signature( 0, add_tmsymbol( "collect" ), new_type_list() );
    MethodEntry me = mangle_prolog_method( prog, tnm, s );
    if( me == MethodEntryNIL ){
	tmstring sig = typename_Signature( s );
	internal_error( "Cannot find internal method '%s.%s'", tnm->name, sig );
    }
    rfre_Signature( s );
    return me->name;
}

// Make sure that the native method spar.compiler.GC.pushRef(Object obj) is
// visited.
static void mangle_pushRef_method( SparProgram *prog )
{
    tmsymbol tnm = add_tmsymbol( "spar.compiler.GC" );

    Signature s = new_Signature(
	0,
	add_tmsymbol( "pushRef" ),
	append_type_list(
	    new_type_list(),
	    new_ObjectType( add_origsymbol( "java.lang.Object" ) )
	)
    );
    MethodEntry me = mangle_prolog_method( prog, tnm, s );
    if( me == MethodEntryNIL ){
	tmstring sig = typename_Signature( s );
	internal_error( "Cannot find method '%s.%s'", tnm->name, sig );
    }
    rfre_Signature( s );
}

/* Mangle a SparProgram. */
SparProgram mangle_SparProgram( SparProgram prog, const_SparProgramUnit unit, bool verifymode )
{
    // First touch java.lang.String, since it's almost
    // a primitive type.
    origsymbol str = add_origsymbol( "java.lang.String" );
    bool ok = visit_type( &prog, str );
    rfre_origsymbol( str );
    if( !ok ){
	return SparProgramNIL;
    }
    if( verifymode ){
	// We want to compile as much as possible of the class, since
	// we are running a verifier such as Jacks on this.
	// Mangle all methods in the main class.
	mangle_unit_members( &prog, unit );
    }
    else {
	// We are compiling a normal program. Only compile stuff that
	// is necessary.
	prog->main = mangle_MainMethod( &prog, prog->main );
    }
    prog->exceptor = mangle_exceptor_method( &prog, prog->exceptor );
    prog->boundsviolator = mangle_boundsviolator_method( &prog );
    prog->outofmemory = mangle_outofmemory_method( &prog );
    prog->nullpointer = mangle_nullpointer_method( &prog );
    prog->garbagecollector = mangle_garbagecollector_method( &prog );
    mangle_pushRef_method( &prog );
    return prog;
}
